# 1.常用指令

**作用**：在渲染的`DOM`上应用特殊的响应式行为。

| {{ }}         | mustache语法（插值表达式）                                   |
| ------------- | ------------------------------------------------------------ |
| **v-text**    | **渲染文本，功能类似 {{ }}，采用了表达式的形式，且会覆盖掉文本里的内容，不推荐使用因为不够灵活** |
| **v-html**    | **采用表达式的形式，以 html 的结构去解析渲染代码**           |
| **v-pre**     | **单纯的指令，不交给 vue 去解析渲染目标代码段。我们写的什么，呈现出来就是什么** |
| **v-once**    | **单纯的指令，页面数据仅渲染一次，以后数据的更新并不会触发目标对象进行数据重新更新操作。** |
| **v-cloak**   | **单纯的指令，解决页面加载时候的闪烁问题**                   |
| **v-bind**    | **属性绑定机制，语法糖 `:`，内部可写一些简单合法的`js`表达式** |
| **v-on**      | **监听事件绑定机制，语法糖 `@`**                             |
| **v-if**      | **条件判断**                                                 |
| **v-else-if** | **条件判断**                                                 |
| **v-else**    | **条件判断**                                                 |
| **v-show**    | **决定元素要不要显示出来**                                   |
| **v-for**     | **循环遍历**                                                 |
| **v-model**   | **双向数据绑定，只应用于表单元素**                           |

## `{{}}`

```html
<body>
   <div id="app">{{ message }}</div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            message: 'sxw'
         }
      })
   </script>
</body>
```

```html
<body>
   <div id="app">
      <!-- 双段号可进行简单的运算 -->
      <h3>{{ firstName + lastName }}</h3>
      <h3>{{ firstName }} {{ lastName }}</h3>
      <h3>{{ firstName + ' ' + lastName }}</h3>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            firstName: 'shu',
            lastName: 'xiaowei'
         }
      })
   </script>
</body>
```



## `v-text`

```html
<body>
   <div id="app">
      <h3 v-text="message">此处内容被覆盖</h3>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            message: 'sxw'
         }
      })
   </script>
</body>
```



## `v-html`

```html
<body>
   <div id="app">
      <h3 v-html="url">此处内容被覆盖</h3>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            url: '<a href="https://www.baidu.com">百度一下</a>'
         }
      })
   </script>
</body>
```



## `v-pre`

```html
<body>
   <div id="app">
      <h3 v-pre>{{ message }}</h3>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            message: "sxw"
         }
      })
   </script>
</body>
```



## `v-once`

在浏览器控制台通过 `app.message = 3`来改变`data`数据，可以发现页面并不会更新。



## `v-cloak`

**原理**：在还没有进行`Vue`解析之前，目标元素上是存在`v-cloak`属性的。对应的`display: none;`样式生效。当`vue`解析到目标代码，也就是`Vue`目前已经携带了`data`数据了，就会自动移除目标元素上的`v-cloak`属性，实现了完美的过渡。

```html
<style>
  [v-cloak] {
     display: none;
  }
</style>
<body>
   <div id="app">
      <h3 v-cloak>{{ message }}</h3>
   </div>
   <script>
      setTimeout(function() {
        const app = new Vue({
            el: '#app',
            data: {
               message: "sxw"
            }
         }) 
      }, 2000)
   </script>
</body>
```



## `v-bind`

### 动态绑定`class`属性

#### 对象形式

```html
<style>
  .color{
     color: red;
  }
  .fontSize{
     font-size: xx-large;
  }
</style>
<body>
   <div id="app">
      <!-- 对象形式 -->
      <span v-bind:class="{color: true, fontSize: true}">{{ message }}</span>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            message: "sxw"
         }
      }) 
   </script>
</body>
```

```html
<style>
  .color{
     color: red;
  }
  .fontSize{
     font-size: xx-large;
  }
</style>
<body>
   <div id="app">
      <span v-bind:class="{color: isColor,fontSize: isLarger}">{{ message }}</span>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            message: "sxw",
            // 提取出来以便控制
            isColor: true,
            isLarger: true
         }
      }) 
   </script>
</body>
```

```html
<style>
  .color{
     color: red;
  }
  .fontSize{
     font-size: xx-large;
  }
</style>
<body>
   <div id="app">
      <span v-bind:class="getClass()">{{ message }}</span>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            message: "sxw",
            isColor: true,
            isLarger: true
         },
         methods: {
            getClass() {
               return {color: this.isColor,fontSize: this.isLarger}
            }
         }
      }) 
   </script>
</body>
```

---

```html
<style>
  .color{
     color: red;
  }
  .fontSize{
     font-size: xx-large;
  }
</style>
<body>
   <div id="app">
      <span v-bind:class="getClass()">{{ message }}</span>
      <button v-on:click="changeColor">变换颜色</button>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            message: "sxw",
            isColor: true,
            isLarger: true
         },
         methods: {
            changeColor() {
               this.isColor = !this.isColor
            },
            getClass() {
               return {color: this.isColor,fontSize: this.isLarger}
            }
         }
      }) 
   </script>
</body>
```

#### 数组形式

```html
<style>
  .color{
     color: red;
  }
  .fontSize{
     font-size: xx-large;
  }
</style>
<body>
   <div id="app">
      <span v-bind:class="['color','fontSize']">{{ message }}</span>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            message: "sxw"
         }
      }) 
   </script>
</body>
</html>
```

```html
<style>
  .color{
     color: green;
  }
  .fontSize{
     font-size: xx-large;
  }
</style>
<body>
   <div id="app">
      <span v-bind:class="[color, fontSize]">{{ message }}</span>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            message: "sxw",
            color: 'color',
            fontSize: 'fontSize'
         }
      }) 
   </script>
</body>
```

```html
<style>
  .color{
     color: red;
  }
  .fontSize{
     font-size: xx-large;
  }
</style>
<body>
   <div id="app">
      <span v-bind:class="getClass()">{{ message }}</span>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            message: "sxw",
            color: 'color',
            fontSize: 'fontSize'
         },
         methods: {
            getClass() {
               return [this.color, this.fontSize]
            }
         }
      }) 
   </script>
</body>
```

### 动态绑定`style`样式属性 

#### 对象形式 

```html
<body>
   <div id="app">
      <span v-bind:style="{color: 'red',fontSize: '100px'}">{{ message }}</span>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            message: 'sxw'
         }
      })
   </script>
</body>
```

```html
<body>
   <div id="app">
      <span v-bind:style="{color: finalColor,fontSize: finalFontSize}">{{ message }}</span>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            message: 'sxw',
            finalColor: 'red',
            finalFontSize: '120px'
         }
      })
   </script>
</body>
```

```html
<body>
   <div id="app">
      <span v-bind:style="{color: finalColor,fontSize: finalFontSize + 'px'}">{{ message }}</span>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            message: 'sxw',
            finalColor: 'red',
            finalFontSize: 10
         }
      })
   </script>
</body>
```

```html
<body>
   <div id="app">
      <span v-bind:style="getStyle()">{{ message }}</span>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            message: 'sxw',
            finalColor: 'red',
            finalFontSize: 10
         },
         methods: {
            getStyle() {
               return {color: this.finalColor,fontSize: this.finalFontSize + 'px'}
            }
         }
      })
   </script>
</body>
```

#### 数组形式

```html
<body>
   <div id="app">
      <span v-bind:style="[baseStyle1,baseStyle2]">{{ message }}</span>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            message: 'sxw',
            baseStyle1: {color: 'red'},
            baseStyle2: {fontSize: '100px'}
         }
      })
   </script>
</body>
```



## `v-on`

```html
<body>
   <div id="app">
      <!-- 情况1: 当事件调用的方法没有参数时,默认省略小括号(),以下两种方式是一样的 -->
      <button @click="btnClick">按钮A</button>
      <button @click="btnClick()">按钮B</button>

      <!-- 情况2: 当事件方法本身具有一个参数时,我们不给其传递参数并且省略了小括号,那么Vue默认会将浏览器原生事件event当作参数传递到方法中 -->
      <button @click="btn2Click">按钮C</button>

      <!-- 2.1 正常传递参数 -->
      <button @click="btn2Click('111')">按钮D</button>

      <!-- 2.2 函数需要参数,但没有进行传递,那么函数的形参为undefined输出 -->
      <button @click="btn2Click()">按钮E</button>

      <!-- 情况3: 在方法定义时,我们需要event对象又需要进行其他参数的传递,可通过$event实现 -->
      <button @click="btn3Click('111', $event)">按钮F</button>
       
      <!-- 3.1 下面的第一个参数是变量sxw,会自动去data中找变量sxw -->
      <button @click="btn3Click(sxw, $event)">按钮G</button>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            sxw: 'The Chosen 1'
         },
         methods: {
            btnClick() {
               console.log('111')
            },
            btn2Click(event) {
               console.log(event)
            },
            btn3Click(a, event) {
               console.log(a,'---',event)
            }
         }
      })
   </script>
</body>
```

#### 修饰符

```html
<body>
   <div id="app">
      <div @click="divClick">
         aaaaaa
         <!-- 相当于原生的event.stopPropagation,阻止所有往外的冒泡 -->
         <button @click.stop="btnClick">按钮</button>
      </div>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         methods: {
            divClick() {
               console.log('divClick')
            },
            btnClick() {
               console.log('btnClick')
            }
         }
      })
   </script>
</body>
```

```html
<body>
   <div id="app">
      <form action="baidu">
         <!-- 当我们不加.prevent,点击按钮会自动跳转提交,.prevent会阻止默认行为事件,相当于原生的event.preventDefault -->
         <input type="submit" value="提交" @click.prevent="submitClick">
      </form>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         methods: {
            submitClick() {
               console.log('...')
            }
         }
      })
   </script>
</body>
```

```html
<body>
   <div id="app">
      <!-- 仅监听enter按键,在键盘抬起时触发事件 -->
      <input type="text" @keyup.enter="keyUp" />
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         methods: {
            keyUp() {
               console.log('...')
            }
         }
      })
   </script>
</body>
```

```html
<body>
   <div id="app">
      <!-- .once只触发一次回调 -->
      <button @click.once="btnClick">按钮</button>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         methods: {
            btnClick() {
               console.log('....')
            }
         }
      })
   </script>
</body>
```

其他按键修饰符：`.enter`、`.tab`、`.delete`、`.esc`、`.space`、`.up`、`.down`、`.left`、`.right`

[键盘事件对应的keyCode码](http://www.cnblogs.com/wuhua1/p/6686237.html)

其他修饰符：

- ==.self== 只当事件在元素本身触发时触发回调，不让子元素事件触发自己绑定的事件，且不会阻止冒泡继续。

- ==.native== 监听组件根元素的原生事件。

- ==.capture== 添加事件侦听器时，使用事件捕获模式。



## `v-if`、`v-else-if`、`v-else`

```html
<body>
   <div id="app">
      <!-- v-if中的条件flag成立(true),则显示元素  -->
      <h1 v-if="flag">{{ msg }}</h1>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            msg: 'sxw',
            flag: true
         }
      })
   </script>
</body>
```

```html
<body>
   <div id="app">
      <!-- 当v-if中的条件成立的时候,元素显示。否则显示v-else中对应的元素 -->
      <h1 v-if="flag">{{ msg }}</h1>
      <h2 v-else>v-if中条件不成立时,显示v-else中的内容</h2>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            msg: 'sxw',
            flag: true
         }
      })
   </script>
</body>
```

```html
<body>
   <div id="app">
      <h1 v-if="score >= 90">优秀</h1>
      <h1 v-else-if="score >= 70">良好</h1>
      <h1 v-else-if="score >= 60">及格</h1>
      <h1 v-else>不及格</h1>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            score: 99
         }
      })
   </script>
</body>
```

```html
<!-- 使用计算属性优化上述需求 -->
<body>
   <div id="app">
      <h1>{{ result }}</h1>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            score: 99
         },
         computed: {
            result() {
               let showMessage = ''
               if(this.score >= 90) {
                  showMessage = '优秀'
               }else if(this.score >= 70) {
                  showMessage = '良好'
               }else if(this.score >= 60) {
                  showMessage = '及格'
               }else {
                  showMessage = '不及格'
               }
               return showMessage
            }
         }
      })
   </script>
</body>
```

```html
<!-- 需求: 实现用户登录方式切换 -->
<body>
   <div id="app">
      <span v-if="flag">
         <!-- label中的for属性和input中的id属性相对应,实现了点击label内容自动聚焦input框 -->
         <label for="userName">用户账号</label>
         <input id="userName" type="text" placeholder="用户账号" :key="1">
      </span>
      <span v-else>
         <label for="email">用户邮箱</label>
         <input id="email" type="text" placeholder="用户邮箱" :key="2" />
      </span>
      <button @click="flag = !flag">切换</button>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            flag: true  
         }
      })
   </script>
</body>
```

==注意==：上述代码存在一个`bug`，涉及到`Vue`底层原理。

当用户往`input`中输入内容后，发现自己需要切换一种模式去输入内容。然而在切换之后，原先输入框中的内容依旧存在，而不是我们想要的，当用户切换一种模式后，输入框中的内容会被自动清除掉。

我们回到代码，发现用户账号和用户邮箱下明明是两个独立的`input`框，当用户点击切换时，理应是自动置空的，可为什么实现起来不是这样？



![虚拟dom](D:\notes\Vue\img\04.指令\虚拟dom.png)



==辨析==：因为`Vue`在进行`DOM`渲染的时候，出于性能考略，会尽可能地复用已经存在的元素，而不是重新渲染新元素。

上述案例，`Vue`内部会发现原来的`input`元素已经不再使用了，通过对比（`diff`算法）发现即将要渲染的`DOM`元素与之前的`input`相似，`Vue`就直接将其再次渲染并作为`else`中的`input`来使用。

`Vue`真正在渲染元素的时候，并不会直接将我们的元素渲染到页面上去。而是先将元素渲染进虚拟`dom`中，也就是放入内存中，再将虚拟`dom`中的内容渲染到页面。

所以在上述例子中，两种可能并不会同时渲染到页面中去。在虚拟`dom`进行渲染的时候，会先看看自己内存中有没有保存了一份，而不会在虚拟`dom`中重新创建出一份来。将原先的那些东西往我们的界面上进行渲染，然后你会发现我们现在在用的依旧是我们之前在页面中使用的`label`、`input`。但在渲染页面的时候，虚拟`dom`还会进行一个对比，将目标`DOM`中改变了的属性重新渲染，而对于渲染的多余的属性（也就是我们在一种模式下`input`中输入的值）并不会进行删除操作。所以当用户输入一个`333`的时候， `<input value="333" />`中的`value`属性并不会被删除，而是直接被渲染出来了。

==解决方案==：在不同的`input`后面添加一个属性`key`作为唯一标识。

`key`值的不同表示我这个`input`是独一无二的。当拥有属性`key`值不同的时候，虚拟`dom`在渲染的时候，就不会将其复用了。



## `v-show`

```html
<body>
   <div id="app">
      <h1 v-show="flag">{{ msg }}</h1>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            msg: 'sxw',
            flag: true
         }
      })
   </script>
</body>
```

### 辨析`v-show`和`v-if`

**使用建议**：当需要频繁显示和隐藏，使用`v-show`。当只有一次切换，使用`v-if`。

```html
<body>
   <div id="app">
      <!-- 两者都是隐藏元素 -->
      <!-- v-show是给目标元素的行内样式添加了display: none; -->
      <!-- v-if是直接将元素删除 -->
      <h1 v-show="flag">{{ msg }}</h1>
      <h1 v-if="flag">{{ msg }}</h1>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            msg: 'sxw',
            flag: true
         }
      })
   </script>
</body>
```



## `v-for` 

### 遍历数组

```html
<body>
   <div id="app">
      <ul>
         <li v-for="item in movies">{{ item }}</li>
      </ul>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            movies: ['七龙珠','铁甲小宝','卡布达']
         }
      })
   </script>
</body>
```

```html
<body>
   <div id="app">
      <ul>
         <li v-for="(item,index) in movies">{{ index }} - {{ item }}</li>
      </ul>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            movies: ['七龙珠','铁甲小宝','卡布达']
         }
      })
   </script>
</body>
```

### 遍历对象

```html
<body>
   <div id="app">
      <ul>
         <!-- 遍历对象时,如果只获取到了一个值,则获取到的是value -->
         <li v-for="item in obj">{{ item }}</li>
      </ul>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            obj: {
               name: 'sxw',
               age: 18
            }
         }
      })
   </script>
</body>
```

```html
<body>
   <div id="app">
      <ul>
         <li v-for="(value,key) in obj">{{ key }} - {{ value }}</li>
      </ul>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            obj: {
               name: 'sxw',
               age: 18
            }
         }
      })
   </script>
</body>
```

```html
<body>
   <div id="app">
      <ul>
         <li v-for="(value,key,index) in obj">{{ index }} - {{ key }} - {{ value }}</li>
      </ul>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            obj: {
               name: 'sxw',
               age: 18
            }
         }
      })
   </script>
</body>
```

### 遍历数字 

```html
<body>
   <div id="app">
      <ul>
         <li v-for="i in 3">{{ i }}</li>
      </ul>
   </div>
   <script>
      const app = new Vue({
         el: '#app'
      })
   </script>
</body>
```

### 遍历字符串 

```html
<body>
   <div id="app">
      <ul>
         <li v-for="num in 'shuxiaowei'">{{ num }}</li>
      </ul>
   </div>
   <script>
      const app = new Vue({
         el: '#app'
      })
   </script>
</body>
```

==注意==：官方推荐在使用`v-for`的时候，给对应的元素或者组件添加一个`:key`属性，实现更好的复用。

在组件中使用`v-for`进行遍历的时候，`key`值是必须的。

提供了唯一的`key`值以便跟踪每个节点的身份，重用和重新排序现有元素，并且`key`值只接受`number`或`string`类型。

```html
<body>
   <div id="app">
      <ul>
         <!-- 现在我们要在渲染出来的A和B之间插入一个新元素D,那么key就起到作用了 -->
         <li v-for="item in arr" :key="item">{{ item }}</li>
      </ul>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            arr: ['A','B','C']
         }
      })
   </script>
</body>
```

![v-for循环时的key值](D:\notes\Vue\img\04.指令\v-for循环时的key值.png)



# 2.数组的响应式方法

```html
<body>
   <div id="app">
      <ul>
         <li v-for="(item,index) in arr" :key="item + index">{{ item }}</li>
      </ul>
      <button @click="btnClick">按钮</button>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            arr: ['A','B','C']
         },
         methods: {
            btnClick() {
               // 响应式数组方法:
               // 1.push() 参数可以有多个,在数组最后追加元素
               // this.arr.push('D','E')

               // 2.pop() 将最后一个元素删除
               // this.arr.pop()

               // 3.shift() 将数组第一个元素删除
               // this.arr.shift()

               // 4.unshift() 在数组头部添加元素
               // this.arr.unshift('D')

               // 5.splice() 删除/插入/替换元素
               // 删除元素: 有两个参数,第一个参数是起始位置,第二个参数是要删除的元素个数,若没有传,则表示删除起始位置后面的所有元素
               // this.arr.splice(1) //删除A后面的所有元素
               // this.arr.splice(1,1) //删除A后面的1个元素也就是删除B
               // 替换元素: 有两个参数,第一个参数同上,第二个参数表示我们要替换几个元素,然后后面跟上用于替换的具体元素
               // this.arr.splice(1,1,'D') //从第一位后替换1个元素,用D进行替换
               // this.arr.splice(1,1,'D','E','F')
               // this.arr.splice(1,0,'D','E') //当第二个参数为0时,表示插入元素

               // 6.sort() 排序
               // this.arr.sort() // 可传递一个函数

               // 7.reverse() 反转
               // this.arr.reverse()
               
               // 8.Vue内部自带的set方法
               // set(要修改的对象,索引值,修改成)
               Vue.set(this.letter, 0, '111') //将A修改为 '111'
            }
         }
      })
   </script>
</body>
```

```html
<body>
   <div id="app">
      <ul>
         <li v-for="(item,index) in arr" :key="item + index">{{ item }}</li>
      </ul>
      <button @click="btnClick">按钮</button>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            arr: ['A','B','C']
         },
         methods: {
            btnClick() {
               // 非响应式数组方法:
               // 数据确实改变了,但是界面没有重新渲染,因为Vue内部没有监听这种方法去重新渲染我们的数据。不过我们可以使用splice去代替这种方法实现效果。
               console.log(this.arr[0]) // A
               this.arr[0] = '111'
            }
         }
      })
   </script>
</body>
```

# 3.可遍数组

```js
// ...num 会将我们传入的所有数据都存放到一个数组中保存起来
function sum(...num) {
    console.log(num)
}
sum(1,2,3,4,5,6,7)
```

# 4.代码

```html
<style>
  .active{
     color: red;
  }
</style>
<body>
   <div id="app">
      <ul>
         <!-- 点击哪个li哪个li变红 -->
         <li 
            v-for="(item,index) in movies" 
            :key="item + index"
            :class="{active: aimIndex === index}"
            @click="liClick(index)">{{ item }}</li>
      </ul>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            movies: ['绿皮书','了不起的盖茨比','楚门的世界'],
            aimIndex: 0 // 第一个li变红
         },
         methods: {
            liClick(index) {
               this.aimIndex = index
            }
         }
      })
   </script>
</body>
```

```html
<style>
  tabel{
     border: 1px solid #e9e9e9;
     border-collapse: collapse;
     border-spacing: 0;
  }
  th, td{
     padding: 8px 16px;
     border: 1px solid #e9e9e9;
     text-align: left;
  }
  th{
     background-color: #f7f7f7;
     color: #5c6b77;
     font-weight: 600;
  }
</style>
<body>
   <div id="app">
      <div v-if="books.length">
         <table>
            <thead>
               <tr>
                  <th></th>
                  <th>书籍名称</th>
                  <th>出版日期</th>
                  <th>价格</th>
                  <th>购买数量</th>
                  <th>操作</th>
               </tr>
            </thead>
            <tbody>
               <tr v-for="(item,index) in books">
                  <td>{{ item.id }}</td>
                  <td>{{ item.name }}</td>
                  <td>{{ item.date }}</td>
                  <!-- <td>{{ getFinalPrice(item.price) }}</td> -->
                  <td>{{ item.price | showPrice }}</td>
                  <td>
                     <button @click="decrement(index)" :disabled="item.count <= 1">-</button>
                     {{ item.count }}
                     <button @click="increment(index)">+</button>
                  </td>
                  <td><button @click="removeHandle(index)">移除</button></td>
               </tr>
            </tbody>
         </table>
         <h2>总价格：{{ totalPrice | showPrice }}</h2>
      </div>
      <h2 v-else>购物车为空</h2>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            books: [
               {
                  id: 1,
                  name: '《算法1》',
                  date: '2019-1',
                  price: 12.00,
                  count: 1
               },
               {
                  id: 2,
                  name: '《算法2》',
                  date: '2019-2',
                  price: 22.00,
                  count: 1
               },
               {
                  id: 3,
                  name: '《算法3》',
                  date: '2019-3',
                  price: 32.00,
                  count: 1
               },
               {
                  id: 4,
                  name: '《算法4》',
                  date: '2019-4',
                  price: 42.00,
                  count: 1
               }
            ]
         },
         methods: {
            // 方式1.处理我们要呈现出来的价格
            getFinalPrice(price) {
               // .toFixed(2) 保留两位小数
               return '￥' + price.toFixed(2)
            },
            increment(index) {
               this.books[index].count ++
            },
            decrement(index) {
               this.books[index].count --
            },
            removeHandle(index) {
               this.books.splice(index, 1)
            }
         },
         computed: {
            totalPrice() {
               // 以下是计算价格的4种方法！
                
               // 1.普通的for循环
               // let totalPrice = 0
               // for(let i = 0;i < this.books.length;i ++) {
               //    totalPrice += this.books[i].price * this.books[i].count
               // }
               // return totalPrice;

               // 2.for-in 拿到每项的索引值
               // let totalPrice = 0
               // for(let i in this.books) {
               //    // console.log(i) 拿到的i是索引值
               //    totalPrice += this.books[i].price * this.books[i].count
               // }
               // return totalPrice;

               // 3.for-of 拿到数组中的每一项
               // let totalPrice = 0
               // for(let item of this.books) {
               //    totalPrice += item.price * item.count
               // }
               // return totalPrice

               // 4.高阶函数 reduce
               return this.books.reduce(function(preValue, book) {
                  return preValue + book.price * book.count
               }, 0)
            }
         },
         // 方式2.使用过滤器处理价格
         filters: {
            showPrice(price) {
               return '￥' + price.toFixed(2)
            }
         }
      })
   </script>
</body>
```

# 5.过滤器

用做一些常见的文本格式化，常使用在`{{}}`和`v-bind`表达式中。

格式：`{{ name | nameope }}`

在输出`name`值之前，先调用`nameope`进行过滤处理，并将最终结果进行渲染。

```
1.指令
<script src="./vue.js"></script> //导入vue包之后,在浏览器的内存中就多了一个Vue构造函数;
<div id="app">{{ msg }}</div>
  var vm = new Vue({ //new出来的这个对象就是MVVM中的VM调度者;
     el: '#app',
     data: { //data就是MVVM中的M,用来存放el中所有要用到的数据;
        msg: 'sxw'
     }
  })
-----------------------------------------------------------
a.加载时遇到{{ }}闪烁,因为在渲染时是这么写的 <p>{{ msg }}</p>;
b.加载时遇到空盒子,因为在渲染时是这么写的 <p v-html="html"></p>;
解决上述问题最有效的方法是在el挂载的标签上添加v-cloak指令:
    <div id="app" v-cloak>
        {{ msg }}
    </div>
    并在样式部分写上:
    [v-cloak] {
        display: none;
    }
有时会不起作用,原因有二:
	a.v-cloak的display属性被层级更高的覆盖了,所以要提高层级;
        [v-cloak] {
            display: none !important;
        }
	b.v-cloak样式放在'@import引入的css文件中'不起作用,应该放在'link引入的css文件'里或者'内联样式'中;
注意: v-cloak致使元素不闪烁,仅仅影响双段号这个占位符部分,不会影响元素其余部分;
								   <p v-cloak>+++ {{ msg }} ---</p>
-------------------------------------------------------------------
v-text/v-html 没有闪烁问题,并且会覆盖元素内容;
<h1 v-text="msg">在这里填写是无效的</h1>
<div v-html="html">在这里填写是无效的</div>
html: '<h1>我是一个h1</h1>'
------------------------------------------------------------------------------------
<input type="button" value="按钮a" :title="myTitle + '123'" @click="show">
<input type="button" value="按钮b" :mouseover="show">
mytitle: '额外添加的title'
show() {
	console.log('触发了事件')
}
-----------------------------------------------------
<span :title="message">
    鼠标悬停查看动态绑定的提示信息
</span>
message: '页面加载于' + new Date().toLocaleString() 
								//.toLocaleString() 会根据本地环境来返回时间类型的字符串
-----------------------------------------------------------------------------------
函数传值: 当函数不传参数时默认会传事件对象e,当函数传参以后想传事件对象,需要用$event来表示;
<div id="app">
 <button @click="increase(3, $event)">点击我</button> 
 <p>{{ count }}</p>
 <p :mousemove="updateXy">输出当前鼠标的x和y的值: {{x}} / {{y}}</p>
</div>
<script>
 var vue = new Vue({
    el: '#app',
    data: {
       count: 0,
       x: 0,
       y: 0
    },
    methods: {
       increase: function(step,e) {
          this.count += step
          console.log(e);
       },
       updateXy: function(e) { //事件对象使用方法
          this.x = e.clientX;
          this.y = e.clientY;
       }
    }
 })
</script>
```

```
2.事件修饰符
<style>
  .outer{
     height: 150px;
     background-color: rgb(106, 97, 187);
  }
</style>
<body>
   //事件冒泡机制: (内 ---> 外)
   //点击被outer包裹的按钮时,从内而外依次触发按钮内事件和outer外事件;
   //当在按钮中添加.stop事件修饰符后就会阻止冒泡机制,仅在当前元素上产生影响;
   <div id="app">
      <div class="outer" v-on:click="divHandler">
         <input type="button" value="按钮" v-on:click.stop="btnHandler">
      </div>
      
      //.prevent阻止默认行为,阻止表单自带的submit事件等;
      <a href="http://www.baidu.com" @click.prevent="linkClick">百度</a>

      //事件捕获机制: (外 ---> 内)
      //在父级绑定 .capture 实现捕获触发事件机制;
      //当我们点击按钮内事件时,会异于冒泡先触发外事件,再触发内事件,称之为捕获;
      <div class="outer" v-on:click.capture="divHandler">
         <input type="button" value="按钮" v-on:click="btnHandler">
      </div>
      
      //.self一般绑定于冒泡的外函数,绑定内函数没用,因为没人会影响到内函数;
      //包裹着三层,我们在第二层点击事件上添加.self,那么当点击最内层按钮时冒泡出来到第二层会被阻止,然后继续往外冒泡触发第三层;
      <div class="outer" @click.self="divHandler">
         <input type="button" value="按钮" @click="btnHandler">
      </div>

      //.once表示只阻止一次默认行为,之后便不再阻止,常连在.prevent后使用;
      <a href="http://www.baidu.com" @click.prevent.once="linkClick">百度</a>
   </div>
   <script>
      var vm = new Vue({
         el: '#app',
         methods: {
            divHandler() {
               console.log('这是触发了外面的点击事件')
            },
            btnHandler() {
                console.log('这是触发了内部的点击事件')
            },
            linkClick() {
                console.log('这是触发了链接的点击事件')
            }
         }
      })
   </script>
</body>
```

```
3.双向数据绑定
<body>
   <div id="app">
      <h4>{{ msg }}</h4>
      //v-bind只能实现数据的单向绑定,即从M绑定到V;
      <input type="text" :value="msg" style="width: 100%">

        //v-model实现表单元素和Model数据的双向绑定;
		//v-model只能运用在表单元素中;
		//表单元素: input(radio,text,address,email...) select checkbox textarea
      <input type="text" v-model="msg" style="width: 100%"> 
   </div>
   <script>
      var vm = new Vue({
         el: '#app',
         data: {
            msg: '流川枫'
         }
      })
   </script>
</body>
--------------------------------------------
模拟双向数据绑定:
<div id="app">
 <input type="text" @input="changeName">
 <h1>{{ name }}</h1>
</div>
<script>
 var vue = new Vue({
    el: '#app',
    data: {
       name: ""
    },
    methods: {
       changeName: function(event) {
          this.name = event.target.value;
       }
    }
 })
</script>
```

```
4.属性绑定设置class类样式
	<style>
      .red{
         color: red;
      }
      .thin{
         font-weight: 200;
      }
      .italic{
         font-style: italic;
      }
      .active{
         letter-spacing: 0.5em;
      }
   </style>
<body>
   <div id="app">
	  a)数组 + 三元表达式
      <h1 :class="['thin','italic',flag?'active':'']">sxw</h1>
      
      b)数组 + 对象
	  //由于对象的属性是类名,可带引号也可不带,属性值是一个标识符;
      <h1 :class="['thin', {'active': flag}]">sxw</h1>
      
      c)对象
      <h1 :class="{'red':true,active:false}">sxw</h1>
      //简化
	  <h1 :class="classObj">sxw</h1>
   </div>
   <script>
      var vm = new Vue({
         el: '#app',
         data: {
            flag: true,
            classObj: {red: true,'active': true}
         }
      })
   </script>
</body>
```

```
5.属性绑定设置style行内样式
a)在元素标签头通过:style形式绑定
	<h1 :style="{color: 'red', 'font-size': '40px'}"></h1>
b)简化a
	<h1 :style="styleObj"></h1>
    data: {
        styleObj: {color:'red', 'font-size':'40px','font-weight':'200'}
    }
c)通过数组引用多个data上的样式对象
	<h1 :style="[styleObj1, styleObj2]"></h1>
    data: {
        styleObj1: {'font-size':'40px','font-weight':'200'},
        styleObj2: {fontStyle: 'italic'}
    }
```

```
6.v-for指令
<body>
   <div id="app">
      <p>{{list[0]}}</p>
      <p>{{list[1]}}</p>
      <p>{{list[2]}}</p>
      <p v-for="(item,i) in list">索引值:{{i}} --- 每一项:{{item}}</p>

      <p v-for="(user, i) in list1">id:{{user.id}} --- 名字:{{user.name}} --- 索引：{{i}}</p>

      <!-- 遍历对象上的键值对时,除了val、key,还有i(但是用不太上) -->
		<p v-for="(val,key,i) in user">键:{{key}} --- 值:{{val}} --- 索引:{{i}}</p>

	  <!-- 注意: 用v-for迭代数字时,前面的count值从1开始 -->
		<p v-for="count in 10">第 {{count}} 次循环</p>
   </div>
   <script>
      var vm = new Vue({
         el: '#app',
         data: {
            list: [1,2,3],
            list1: [
               { id:1, name:'zs1'},
               { id:2, name:'zs2'},
               { id:3, name:'zs3'},
               { id:4, name:'zs4'}
            ],
            user: {
               id: 3,
               name: 'sxw',
               gender: 'male'
            }
         }
      })
   </script>
</body>
-----------------------------------------------------------
v-for中key值注意事项:
<body>
   <div id="app">
      <label for="">
         ID: <input type="text" v-model="id">
      </label>
      
      <label for="">
         Name: <input type="text" v-model="name">
      </label>
      
      <input type="button" value="添加" @click="add">

      <!-- v-for循环时,key属性只能使用 number 或者 string -->
      <!-- key能够保证数据的唯一性,让data和页面上的数据强制关联起来 -->
      <p v-for="item in list" :key="item.id">
         <input type="checkbox">{{item.id}} --- {{item.name}}
      </p>
   </div>
   <script>
      var vm = new Vue({
         el: '#app',
         data: {
            id: '',
            name: '',
            list:[
               {id: 1,name: 'a'},
               {id: 2,name: 'b'},
               {id: 3,name: 'c'}
            ]
         },
         methods: {
            add() {
               // push在尾部添加
               // this.list.push({id: this.id,name: this.name})
               // unshift在头部添加
               this.list.unshift({id: this.id,name: this.name})
               this.id = this.name = ''
            }
         }
      })
   </script>
</body>
--------------------------------------------------------------------------
<div id="app">
 <ul>
    <li v-for="(item,i) in movies" @click="changeMovies(i)">{{ item.movie }} | {{ item.rate }} | {{i}}</li>
 </ul>
 <button v-on:click="add">新添加一个电影</button>
</div>
<script>
 var vue = new Vue({
    el: "#app",
    data: {
       movies: [{
          movie: "我是1",
          rate: "9,0"
       },{
          movie: "我是2",
          rate: "8.0"
       },{
          movie: "我是3",
          rate: "7.0"
       }]
    },
    methods: {
    	// 在Vue中改变数组数据是不会有响应式行为的,因为数组只是引用值,当前放着的只是内存地址;
    	// 当比较新旧数组之间的内存地址有没有发生变化才会去渲染数据;
       changeMovies: function(index) {
          let arr = this.movies.concat() //将原数组赋值一份
          arr[index] = { //改变了数组中点击的一项
             movie: "西红柿首府",
             rate: "8.8"
          }
          this.movies = arr 
          //将新数组的内存地址给movies变量,检测发现新旧内存地址发生了改变,就会重新渲染数据;
       },
       add: function() { 
          this.movies.push({
             movie: "你好美丽",
             rate: "100"
          })
       }
    }
 })
</script>
```

```
7.v-if和v-show
<body>
   <div id="app">
      <input type="button" value="toggle" @click="flag=!flag">
      <h3 v-if="flag">sxw</h3>
      <h3 v-show="flag">sxw</h3>
   </div>
   <script>
      var vm = new Vue({
         el: '#app',
         data: {
            flag: true
         }
      })
   </script>
</body>
-----------------------------------------------------------------
<div id="app">
 <p v-if="items > 10">有库存{{ items }}</p>
 <p v-else-if="items <= 10 && items >= 1">快要没货了</p>
 <p v-else>对不起,没货了</p>
</div>
<script>
 var vue = new Vue({
    el: "#app",
    data: {
       items: 20
    }
 })
</script>
```

```
8.过滤器
<body>
   <div id="app">
      {{ msg | msgFormat }}
   </div>
   <script>
   	  // 1.定义全局过滤器 msgFormat;
   	  // 2.通过回调函数拿到需要处理的值 msg;
   	  // 3.函数体内进行逻辑操作;
      Vue.filter('msgFormat', function(msg) {
      	 // 字符串 replace 方法,第一个参数可写字符串 or 正则表达式;
      	 // 字符串表示只能替换一次,正则表达式能实现替换多次;
         return msg.replace('再见','我替换了')
      })
      var vm = new Vue({
         el: '#app',
         data: {
            msg: '再见青春,再见信仰,再见梦想'
         }
      })
   </script>
</body>
---------------------------------------------------------------
(正则替换)
<body>
   <div id="app">
      {{ msg | msgFormat }}
   </div>
   <script>
      Vue.filter('msgFormat', function(msg) {
      	 // 使用正则,实现替换所有
         return msg.replace(/再见/g,'我替换了')
      })
      var vm = new Vue({
         el: '#app',
         data: {
            msg: '再见青春,再见信仰,再见梦想'
         }
      })
   </script>
</body>
--------------------------------------------------
(传递参数)
<body>
   <div id="app">
   	  // 给过滤器传参 'sxw'
      {{ msg | msgFormat('sxw') }}
   </div>
   <script>
   	  // 回调函数第一个参数拿到需要处理的数 msg
   	  // 第二个参数接收我们传递过来的实现替换的参数
      Vue.filter('msgFormat', function(msg, arg) { 
         return msg.replace(/再见/g,arg)
      })
      var vm = new Vue({
         el: '#app',
         data: {
            msg: '再见青春,再见信仰,再见梦想'
         }
      })
   </script>
</body>
----------------------------------------------------
(连续调用)
<body>
   <div id="app">
      {{ msg | msgFormat('sxw') | test }}
   </div>
   <script>
      Vue.filter('msgFormat', function(msg, arg) {
         return msg.replace(/再见/g,arg)
      })
      Vue.filter('test', function(msg) {
               return msg + '连续第二次调用过滤器'
         })
      var vm = new Vue({
         el: '#app',
         data: {
            msg: '再见青春,再见信仰,再见梦想'
         }
      })
   </script>
</body>
------------------------------------------------
(定义私有过滤器)
<body>
   <div id="app">
      <h3>{{ dt | dateFormat }}</h3>
   </div>
   <script>
      var vm = new Vue({
         el: '#app',
         data: {
            dt: new Date()
         },
         filters: {
            // 过滤器调用的顺序,如果私有过滤器和全局过滤器名称一致,优先调用私有过滤器;
            // 在参数列表中,通过 pattern="" 来指定形参默认值,防止报错
            dateFormat: function(dt,pattern='') {
               var y = dt.getFullYear()
               var m = dt.getMonth() + 1
               var d = dt.getDate()
               // 如果传进来的字符串类型转为小写之后等于 yyyy-mm-dd,那么就返回 年-月-日
               // 否则返回 年-月-日 时:分:秒
               if(pattern && pattern.toLowerCase() === 'yyyy-mm-dd') {
                  return `${y}-${m}-${d}` // 使用模板字符串输出,提高可读性
               }else {
                  var hh = dt.getHours()
                  var mm = dt.getMinutes()
                  var ss = dt.getSeconds()
                  return `${y}-${m}-${d} ${hh}:${mm}:${ss}`
               }
            }
         }
      })
   </script>
</body>
```

```
9.按键修饰符
 <p v-on:mousemove="updateXy">输出当前鼠标的x和y的值: {{x}} / {{y}} 
 	<span v-on:mousemove.stop="">我不想获取x和y的值了...</span>
 </p>
 <input type="text" v-on:keyup.enter="input"> //enter键抬起时才触发input函数
<script>
 var vue = new Vue({
    el: '#app',
    data: {
       x: 0,
       y: 0
    },
    methods: {
       updateXy: function(e) { 
          this.x = e.clientX;
          this.y = e.clientY;
       },
       input: function(e) {
          alert("input");
       },
       stop: function(e) {
          e.stopPropagation() //传统阻止事件冒泡方式
       }
    }
 })
</script>
```

```
10.生命周期函数-组件运行和销毁期间的4个钩子函数
<body>
   <div id="app">
      <input type="button" value="修改msg" @click="msg='NO'">
      <h3 id="h3">{{ msg }}</h3>
   </div>
   <script>
      var vm = new Vue({
            el: '#app',
            data: {
                msg: 'ok'
            },
            methods: {
                show() {
                    console.log('执行了show方法')
                }
            },
            beforeCreate() {
               // 这是我们遇到的第一个生命周期函数,实例完全被创建出来之前会执行它;
               // console.log(this.msg) // undefined
               // this.show() //报错
               // 注意:在beforeCreate生命周期函数执行的时候,data和methods中的数据都还没有初始化;
            },
            created() {
               // 这是遇到的第二个生命周期函数
               // console.log(this.msg)
               // this.show()
               // 在created中,data和created都已经被初始化好了
               // 如果要调用methods中的方法或者操作data中的数据最早只能在created中去操作
            },
            beforeMount() {
               // 这是遇到的第三个生命周期函数;
               // 表示模板已经在内存中编辑完成了,但尚未把模板渲染到页面中;
               // console.log(document.getElementById('h3').innerText)
               // 在beforMount执行的时候,页面中的元素还没有被真正替换过来,只是之前写的一些模板字符串
            },
            mounted() {
               // 这是遇到的第四个生命周期函数;
               // 表示内存中的模板已经真实的挂载到页面中,用户已经可以看到渲染好的页面了;
               // console.log(document.getElementById('h3').innerText)
               // 注意: mounted是实例创建的最后一个生命周期函数;
               // 当执行完mounted就表示实例已经被完全创建好了,此时如果没有其他操作的话,这个实例就会呆在我们的内存中;
            },
            //接下来是运行中的两个事件
            beforeUpdate() {
               // 这个时候,我们的界面还没有被更新; [数据被更新了吗？ 数据肯定被更新了]
               // console.log('界面上元素的内容：' + document.getElementById('h3').innerText)
               // console.log('data 中的msg数据是：' + this.msg)
               // 得出结论: 执行beforeUpdate时,页面中显示的数据还是旧的,此时data中的数据是最新的,页面尚未和最新的数据保持同步;
            },
            upDated() {
               console.log('界面上元素的内容：' + document.getElementById('h3').innerText)
               console.log('data 中的msg数据是：' + this.msg)
               //updated事件执行的时候,页面和data数据已经保持同步了,都是最新的;
            }
        })
   </script>
</body>
```

```
11.watch、computed和methods对比
<div id="app">
 <button v-on:click="increase">加1</button>
 <button v-on:click="decrease">减1</button>
 <p>{{ count }}</p>
 <p>{{ outPut }}</p>
 <p>{{ result() }}</p>
</div>
<script>
 var vue = new Vue({
    el: '#app',
    data: {
       count: 0
    },
    computed: {
       outPut: function() {
          return this.count > 3 ? "大于3" : "小于3"
       }
    },
    watch: {
       count: function(val) { //第一个参数表示当前数据的最新值
          console.log(val);
          var vm = this;
          window.setTimeout(function() {
             vm.count = 0;
          },2000)
       }
    },
    methods: {
       result: function() {
          return this.count > 3 ? "大于3" : "小于3"
       },
       increase: function() {
          this.count ++;
       },
       decrease: function() {
          this.count --;
       }
    }
 })
</script>
* * *
<!DOCTYPE html>
<html lang="en"> 
<head>
  <meta charset="UTF-8">
  <title>Document</title>
  <script src="./vue.js"></script>
</head>
<body>
  <div id="app">
    <input type="text" v-model="firstname"> +
    <input type="text" v-model="lastname"> =
    <input type="text" v-model="fullname">
  </div>
  <script>
    var vm = new Vue({
      el: '#app',
      data: {
        firstname: '',
        lastname: '',
        fullname: ''
      },
      watch: { //监视 data 中指定数据的变化,然后触发对应的 function 处理函数;
        'firstname': function (newVal) {
          // console.log(newVal + ' --- ' + oldVal)
          this.fullname = newVal + '-' + this.lastname
        },
        'lastname': function (newVal) {
          this.fullname = this.firstname + '-' + newVal
        }
      }
    })
  </script>
</body>
</html>
* * *
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
  <script src="./vue.js"></script>
</head>
<body>
  <div id="app">
    <input type="text" v-model="firstname"> +
    <input type="text" v-model="middlename"> +
    <input type="text" v-model="lastname"> =
    <input type="text" v-model="fullname">
    <p>{{ fullname }}</p>
  </div>
  <script>
    var vm = new Vue({
      el: '#app',
      data: {
        firstname: '',
        lastname: '',
        middlename: ''
      },
      computed: {
        'fullname': function () {
          return this.firstname + '-' + this.middlename + '-' + this.lastname
        }
      }
    });
  </script>
</body>
</html>
```

```
12.鲁巍哥的小例子
代码有bug,看看思路
<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8">
      <title></title>
   </head>
   <body>
      <div id="addressList">
         <form action="">
            <!-- 将input写在form标签里的好处是,当我们输入内容敲击回车键的时候会自动调用form里面的submit事件 -->
            <input type="text"> 
            <p class="help">Type an email address and hit enter</p>
            <ul></ul>
         </form>
      </div>
      <script>
         // 定义了一个addressList类
         class addressList{ 
            constructor(root) { //将dom节点通过参数root传进来
               //添加删除对象,状态需要改变的变量
               this.state = []

               //UI需要的变量,dom节点的变量
               this.root = root
               this.form = root.querySelector('form')
               this.inout = this.form.querySelector('input')
               this.help = this.form.querySelector('.help')
               this.ul = root.querySelector('ul')
               this.items = {} //id -> li 元素

               //绑定事件
               this.form.addEventListener('submit', e => { //调用submit的表单事件
                  e.preventDefault() //去掉submit的默认浏览器行为,因为默认的会去跳转页面
                  const address = this.input.value; //获取用户的邮箱地址
                  this.input.value = '' //置空input框
                  this.addAddress(address) //将用户输入的邮箱地址传到addAddress函数里
               })

               this.ul.addEventListener('click', e => {
                  const id = e.target.getAttribute('data-delete-id') //获取对应要删除的li上的属性,就知道对应id了
                  if (!id) return //用户点击的其他东西
                  this.removeAddress(id)
               })
            }

            addAddress(address) {
               //状态逻辑
               const id = String(Date.now()) //一个邮箱要有一个独特的id,当我们要去删除邮箱的时候去删除对应id就行了,方便定位
               this.state = this.state.concat({ address, id }) //将邮箱存到对象里保存起来

               //UI逻辑
               this.updateHelp() //更新p标签

               const li = document.createElement('li') //用来保存每一条邮箱地址
               const span = document.createElement('span') //邮箱地址
               const del = document.createElement('a') //删除按钮
               span.innerText = address
               del.innerText = 'delete'
               del.setAttribute('data-delete-id', id) //给a标签一个特殊的属性

               this.ul.appendChild(li) //li推进ul里面去
               li.appendChild(del)
               li.appendChild(span) //del和span推进li
               this.items[id] = li //做了一个映射,对应id对应li
            }
            removeAddress(id) {
               //状态逻辑
               this.state = this.state.filter(item => item.id !== id) //删除对应项的内容

               //UI逻辑
               this.updateHelp() //更新p标签
               const li = this.items[id] //获取li
               this.ul.removeChild(li) //删除li
            }

            //更新提示的显示或隐藏
            updateHelp() {
               if(this.state.length > 0) {
                  this.help.classList.add('hidden')
               }else {
                  this.help.classList.remove('hidden')
               }
            }
         }

         // 创建了两个变量
         const root = document.getElementById('addressList') //获取了html里面的dom节点
         const add = new AddressList(root); //将dom节点传到了类里面,并且new出来一个对象add,所有的操作都是在addressList这个类的构造函数里面去完成的
      </script>
   </body>
</html>
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
</head>
<body>
   <div id="app">
      <!-- 观察下面这连个span，可以发现他们结构是差不多的，所以vue底层的虚拟dom会将其中一份作为备份，当条件不满足的时候显示另一份的时候，并不会重新创建另一个span结构，而是从虚拟dom中拿，只是更改了简单的id等属性，但是内容并不会去修改她，所以这样就会造成一个bug，当在用户账号中输入一些内容的时候，切换到用户邮箱的时候，哪些内容依旧存在，解决方法就是加key值，只要是key值不同，虚拟dom就知道这两个不是相同的结构了。还有下面的label中的for对应下面input中的id，这样的好处就是当点击用户账号的时候,就回去找对应的input框 -->
       // 复用
      <span v-if="isUser">
         <label for="username">用户账号</label>
         <input type="text" id="username" placeholder="用户账号" key="username">
      </span>
      <span v-else>
         <label for="email">用户邮箱</label>
         <input type="text" id="email" placeholder="用户邮箱" key="email">
      </span>
      <button @click="isUser = !isUser"></button>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            isUser: true
         }
      })
   </script>
</body>
</html>
```

```
// set(要修改的对象, 索引值, 修改后的值) --- 功能类似于 数组的splice方法
Vue.set(this.letters, 0, 'aaa')

// 注意：通过索引值去修改数组中的元素不是响应式的
this.letters[0] = 'aaa'; // 真实中数组中的数据是被修改了的，但是vue没有实时监听这个方法，页面并不会被渲染起来
```







