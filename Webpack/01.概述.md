# 1.历史进程

在没有`Webpack`之前，也就是没有模块化之前，存在三点明显的缺陷：

- 开发代码可读性差。
- 文件函数之间存在关联性（耦合性）问题。
- 不利于团队的协作开发。
- 全局变量同名问题（污染全局变量）。
- 代码编写对`js`文件存在依赖顺序问题。

---

**解决上述问题，经历了很长的历史进程**：

- `IIFE`，立即执行函数的出现，利用了函数有自己的作用域取解决。

![污染全局变量](D:\notes\Webpack\img\污染全局变量.png)

问题1：上述引入外部`js`脚本，可能存在作用域以及污染全局变量的问题。

解决方法：

```js
var moduleA = (function() {
    // 存储导出的对象
    var obj = {};
    var name = 'sxw';
    var age = 18;
    var flag = true;
    obj.name = name;
    obj.age = age;
    obj.flag = flag;
    return obj // 将对象 obj 暴露出去
})()

// 在别的文件中的使用
(function() {
    if(moduleA.flag) {
        console.log('成功啦！')
    }
})
```

```js
(function () {
    function con(value) {
        console.log(value);
    }
    function add(a,b) {
        con(a + b);
    }
    
    // 通过window方法暴露给全局我们想要暴露出去的部分
    window.add = add
})()
```

问题2：存在引入依赖问题。

解决方法：`gulp`、`grunt`等工具的出现。

问题3：上述的解决方法就是在文件首部添加一个说明，用来描述当前文件是否需要加载别的依赖文件，以及依赖的先后顺序。但当我们修改了文件内容时，可能会打破这个依赖规则。并且上述这个方法存在`Dead Code`死代码现象，也就是说当我们仅仅需要使用目标库中的一个插件的时候，她会加载整个目标库，造成资源浪费。`eg`：`underscore.js`、`lodash`等。

解决方法：`commonJS`模块化导出的出现。

```js
// 文件导出
function add(a,b) {
    console.log(a + b);
}
module.export = add;
```

```js
// 文件引入
let add = require('./add');
```

但是使用上述方法，浏览器是无法识别`require`、`export`等语法的。

解决方法：`browerify`打包工具的出现。但是其打包固化，并且无法按需加载，造成资源浪费等问题。她只是将所有的文件打包成一个`js`文件，存在代码冗余。

解决方法：出现了两个异步加载的规范。

**AMD**：代表`Require.js`

**CMD**：代表`Sea.js` 国人写的

还有**CommonJS**规范，`Node.js`就是遵循该规范的

```js
// 模块化的两个核心: 导出和导入
```

![CommonJS](D:\notes\Webpack\img\CommonJS.png)

还有**ES6**中的`Modules`

![ES6中的模块化写法](D:\notes\Webpack\img\ES6中的模块化写法.png)

最后，`Webpack`的出现！

# 2.`Webpack`出现

**概述**：是`JavaScript`应用的静态模块打包工具，支持任意模块化的语法，采用按需加载、异步加载的方式，将很多的`js`、`css`、`json`、图片文件整合成一个`js`文件。项目上线的时候只需要将那一个导出的文件丢上去即可。是目前为止，解决模块化比较好的方案！支持我们使用模块化开发，并且帮助我们处理模块之间的依赖关系。将各种文件、图片当作模块来使用，这就是`webpack`中模块化的概念。

**优点**：

- 支持任意模块化，增加了开发效率。（因为15年`ES6`才出现模块化这个标准，在此期间已经出现了很多的第三方规范。导致前端环境杂乱，规范多样。而`webpack`提供给不同模块化之间的兼容存在。

- 异步加载，增加了运行效率。通过将项目打包成一个个小文件，在浏览器加载的时候开启异步加载特性，提升加载效率。

**与grunt、gulp之间的对比**：

- `grunt`/`gulp`的核心是`Task`。我们可以配置一系列的`task`，并且定义`task`要处理的事务（譬如：`ES6`、`ts`转化，图片压缩，`scss`转成`css`等），之后让`grunt`/`gulp`来依次执行这些`task`，而且让整个流程自动化。所以`grunt`/`gulp`也被称为前端自动化任务管理工具。
- 如果我们的工程模块依赖非常简单，甚至没有用到模块化的概念，只需要进行简单的合并、压缩、就使用`grunt`/`gulp`即可。但如果整个项目使用了模块化管理，而且互相依赖非常强，就可以使用强大的`webpack`了。

- 所以`grunt`/`gulp`更加强调前端流程的自动化，模块化不是他的核心。`webpack`更加强调模块化开发管理，而文件压缩合并、预处理等功能，是他的附带功能。