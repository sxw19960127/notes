# 虚拟`DOM`

`virtual` `dom`是`vue`和`react`的核心。

- `vdom`是什么？为何会存在`vdom`
- `vdom`如何应用，核心`API`是什么
- 介绍一下`diff`算法

用`js`模拟`DOM`结构。

`DOM`变化的对比放在`js`层来做（图灵完备语言），提高重绘性能。

将`DOM`对比操作放在`js`层，提高效率。

```html
<ul id="list">
    <li class="item">item 1</li>
    <li class="item">item 2</li>
</ul>
```

```
{
	tag: 'ul',
	attrs: {
		id: 'list'
	},
	children: [
		{
			tag: 'li',
			attrs: {className: 'item'},
			children: ['item 1']
		},
		{
			tag: 'li',
			attrs: {className: 'item'},
			children: ['item 2']
		}
	]
}
```

需求：

```html
<div id="container"></div>
<button id="btn-change">change</button>
<script src="./jquery.js"></script>
<script>
	var data = [
        {
            name: '张三',
            age: '20',
            address: '北京'
        },
        {
            name: '李四',
            age: '10',
            address: '上海'
        },
        {
            name: '王五',
            age: '5',
            address: '广州'
        }
    ]
    
    // 渲染函数
    function render(data) {
        var $container = $('#container')
        
        // 清空现有内容
        $container.html('')
        
        // 拼接table
        var $table = $('<table>')
        $table.append($('<tr><td>name</td><td>age</td><td>address</td></tr>'))
        data.forEach(function(item) {
            $table.append($('<tr><td>' + item.name + '</td></tr>' + item.age + '</td><td>' + item.address + '</td></tr>'))
        })
        
        // 渲染到页面
        $container.append($table)
    }
    
    // 修改信息
    $('#btn-change').click(function() {
        data[1].age = 30
        data[2].address = '兰溪'
        render(data)
    })
    
    // 初始化时候渲染
    render(data)
</script>
```

- `DOM`操作是昂贵的，`js`运行效率高
- 尽量减少`DOM`操作，而不是推倒重来
- 项目越复杂，影响越严重

`vdom`如何应用，核心`API`是什么？

- 介绍`snabbdom`

- 核心`API`

![github-snabbdom](D:\notes\js高级面试\github-snabbdom.jpg)

`vnode`最外层是一个`div`标签，`div`标签上有一个`id`选择器，两个`class`选择器。

有一个`click`事件，绑定再`someFn`函数上。

`div`标签上有三个子元素（数组中有三个元素）：

- 第一个元素是`span`标签
- 第二个元素是字符串
- 第三个元素是`a`标签 

`patch`函数两个参数表示的意思：

- 第一个参数表示真实节点，一个空的容器 
- 第二个参数虚拟模拟出来的节点

- 第一次渲染的时候就把`vnode`中的所有模拟完成的`node`节点全部都赋给`container`
- 第一次渲染的时候就要把所有的数据源全部都给渲染出来
- 第二个`patch`中的两个参数表示上一个`vnode`和新渲染出来的`newVnode`，将两者进行对比而仅仅更新有变化的部分

![snabbdom](D:\notes\js高级面试\snabbdom.jpg)

`h`函数返回的是`vnode`节点，`vnode`就是用`vdom`模拟的节点。

`h`函数仅仅是模拟了一个`dom`节点，模拟了一个`node`。

![snabbdom-h函数](D:\notes\js高级面试\snabbdom-h函数.jpg)

![snabbdom-patch函数](D:\notes\js高级面试\snabbdom-patch函数.jpg)

![patch函数的对比](D:\notes\js高级面试\patch函数的对比.jpg)

```html
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
    <title></title>
</head>
<body>
	<div id="container"></div>
    <button id="btn-change">change</button>
    <script src="https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom.js"></script>
    <script src="https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom-class.js"></script>
    <script src="https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom-props.js"></script>
    <script src="https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom-style.js"></script>
    <script src="https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom-eventlisteners.js"></script>
    <script src="https://cdn.bootcss.com/snabbdom/0.7.1/h.js"></script>
    <script>
    	var snabbdom = window.snabbdom
        
        // 定义patch
        var patch = snabbdom.init([
            snabbdom_class,
            snabbdom_props,
            snabbdom_style,
            snabbdom_eventlisteners
        ])
        // 定义h
        var h = snabbdom.h
        
        var container = document.getElementById('container')
        
        // 生成vnode,使用ul标签将container标签所替换掉
        var vnode = h('ul#list', {}, [
            h('li.item', {}, 'Item 1'),
            h('li.item', {}, 'Item 2')
        ])
        patch(container,vnode)
        
        document.getElementById('btn-change').addEventListener('click',function() {
            // 生成 newVnode
            var newVnode = h('ul#list', {}, [
                h('li.item', {}, 'Item 1'), // 相同的不做多余的渲染
                h('li.item', {}, 'Item B'), // 找出差异,仅渲染差异
                h('li.item', {}, 'Item 3')
            ])
            patch(vnode,newVnode)
        })
    </script>
</body>
```

核心`API`：

- h（'<标签名>'，{...属性...}，[...子元素...]）
- h（'<标签名>'，{...属性...}，'...'）
- patch(container，vnode)
- patch(vnode，newVnode)

---

==问题解答==：

- 如何使用？可用`snabbdom`用法来举例
- 核心`API`：h函数、patch函数



# `diff`算法

- 什么是`diff`算法
- `vdom`为何用`diff`算法
- `diff`算法的实现流程

![diff-上](D:\notes\js高级面试\diff-上.jpg)

`diff`是`Linx`系统中的一个命令。

![diff-中](D:\notes\js高级面试\diff-中.jpg)

`git diff`：我们提交到`git`的时候看一下提交上的文件中做了哪些修改。

![diff-下](D:\notes\js高级面试\diff-下.jpg)

网上搜`diff`在线对比工具，我们也能够直观地看出文件之间的差异。

- `diff`算法非常复杂，实现难度很大，源码量很大

`vdom`为何使用`diff`算法：

- `DOM`操作时昂贵的，因此应该尽量减少`DOM`操作
- 找出本次`DOM`必须更新的节点来更新，其他的不变
- 这个找出的过程就是`diff`算法

`diff`实现过程：

- patch(container，vnode)
- patch(vnode，newVnode)

==情况1==：

![diff算法演示-上](D:\notes\js高级面试\diff算法演示-上.jpg)

![diff演示-中](D:\notes\js高级面试\diff演示-中.jpg)

==情况2==：

![diff演算 - 下](D:\notes\js高级面试\diff演算 - 下.jpg)

![diff - 演示 下下](D:\notes\js高级面试\diff - 演示 下下.jpg)

![diff - 演示- 对](D:\notes\js高级面试\diff - 演示- 对.jpg)

不仅仅是以上内容：

- 节点新增和删除
- 节点重新排序
- 节点属性、样式、事件绑定
- 如何极致压榨性能

`diff`实现过程：

- patch(container，vnode)和patch(vnode，newVnode)
- createElement
- updateChildren

---

==问题解答==：

- 知道什么是`diff`算法，是`linux`基础命令
- `vdom`中应用`diff`算法是为了找出需要更新的节点
- `diff`实现，patch(container，vnode)和patch(vnode，newVnode)

- 核心逻辑，createElement和updateChildren



# `MVVM`和`Vue`

- 如何理解`MVVM`
- 如何实现`MVVM`
- 是否解读过`vue`源码
- 说一下使用`jQuery`和使用框架的区别
- `vue`中如何实现响应式
- `vue`中如何解析模板
- `vue`的整个实现流程

![jQuery实现todolist](D:\notes\js高级面试\jQuery实现todolist.jpg)

![vue实现todolist](D:\notes\js高级面试\vue实现todolist.jpg)

两者的区别：

- 数据和视图的分离
- 以数据驱动视图

---

==问题解答==：

- 数据和视图分离，解耦（开放封闭原则）
- 以数据驱动视图，只关心数据变化，`DOM`操作被封装

说一下对`MVVM`的理解：

- `MVC`

- `MVVM`
- 关于`ViewModel`

三要素：

- 响应式：`vue`如何监听到`data`的每个属性的变化的？
- 模板引擎：`vue`的模板如何被解析，指令如何处理？
- 渲染：`vue`的模板如何被渲染成`html`？以及渲染过程？

`vue`如何实现响应式：

- 什么是响应式
- `Object.defineProperty`

什么是响应式：

- 修改`data`属性之后，`vue`立刻监听到。
- `data`属性被代理到`vm`上

![响应式](D:\notes\js高级面试\响应式.jpg)

模拟实现`vue`如何监听到`data`的变化：

- 通过`object.definedProperty`中的`set`和`get`实现实时监听
- `data`上的数据如何代理到对象`mv`上去，依旧是通过`object.definedProperty`第一个参数就是要将第二个参数中的所有的属性全部挂载到第一个参数对象上去

![模拟实现](D:\notes\js高级面试\模拟实现.jpg)

---

==问题解答==：

- 关键是`Object.definedProperty`
- 将`data`的属性代理到`vm`上

`vue`中如何解析模板：

- 模板是什么
- `render`函数
- `render`函数与`vdom`





















