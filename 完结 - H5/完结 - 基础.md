# H5新特性一览

1. 新语义标签元素
2. 为`input`引入新属性
3. 引入音视频标签元素
4. 引入`canvas`画布
5. 拖放
6. 文件读取
7. 地理位置
8. 执行脚本多线程`worker`
9. 本地存储
10. `websocket`
11. `HistoryAPI`
12. `postmessage`跨文档通信



# 历史

`XHTML1.0`，在`html`中引入`xml`，严格要求写法，在一定程度上解决了浏览器的兼容性问题，所带来的反应较好。

`XHTML2.0`，过于严格且不支持旧的页面。如果不按规范来写代码，页面将无法展示，导致了浏览器厂商的一致反对。

`WHATWG`的建立，目的以拓展和改进`html`。

2006年，`W3C`与`WHATWG`合作。

`HTML5` `W3C`规范的提出，2008年提出`html5`草案。



# 理念

## 避免不必要的复杂。

`DOCTYPE`用以告诉浏览器关于页面，我是使用哪个`HTML`版本进行编写的。

```html
<!-- html4.01 -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML4.01...>
```

```html
<!-- html5简化 -->
<!DOCTYPE html>
```

## 支持已有写法

## 优雅降级

当浏览器不支持标签内的某个属性时，浏览器会降级到一个默认的支持属性的版本。

## 用户优先

用户 > 开发者(程序员) > 浏览器厂商 > 标准制定者



# `Doctype`

标准模式和怪异模式。

验证：

```js
console.log(document.compatMode);
    返回BackCompat --> 表示怪异模式(按照各个浏览器来解析)
    返回CSS1Compat --> 表示标准模式(按照规范来解析)
```

区别：

```
标准盒模型和IE6混杂模式盒模型;
table字体在标准模式下继承body,怪异模式下不继承body;
怪异模式IE6以下版本中可以给span等行级元素设置宽高;
怪异模式下即使父级没有高度,也可以设置百分比高度;
怪异模式IE6以下margin:0 auto不能左右居中;
怪异模式IE6以下图片的padding失效;
只有在IE6之前的浏览器才会触发IE6混杂模式;
IE6混杂模式盒模型是微软超前的意识提出的,所以只有IE浏览器才会有;
在怪异模式下盒模型的总宽度和高度是包含内边距padding和边框border在内的,所以盒子宽度即为width;
```



# H5结构元素

```
header 整个页面的头部,某块区域的标题,页眉;
footer 文档或者某一块的底部,页脚;
main 主要内容区域;
nav 导航链接部分;
section 页面中一个内容区域;

article 它代表一个独立的,完整的相关内容块;
aside 表示一个页面的一部分,和这个页面的其他内容关联性不强,或者是没有关联,单独存在;
figure 规定独立的流内容(图像,图表,照片,代码...);
```



# H5功能元素

```
video 视频;
audio 音频;
source 资源;
canvas 画布;
progress 进程;
figcaption 标签定义(了解即可);
```

```html
<!-- controls,显示出相应视频音频的控件 -->
<!-- poster为视频第一帧设置海报,只有video有 -->
<video height="600px" controls src="./video/1.mp4" poster="./1.png"></video>
```

```html
<audio src="./video/1.mp3" controls></audio>
<audio controls>
   <source src="./video/1.mp3"> // 先去服务器里看一下有没有mp3格式
   <source src="./video/1.ogg"> // 没有的话再去申请ogg格式,按顺序加载
</audio>
```

```js
// js动态创建Audio
var myAudio = new Audio('./video/1.mp3'); // 和img标签一样
myAudio.controls = 'controls'; // 这里直接等于true,也行
document.body.appendChild(myAudio); // 插入到dom当中,添加子元素
```

```html
<canvas width=600 height=600></canvas>
<progress id="pro" max=100 min=0 value=30></progress>
```

```js
// 浏览器支持情况:
canPlayType()方法,audio.canPlayType() --> 返回probably或者maybe,返回空为不支持
```

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
        <style>
            span{
                display: none;
            }
        </style>
    </head>
    <body>
        <progress id="pro" max=100 min=0 value=0></progress>
        <span id="ok">完成</span>
        <script>
            var timer = setInterval(function() { 
                // 设置计时器
				// 平时练习的时候可以不写document.getElementById("pro")来获取dom节点,通过对应的id值.属性      
                if(pro.value === 100) { 
                    clearInterval(timer);
                    ok.style.display = "block";
                }else {
                    pro.value += 10;
                    console.log("检查计时器有没有清除");
                }
            },1000);
        </script>
    </body>
</html>
```



# H5表单元素

```
<input type="text"> 文本框
<input type="radio"> 小圆点
<input type="checkbox"> 复选框
<input type="password"> 密码
<input type="submit"> 提交
<input type="button"> 按钮
<input type="file"> 上传文件
```

`input`新属性：

```
multiple 可上传多个文件;
placeholder 提示用户当前文本框是干啥作用的;
pattern 验证input类型输入框中内容是否与正则匹配;
```

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
    </head>
    <body>
        <input type="text">
        <form action="">
			应用场景,radio单选框,性别选择,name必须相同才能起到单选的目的,value是提交时候后台获取的值
            <input type="radio" name="sex" value="male">男生 
            <input type="radio" name="sex" value="female">女生
            <input type="submit">
        </form>
        <form action="">
			应用场景,checkbox复选,提交到后台的时候是name=value的形式
            <input type="checkbox" name="eat" value="apple">苹果
            <input type="checkbox" name="eat" value="pear">梨
            <input type="submit">
        </form>
        <form action="">
        	自动把我们输入的值作为value值
            <input type="password" name="word">
            <input type="submit">
        </form>
        <input type="button" value="ok"> //小按钮
        <form action="">
            <input type="file" multiple> //multiple可以同时选择多个文件
            <input type="submit">
        </form>
    </body>
</html>
```

`input type`新增：

```html
<input type="tel">
<input type="range"> // 进度条
<input type="number">
<input type="search">
<input type="email">
<input type="datatime-local"> // 表示本地日期和时间,支持情况不是很好
<input type="color"> // 供我们选择颜色的
<input type="date"> // 以下四个使用不多
<input type="month">
<input type="week">
<input type="time">
```

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
        <style>
            input{
                display: block; // 独占一行
            }
        </style>
    </head>
    <body>
        <form action="">
            <input type="tel"> 
            // 当前文本框是一个输入电话号码的文本框,移动端比较明显
只能输入数字和下划线,当超过规定数值范围提交的时候会提示,在移动端的时候会自动弹出一个数字键盘
            <input type="number" max="100" min="0">
            <input type="email" value="123@qq.com">
            <input id="range" type="range" max="100" min="0" step="10" value="0">
            <input type="submit">
        </form>
        <script>
            range.onclick = function() {
                // console.log(this);
                console.log(this.value); // 谁调用了这个函数,这个函数里的this就指向谁
            };
        </script>
    </body>
</html>
```

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
    </head>
    <body>
        <form action="">
        	pattern属性可以代替下面js里的正则表达式
            <input id="test" type="text" pattern="^\d{6}$" name="num">
            <input type="submit">
        </form>
        
        <script>
            // 用正则表达式写输入框内只能书写6位数字
//^以...开头 ,$以...结束(锁定了只能输入6个数字) ,// ,\d表示数字 ,{6}只能书写6位 ,g只有6位
            var reg = /^\d{6}$/g;
            test.onblur = function() { // 失去焦点的时候value值是几位
                if(reg.test(this.value)) { // 匹配对应test函数,匹配的是input框中的value值
                    this.style.borderColor = "green";
                }else {
                    this.style.borderColor = "red";
                }
            };
        </script>
    </body>
</html>
```



# `Audio/Video`

属性一览：

1.

```
muted 静音
autoplay 自动播放,注意在静音muted的条件下而且只有video好用
controls 调出控件
loop 循环播放,视频音频都行
```

2.

```
preload(none/metadata/auto) 是否预加载;
     none: 不进行预加载;
     metadata: 部分进行预加载,提供基本的没啥用的信息,宽高,但是里面的内容是不加载出来的;
     auto: 全部预加载;
     preload="metadata";
```

3.

```js
currentSrc 获取资源链接(注意要资源加载完成后才能获取到);
	var myAudio = document.getElementById("myAudio");
    myAudio.oncanplay = function() { 
    // 为啥要绑定一个canplay事件,因为我们获取资源链接是需要等视频链接加载完的,而canplay事件是不确定按照当前播放速率能否将视频播放完,既然都能够播放视频了,肯定已经加载完地址了
      console.log(myAudio.currentSrc);  
    };
```

4.

```
duration 媒体持续时间(总时长,注意要资源加载完成后才能获取到)在canplay事件函数里面去检测;
```

5.

```html
currentTime 返回或设置资源当前时间;
    <audio id="myAudio" src="./song.mp3" controls>
    <button id="current">currentTime</button>
    <script>
        var myAudio = document.getElementById('myAudio');
        current.onclick = function() {
            console.log(muAudio.currentTime);
        };
    </script>
```

6.

```html
volume 音量[0-1],可读可写;
    <audio id="myAudio" src="./1.mp3" controls></audio>
    <button id="lessVolume">-</button>
    <button id="addVolume">+</button> //为啥不写成addvolume,大写是为了下面直接获取dom节点
    <button id="quick">快进</button>
    <button id="slow">慢放</button>
    <button id="p">play/pause</button>
    <button id="btn">btn</button>
    <script>
        // var myAudio = document.getElementById("myAudio");这样获取dom节点比较规范
        lessVolume.onclick = function() {
            var volume = parseInt((myAudio.volume - 0.1)* 10) / 10;
            if(volume >= 0 && volume <= 1) {
                myAudio.volume = volume;
            } 
            console.log(myAudio.volume);
        };
        addVolume.onclick = function() { // bug待解决:为啥音量只能加到0.7就上不去了
            var volume = parseInt((myAudio.volume + 0.1) * 10) /10;
            if(volume >= 0 && volume <= 1) {
                myAudio.volume = volume;
            }
            console.log(myAudio.volume);
        };
        quick.onclick = function() {
            myAudio.playbackRate += 0.1;  
        };
        slow.onclick = function() {
            myAudio.playbackRate -= 0.1;  
        };
        p.onclick = function() {
            if(myAudio.paused) {
                myAudio.play();
            }else {
                myAudio.pause();
            }
        };
        // 判断两种状态进行标识
        var flag = true;
        p.onclick = function() {
            flag = !flag;
            if(flag) {
                console.log(1);
            }else {
                console.log(0);
            }
        };
        btn.onclick = function() {
            myAudio.src = "./2.mp3"; // 实现切歌的效果
            myAudio.load(); // 重新加载资源,在有自动播放的时候当做切歌比较舒服
        };
        // 事件的触发
        myAudio.onplay = function() {
            console.log("我播放啦~");
        };
        myAudio.onpause = function() {
            console.log("我暂停啦~");
        };
        myAudio.onended = function() {
            cosole.log("我结束啦~");
        };
    </script>
```

7：了解即可

```
playbackRate 读取或设置媒体资源播放的当前速率(大于1快放,大于0小于1慢放,无倒放);
paused/ended/seeking 查询媒体播放状态,返回true/false;
paused 是否暂停,返回状态true/false;
ended 判断音频是否结束了;
seeking 正在请求某一播放位置的媒体数据,了解即可;
player/buffered/seekable 均返回一个TimeRanges对象;
    timeRanges对象的length属性为部分时间段;
    end(i)返回已播放时间段的结束时间;
    start(i)返回已播放时间段的开始时间;
played 标明媒体资源在浏览器中已播放的时间范围;
    在两个暂停中间进行的播放时间长度,返回一个数组,当然也可以获取播放开始的时间和播放结束的时间
buffered 确定浏览器已经缓存媒体文件;
seekable 表明可以对当前媒体资源进行请求;
```

方法一览：

```
play() 播放
pause() 停止
load() 重置媒体元素并重新载入媒体,可中止正在进行的任务或事件 
```

事件一览：

```
play 媒体开始播放时触发
pause 媒体暂停时触发
ended 资源播放结束
canplay 浏览器能够开始播放媒体数据,但是不确定已当前的速率能否顺利的播放完媒体
```

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
    </head>
    <body>
        <audio id="myAudio" controls src="./video/1.mp3"></audio>
        <script>
            var obj = {
                aa: function() {
                    console.log(3);
                }
            }
            if(obj.aa) {
                console.log("有！")
            }
            // 检验我们的浏览器是否支持audio标签以及支持什么格式的音频
            var myAudio = document.getElementById('myAudio');
            if(myAudio.canPlayType) {
                if(myAudio.canPlayType("audio/mpeg") != "") {
                    document.write("您的浏览器支持mp3编码;");
                    // --> probably
                }
                if(myAudio.canPlayType('audio/ogg; codecs="vorbis"') != "") {
                    document.write('您的浏览器支持ogg编码;');
                    // --> probably;
                }
                if(myAudio.canPlayType('audio/mp4; codecs="mp4a.40.5"') != "") {
                    document.write('您的浏览器支持aac编码');
                    // --> probably
                }
            }else {
                document.write("您的浏览器不支持要检测的音频文件");
            }
        </script>
    </body>
</html>
```



# `Canvas`

在一个元素上通过调用API，进行绘画，使得浏览器重排重绘渲染的过程减少，因为只需要对一个元素进行渲染。

```
Canvas画布,是HTML5中非常重要的一个更新亮点,可以替代Flash的;
制作动画、游戏,渲染效率非常高,浏览器不需要安装任何的插件就可以渲染动画;而Flash是需要安装Flash Player插件才行;
Canvas是一个在面试中极度加分的项目,完整的去检验大家内功水平,全是面向对象;
Canvas是一个标签,有一个默认的宽度,（不需要了解）。注意:如果我们要设置画布的宽高的时候,必须在HTML标签上设置,而不能在CSS上设置;
Canvas在网页上呈现居然是一个会动的图片,我们可以右键图片另存为;
我们必须使用JavaScript来控制Canvas渲染各种东西;
ctx对象非常重要,所有的绘制都是ctx方法;
canvas兼容到IE9;
笔触和填充:Canvas中能够产生颜色的是两种东西:一个叫笔触(老百姓叫做描边),另一个叫做填充。
绘制的线可以用fill填充,并且可以用strock来描边。需要注意的是,形状如果不封闭就fill了,此时形状会自动封闭,但是与封闭的区别在于封闭的那条线就没有了;
ctx.strokeRect 矩形描边
ctx.fillRect 矩形填充
属性是用等号赋值,方法是用圆括号调用;
弧和圆形 ---> arc(x, y, radius, startAngle, endAngle, anticlockwise);
画一个以(x,y)为圆心，以radius为半径的圆弧(圆)，从startAngle开始到endAngle结束，按照anticlockwise给定的方向(默认为顺时针)来生成。
一定要注意,在canvas中角度是弧度制的。复习一下弧度制，就是在一个圆形披萨饼中，切一片披萨，让弧度边长等于圆的半径。此时无论圆形多大,切下来的角度是固定的,都是57.29度,称为1弧度,记做1rad。360° = 2* PI rad 
绘制一个圆形:ctx.arc(200,200,100,0,2*Math.PI,false);
```

## `API`

```
快速矩形描边		 ctx.strokeRect(x,y,w,h);
开始绘制路径		 ctx.beginPath();
封闭路径		     ctx.closePath();
将画笔移动到某个点   ctx.moveTo(x,y);
移动画笔画线,但是是虚拟的线		ctx.lineTo();
画线				 ctx.stroke();
填充				 ctx.fill();
改变线的颜色		 ctx.strokeStyle = "red";
改变填充颜色		 ctx.fillStyle = "red";
快速矩形填色		 ctx.fillRect(x,y,w,h);
清除一个矩形区域     ctx.clearRect(x,y,w,h);
得到上下文	         mycanvas.getContext("2d");
mycanvas.getContext("2d") ------> Context是上下文的意思。Canvas起初是空白的,为了展示,首先脚本需要找到渲染上下文,然后在它的上面绘制。<canvas>元素有一个getContext()的方法,这个方法是用来获得渲染上下文和它的绘画功能。getContext()只有一个参数,上下文的格式;
设置图片的宽度和高度:ctx.drawImage(图片对象,dx画布上的左上角的x,dy画布上的左上角的y,100图片的宽,70图片的高);可以使用4个数字参数;
比如: 我们现在想在canvas上面呈递切片中的位置:
将这个切片放置在画布的100,100 呈递的宽度、高度是切片的2倍;
ctx.drawImage(image,299,94,93,76, 100,100,93*2,76*2); //前四个数是切片在原图上的位置的左上顶点和宽高,后四个数是canvas上的位置的左上顶点和宽高
```

```html
// 宽高的单位不是像素,没有单位,是一个相对的单位
<canvas width="100" height="100"></canvas> 
var canvas = document.getElementsByTagName("canvas")[0];
var ctx = canvas.getContext("2d"); 注意,Canvas获取绘画上下文的api是getContext("2d");
```

```
绘制图形:
1.直线
    moveTo(x,y); 画笔挪到起始点(x,y)
    lineTo(x,y); 画笔划线到另一点(x,y)
2.样式
    stroke(); 描边画
    lineWidth = 20; 设置线宽
    strokeStyle = 'red'; 线的颜色
    closePath(); 闭合路径
    fill(); 填充画
    fillStyle = 'red';填充颜色
设置图形 线样式:
    1.lineWidth: 线条宽度;
    2.lineCap: 线两头样式butt/square/round;
    3.lineJoin: 两线拐角处miter/round/bevel;
    4.miterLimit: 绘制交点的方式;
// 三角形a
    ctx.moveTo(100,100);
    ctx.lineTo(200,100);
    ctx.lineTo(200,200);
    ctx.closePath();
    ctx.strokeStyle = 'red';
    ctx.stroke();
// 三角形b
    ctx.moveTo(100,300);
    ctx.lineTo(200,300);
    ctx.lineTo(200,400);
    ctx.closePath();
    ctx.strokeStyle = 'green';
    ctx.stroke();
矩形:
	rect(x,y,w,h); 坐标点 宽度 高度
	strokeRect(x,y,w,h); 描边画矩形,自己是一个单独的路径,不对其他路径进行影响,等于重新开辟一个路径
	fillRect(x,y,w,h); 填充画矩形,自己是一个单独的路径,不对其他路径进行影响,相当于重新开辟一个路径
圆形:
	arc(x,y,sAngle,eAngle,false,c); 中心点 半径 起始弧度 终止弧度(0,Math.PI*2 --> 圆) 
														   默认是false按照顺时针画的
曲线:
	两条切线之间的弧或者曲线
	arcTo(x1,y1,x2,y2,r);
二次方,三次方曲线方程:
    quadraticCurveTo(cpx,cpy,x,y);
    bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y);
```

```
问: 浏览器展示的两个三角形分别是什么颜色的？
解: 因为是在同一个路径上的,所以下面的效果会把上面的效果给覆盖掉,即同一个属性写了两遍,解决办法是再重新开启一个新的路径ctx.beginPath()。fill和stroke方法都是作用在当前的所有子路径,若想开辟新的路径,在绘制新路径之前需要使用beginPath();
```

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
        <style>
            canvas{ //以这里为实际宽高
                border: 1px solid #000;
                width: 200px;
                height: 200px;
            }
        </style>
    </head>
    <body>
    	//如果style里面没有设置宽高,则默认为400px;
        <canvas id="myCanvas" width="400" height="400"></canvas>
        <script>
            var myCanvas = document.getElementById('myCanvas');
            console.log(myCanvas.offsetWidth); //获取画布的宽是style里的属性
            var ctx = myCanvas.getContext('2d'); //canvas的API,画笔

            ctx.lineWidth = 20; //设置线宽,没有单位
            ctx.strokeStyle = 'red'; //设置描边的颜色
            ctx.fillStyle = 'green'; //设置填充的颜色
            ctx.moveTo(100, 100); //挪动画笔到(100,100)
            ctx.lineTo(200, 100); //画到(200,100)
            ctx.lineTo(200, 200); 
            ctx.lineTo(100,100); //其实这里不一定要重新回到原点也能实现填充
            ctx.closePath(); //路径闭合可以解决上面一行代码产生的缺了一个角的问题,即上面这行代码不写,换成这一行,就不存在缺口的问题了;
            ctx.rect(100, 100, 100, 100); //坐标x,坐标y,宽,高
            ctx.fill(); //填充渲染出来
            ctx.stroke(); //描边渲染出来

            ctx.beginPath();
            ctx.moveTo(100, 200);
            ctx.lineTo(200, 200);
            ctx.lineWidth = 20;
            ctx.lineCap = 'round'; //butt默认,square/round
            ctx.stroke();
        </script>
    </body>
</html>
```

```html
<head>
    <style>
        canvas{border: 1px solid red;}
    </style>
</head>
<body>
	//注意，给canvas设置宽和高的时候不能在上面style样式里面设置，应该在canvas标签属性头部设置
    <canvas width="600" height="400" id="mycanvas"></canvas>
    <script>
        //使用DOM方法得到画布
        var mycanvas = document.getElementById("mycanvas");
        //使用画布的上下文,所有的命令是由他发出的，而不是画布发出的。ctx即为context的缩写
        var ctx = mycanvas.getContext("2d");
        //画各种东西,用ctx打点调用方法,而不是myCanvas;
        //画一个矩形,从点(100,100),画一个宽300,高40的矩形;
        ctx.fillRect(100,100,300,40);
        //所有的步骤都是ctx在打点,和canvas无关,所有API的绘制都是ctx的事情,而不是canvas对象;
        ctx.fillStyle = "blue";
        ctx.beginPath();
        //画一个圆,圆心(300,300),半径100,从0画到2π,顺时针逆时针随便
        ctx.arc(300,300,100,0,Math.PI*2,true);
        ctx.fill();
        ctx.closePath();
    </script>
</body>
```

```html
<head>
    <style>
        canvas{border: 1px solid red;}
    </style>
</head>
<body>
    <canvas width="600" height="400" id="mycanvas"></canvas>
    <script>
        var mycanvas = document.getElementById("mycanvas");
        var ctx = mycanvas.getContext("2d");

        //笔触,只有描边没有里面的填充色
        // ctx.strokeStyle = "red";
        // ctx.strockRect(x, y, width, height);
        // ctx.strokeRect(100,100,300,40);

        //线
        ctx.beginPath(); //开始一个路径 (必须要有的)
        ctx.moveTo(100, 100); //第一个点,移到点(100,100);(必须要有的)
        ctx.lineTo(300, 300); //画一条线到点(300, 300),此时是一条抽象的线,没有画到画布上;
        ctx.lineTo(300, 200); //可以不断进行画线;可以多次使用lineTo;
        ctx.closePath(); //自动去封闭路径;
        ctx.lineWidth = "10"; //设置描边线的粗细;
        ctx.lineJoin = "round"; //改变线的端点形成的凹凸程度;
        ctx.strokeStyle = "red"; //改变描边的颜色;
        ctx.stroke(); //画线！必须调用stroke命令,把上面这条抽象的线给画下来;
        ctx.fillStyle = "pink"; //改变填充的颜色;
        ctx.fill(); //对这个形状进行填充;
    </script>
</body>
```

```html
<body>
    <canvas width="600" height="400" id="mycanvas"></canvas>
    <script>
        var mycanvas = document.getElementById("mycanvas");
        var ctx = mycanvas.getContext("2d");

        //弧也是笔触
        ctx.beginPath();
		//圆心(200,200) 半径(100) 起始的弧度(0) 终止的弧度(1) true表示逆时针。
        ctx.arc(200,200,100,0,1,true);
        ctx.arc(100,100,50,0,2 * Math.PI,false);
        ctx.stroke();
        ctx.fill();
    </script>
</body>
```

```html
画一个小人头:
<body>
    <canvas width="600" height="400" id="mycanvas"></canvas>
    <script>
        var mycanvas = document.getElementById("mycanvas");
        var ctx = mycanvas.getContext("2d");
        
        ctx.beginPath();
        ctx.arc(200,200,100,0,Math.PI * 2,true); 
        ctx.stroke();
        ctx.fillStyle = "pink";
        ctx.fill();

        ctx.beginPath();
        ctx.arc(150,180,20,0,Math.PI * 2,true); 
        ctx.stroke();
        ctx.fillStyle = "red";
        ctx.fill();

        ctx.beginPath();
        ctx.arc(250,180,20,0,Math.PI * 2,true); 
        ctx.stroke();
        ctx.fillStyle = "red";
        ctx.fill();

        ctx.beginPath();
        ctx.arc(200,170,90,0.5,2.6,false);
        ctx.stroke();
    </script>
</body>
```

## 贝塞尔曲线

一次贝塞尔曲线

```html
<head>
    <style>
        canvas{border: 1px solid red;}
    </style>
</head>
<body>
    <canvas width="600" height="400" id="mycanvas"></canvas>
    <script>
        var mycanvas = document.getElementById("mycanvas");
        var ctx = mycanvas.getContext("2d");

        ctx.beginPath(); 
        ctx.moveTo(100, 100);
        // ctx.quadraticCurveTo(cp1x, cp1y, x, y);
        // 如果控制点(cp1x,cp1y)出现在100-300之间，则是一条直线
        ctx.quadraticCurveTo(200, 200, 300, 300);
        ctx.stroke(); 
    </script>
</body>
```

二次贝塞尔曲线

```html
<body>
    <canvas width="600" height="400" id="mycanvas"></canvas>
    <script>
        var mycanvas = document.getElementById("mycanvas");
        var ctx = mycanvas.getContext("2d");

        ctx.beginPath(); 
        ctx.moveTo(100, 100);
        // ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
        // ctx.bezierCurveTo(150, 150, 250, 250, 300, 300); 如果两个控制点与起始点和终止点相对应的话，就又是一条直线
        ctx.bezierCurveTo(150, 50, 250, 450, 300, 300); //左边一头往上提，右边一头往下压
        ctx.stroke(); 
    </script>
</body>
```

## 运动

```
让元素在canvas上运动起来,需要使用定时器setInterval();
Canvas使用了一个特殊的模式。上屏的元素,立刻被像素化。也就是说,上屏幕的元素,你将得不到这个“对象”;
一个圆形画到ctx上面,此时就是一堆像素点,不是一个整体的对象了,你没有任何变量能够得到这个圆形,改变这个圆形的x、y;
所以Canvas有一个机制,叫做上屏幕的元素是不能改变形状、位置的。你要想产生运动,必须重新画一个。所以Canvas的画图原理就是:清屏 --> 重绘 --> 清屏 --> 重绘 -->......;
和DOM中的盒子运动完全不一样,DOM中我们试图更改同一个DOM元素的属性;
```

```html
<head>
    <style>
        canvas{border: 1px solid red;}
    </style>
</head>
<body>
    <canvas width="600" height="400" id="mycanvas"></canvas>
    <script>
        var mycanvas = document.getElementById("mycanvas");
        var ctx = mycanvas.getContext("2d");

        var x = 100;
        setInterval (function() {
            x++; // 通过改变步长变换运动快慢 x+=10;
            ctx.clearRect(0, 0, 600, 400); //清屏,从左上角(0,0)到画布整个宽和高
            // 绘制一个新的圆形
            ctx.beginPath();
            ctx.arc(x, 100, 50, 0, Math.PI*2, true);
            ctx.closePath();
            ctx.fillStyle = "orange";
            ctx.fill();
        },20) // 每20毫秒去执行里面的语句
        // 每20毫秒清屏,重绘,其实不是一个圆,只是我们的视觉残留觉得他在运动
    </script>
</body>
```

改变运动速度的两种方法：

- 改变步长
- 改变时间

## DOM元素的移动

```html
<head>
    <style>
        div{
            width: 200px;
            height: 200px;
            background-color: orange;
            position: relative; /*动起来的话要有一个定位*/
        }
    </style>
</head>
<body>
    <div></div>
    <script>
        var div = document.getElementsByTagName("div")[0]; 
        var left = 0;
        setInterval(function() {
            left++;
            div.style.left = left + "px";
        },20)
    </script>
</body>
```

两个圆运动：

```html
<head>
    <style>
        canvas{border: 1px solid red;}
    </style>
</head>
<body>
    <canvas width="600" height="400" id="mycanvas"></canvas>
    <script>
        var mycanvas = document.getElementById("mycanvas");
        var ctx = mycanvas.getContext("2d");

        var x = 100;
        setInterval (function() {
            x++;
            ctx.clearRect(0, 0, 600, 400);
            ctx.beginPath();
            ctx.arc(x, 100, 50, 0, Math.PI*2, true);
            ctx.closePath();
            ctx.fillStyle = "orange";
            ctx.fill();

            ctx.beginPath();
            ctx.arc(x, 300, 50, 0, Math.PI*2, true);
            ctx.closePath();
            ctx.fillStyle = "blue";
            ctx.fill();
        },20)
    </script>
</body>
```

两个圆，一个从100起步，另一个从200起步：

```html
<head>
    <style>
        canvas{border: 1px solid red;}
    </style>
</head>
<body>
    <canvas width="600" height="400" id="mycanvas"></canvas>
    <script>
        var mycanvas = document.getElementById("mycanvas");
        var ctx = mycanvas.getContext("2d");

        var x1 = 100;
        var x2 = 200;
        setInterval (function() {
            ctx.clearRect(0, 0, 600, 400);
            
            x1++;
            ctx.beginPath();
            ctx.arc(x1, 100, 50, 0, Math.PI*2, true);
            ctx.closePath();
            ctx.fillStyle = "orange";
            ctx.fill();

            x2++;
            ctx.beginPath();
            ctx.arc(x2, 300, 50, 0, Math.PI*2, true);
            ctx.closePath();
            ctx.fillStyle = "blue";
            ctx.fill();
        },20)
    </script>
</body>
```

```html
不管页面上有几个元素在运动,一定只有一个定时器。定时器负责每帧清屏一次,然后重绘所有元素。但是关键是所有元素的信息、状态你难以维护,所以需要面向对象。
<head>
    <style>
        canvas{border: 1px solid red;}
    </style>
</head>
<body>
    <canvas width="600" height="400" id="mycanvas"></canvas>
    <script>
        var mycanvas = document.getElementById("mycanvas");
        var ctx = mycanvas.getContext("2d");

        //构造函数,圆类
        function Ball(x, y, r, speed) { //要有一个构造函数,要有一个类Ball
            this.x = x; //坐标x
            this.y = y; //坐标y
            this.r = r; //半径
            this.speed = speed; //速度
        }
        //渲染的方法
        Ball.prototype.render = function() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.r, 0, Math.PI*2, true);
            ctx.closePath();
            ctx.fill();
        }
        //更新的方法
        Ball.prototype.update = function() {
            this.x += this.speed;
        }
        //实例化一个小球
        var b = new Ball(100, 100, 50, 2);
        //唯一的一个定时器
        setInterval (function() {
            ctx.clearRect(0, 0, 600, 400); //清屏
            b.update(); //让小球更新
            b.render(); //渲染
        },20);
    </script>
</body>
```

```html
<head>
    <style>
        canvas{border: 1px solid red;}
    </style>
</head>
<body>
    <canvas width="600" height="400" id="mycanvas"></canvas>
    <script>
        var mycanvas = document.getElementById("mycanvas");
        var ctx = mycanvas.getContext("2d");

        //构造函数,圆类
        function Ball(x, y, r, speed) { //要有一个构造函数，要有一个类Ball
            this.x = x; //坐标x
            this.y = y; //坐标y
            this.r = r; //半径
            this.speed = speed; //速度
        }
        //渲染的方法
        Ball.prototype.render = function() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.r, 0, Math.PI*2, true);
            ctx.closePath();
            ctx.fill();
        }
        //更新的方法
        Ball.prototype.update = function() {
            this.x += this.speed;
        }
        //实例化一个小球
        var b1 = new Ball(100, 100, 50, 2);
        var b2 = new Ball(80, 200, 20, 8);
        //唯一的一个定时器
        setInterval(function() {
            ctx.clearRect(0, 0, 600, 400); //清屏
            b1.update(); //让小球更新
            b1.render(); //渲染

            b2.update();
            b2.render();
        },20);
    </script>
</body>
```

让所有演员（就是上画布的元素），都要进入数组，在定时器中，每一帧更新所有演员，渲染所有演员。

```html
<head>
    <style>
        canvas{border: 1px solid red;}
    </style>
</head>
<body>
    <canvas width="600" height="600" id="mycanvas"></canvas>
    <script>
        var mycanvas = document.getElementById("mycanvas");
        var ctx = mycanvas.getContext("2d");

        //构造函数,圆类
        function Ball(x, y, r, speed, color) { //要有一个构造函数,要有一个类Ball
            this.x = x; //坐标x
            this.y = y; //坐标y
            this.r = r; //半径
            this.speed = speed; //速度
            this.color = color; //颜色
            actorsArr.push(this);//将自己推入数组
        }
        //渲染的方法
        Ball.prototype.render = function() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.r, 0, Math.PI*2, true);
            ctx.closePath();
            ctx.fillStyle = this.color;
            ctx.fill();
        }
        //更新的方法
        Ball.prototype.update = function() {
            this.x += this.speed;
        }
        //演员数组
        var actorsArr = [];
        //实例化一些小球,他们都可以自动动画
        new Ball(100, 100, 30, 2, "red");
        new Ball(100, 200, 40, 3, "pink");
        new Ball(100, 300, 50, 4, "skyblue");
        new Ball(100, 400, 60, 5, "yellow");
        //帧编号,可以显示在屏幕左上角
        var fno = 0;
        //唯一的一个定时器
        setInterval(function() {
            ctx.clearRect(0, 0, mycanvas.width, mycanvas.height); //清屏
        //打印帧编号
        fno ++;
        ctx.fillStyle = "black"; //设置帧编号的颜色
        ctx.fillText("帧编号:"+ fno, 20, 20);
            //更新、渲染所有演员
            //用for循环来遍历
            for(var i = 0;i < actorsArr.length; i++) {
                actorsArr[i].update();
                actorsArr[i].render();
            }
        },20);
    </script>
</body>
```

项目：鼠标移动炫彩小球

```html
<head>
    <style>
        *{
            margin: 0;
            padding: 0;
        }
        body{
            background: black;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <canvas id="mycanvas"></canvas>
    <script>
        var mycanvas = document.getElementById("mycanvas");
        var ctx = mycanvas.getContext("2d");

        //设置画布满屏
        mycanvas.width = document.documentElement.clientWidth;
        mycanvas.height = document.documentElement.clientHeight;
        //小球类
        function Ball(x,y) {
            this.x = x; //圆心横坐标x
            this.y = y; //圆心纵坐标y
            this.r = 30; //半径给定死
            this.color = "rgba(" + parseInt(Math.random() * 256) + "," + parseInt(Math.random() * 256) + "," + parseInt(Math.random() * 256) + ",0.8)";
            this.dx = parseInt(Math.random() * 8) - 4; //x的变化值
            this.dy = parseInt(Math.random() * 8) - 4; //y的变化值
            ballsArr.push(this); //让自己进入数组
        }
        //更新的方法
        Ball.prototype.update = function() {
            this.x += this.dx;
            this.y += this.dy;
            this.r --; //半径减小，当自己半径没有的时候要从数组中清除自己了
            if(this.r < 0) {
                this.godie(); //执行godie函数
            }
        }
        //渲染的方法
        Ball.prototype.render = function() {
        	ctx.beginPath();
            ctx.arc(this.x, this.y, this.r, 0, Math.PI*2, true);
            ctx.closePath();
            ctx.fillStyle = this.color;
            ctx.fill();
        }
        //自杀函数
        Ball.prototype.godie = function() {
            //遍历数组,因为不知道数组中第几项
            for(var i = 0; i < ballsArr.length; i++) {
                if(ballsArr[i] === this) { //如果数组中有值等于自己
                    ballsArr.splice(i, 1); //让数组删除自己，第i项，删1项
                }
            }
        }
        //把类构建好以后要学会静态的去测试一下
        //var b = new Ball(100,100);
        //b.render();
        
        //小球数组
        var ballsArr = [];
        //监听
        mycanvas.onmousemove = function(event) {
            new Ball(event.clientX , event.clientY)
        }
        //定时器
        setInterval(function() {
            //清屏
            ctx.clearRect(0, 0, mycanvas.width, mycanvas.height);
            //渲染、更新所有小球
            for(var i = 0; i < ballsArr.length; i++) {
                ballsArr[i].update();
                //因为update可能会删除这个小球(半径小于0)，所以要验证一下这个小球是否存在
                ballsArr[i] && ballsArr[i].render(); 
            };
        }, 20);
    </script>
</body>
```

使用图片：`canvas`中不可能所有的形状都自己画，一定是美工给我们素材，我们使用。

`canvas`中使用图片，使用`drawImage`函数，但是有一个事必须注意，必须等`img`完全加载之后才能呈递图片。

```html
<body>
    <canvas width="400" height="600" id="mycanvas"></canvas>
    <script>
        var mycanvas = document.getElementById("mycanvas");
        var ctx = mycanvas.getContext("2d");

        // 创建一个img对象的孤儿节点
        var image = new Image();
        image.src = "img/1.jpg";
        // 一定要等到这个图片loading之后,然后渲染她
        image.onload = function() {
            ctx.drawImage(image, 0, 0, 350, 550);//img这张图放到(0,0)位置上去宽350高550
        }
    </script>
</body>
```

使用精灵制作元素行走：

```html
<head>
    <style>
        canvas{border: 1px solid #333;}
    </style>
</head>
<body>
    <canvas width="800" height="1200" id="mycanvas"></canvas>
    <script>
        var mycanvas = document.getElementById("mycanvas");
        var ctx = mycanvas.getContext("2d");

        var image = new Image();
        image.src = "img/1.png";

        var step = 0;
        var x = 100;
        image.onload = function() {
            setInterval(function() {
                //清屏
                ctx.clearRect(0, 0, 800, 1200);
                step++;
                if(step > 3){
                    step = 0;
                }
                x+=12;
                ctx.drawImage(image, 71* step, 111*0, 71, 111, x, 100, 71, 111);
            },100)
        }
    </script>
</body>
```

```
渐变:
	线性渐变:起点和终点,这里只是规定一个方向,从某一点到另一点方向的渐变
		createLinearGradient(x1,y1,x2,y2);
	径向渐变:从某一个圆到另一个圆的渐变
		createRadialGradient(x1,y1,r1,x2,y2,r2);
绘制图案:
    createPattern(img,'repeat|repeat-x|repeat-y|no-repeat'); // 把图片放到canvas中
    img: 图片,画布,视频元素;
    注意: 等资源加载完;
```

```
操作图形:
1.translate(dx,dy); 
重新映射画布上的(0,0)位置,平移了坐标系,改变了中心点,操作的是整个画布,在平移之后下面所画的图形也是带有平移之后效果的;		ctx.translate(100,100);

2.scale(sx,sy);
缩放当前绘图
ctx.scale(0.5, 2); 水平方向缩小为原来的0.5倍,垂直方向拉伸为原来的2倍

3.rotate(Math.PI);
旋转当前的绘图
ctx.rotate(Math.PI*0.25);

4.save();
保存当前图像的一份拷贝;

5.restore();
栈中弹出存储的图形状态并恢复

6.setTransform(a,b,c,d,e,f);
参数:a水平缩放,b水平倾斜,c垂直倾斜,d垂直缩放,e水平移动,f垂直移动
变换矩阵,先重置再变换,会清空原来的坐标系再重新开始绘制

7.transform(a,b,c,d,e,f);
在之前的基础上变换,不会清空坐标系,继续绘制(6和7是一样的)
```

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
        <style>
            canvas{
                border: 1px solid #000;
            }
        </style>
    </head>
    <body>
        <canvas id="myCanvas" width="400" height="400"></canvas>
        <img id="img" src="./video/1.jpg" alt="">
        <script>
            var myCanvas = document.getElementById("myCanvas");
            var ctx = myCanvas.getContext('2d');
            
            var img = document.getElementById('img');
            img.onload = function() {
                var bg = ctx.createPattern(img, 'repeat');
                ctx.fillStyle = bg;
                ctx.fillRect(0, 0, 400, 400);
            };
            // var bg = ctx.createLinearGradient(0,100,400,100); //这里换成var bg = ctx.createRadialGradient(200, 200, 50, 200, 200, 100);同心圆,一个半径是50,一个半径是100
            // bg.addColorStop(0,'red'); //颜色设置为transparent
            // bg.addColorStop(0.5, 'orange');
            // bg.addColorStop(1, 'green'); //颜色设置为transparent 透明色
            // ctx.fillStyle = bg;
            // ctx.fillRect(0, 0, 400, 100);
        </script>
    </body>
</html>
```

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
        <style>
            canvas{
                border: 1px solid #000;
            }
        </style>
    </head>
    <body>
        <canvas id="myCanvas" width="400" height="400"></canvas>
        <script>
            var myCanvas = document.getElementById("myCanvas");
            var ctx = myCanvas.getContext('2d');
            
            var w = myCanvas.width,
                h = myCanvas.height;
            ctx.translate(200, 100);
            for(var i = 1;i < 60;i ++) {
                ctx.translate(30,30); // 向右平移
                ctx.scale(0.95, 0.95); // 缩放圆,变小 
                // ctx.transform(0.95, 0, 0, 0.95, 30, 30); 可以替换上面两行代码
                ctx.rotate(Math.PI/12); // 每次在原来的基础上旋转30°

                ctx.beginPath();
                ctx.fillStyle = 'red';
                ctx.globalAlpha = '0.4'; // 透明度
                ctx.arc(0, 0, 50, 0, Math.PI*2, true);
                ctx.closePath(); // 做一个闭合图形的时候最好都带上closePath
                ctx.fill();
            }
        </script>
    </body>
</html>
```

```
globalCompositeOperation组合图形
ctx.globalCompositeOperation = 'source-over';
```

```
clearRect(x,y,dx,dy); // 擦除当前区域
```

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
        <style>
            canvas{
                border: 1px solid #000;
            }
        </style>
    </head>
    <body>
        <canvas id="myCanvas" width="400" height="400"></canvas>
        <script>
            var myCanvas = document.getElementById("myCanvas");
            var ctx = myCanvas.getContext('2d');
            
            var w = myCanvas.width,
                h = myCanvas.height;
            ctx.fillRect(0, 0, w, h);
            myCanvas.onmousemove = function(e) {
                ctx.clearRect(e.clientX - 25, e.clientY - 25, 50, 50); 
                // 绑定一个鼠标事件,e.client鼠标的x方向,-25是把中心点移动到橡皮中间位置;
            };
        </script>
    </body>
</html>
```

矩形落地`demo`：

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
        <style>
            canvas{
                border: 1px solid #000;
            }
        </style>
    </head>
    <body>
        <canvas id="myCanvas" width="400" height="400"></canvas>
        <script>
            var myCanvas = document.getElementById("myCanvas");
            var ctx = myCanvas.getContext('2d');
            
            var w = myCanvas.width,
                h = myCanvas.height;
            var y = 0;
            ctx.fillRect(100, y, 50, 50);
            var timer = setInterval(function() {
                ctx.clearRect(0, 0, w, h); // 每次进来都要清空画布
                y += 10;
                if(y >= 350) {
                    clearInterval(timer);
                    ctx.fillRect(100,350, 50, 50); // 直接生成
                }else {
                    ctx.fillRect(100, y, 50, 50);
                }
            }, 50);
        </script>
    </body>
</html>
```

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
        <style>
            canvas{
                border: 1px solid #000;
            }
        </style>
    </head>
    <body>
        <canvas id="myCanvas" width="400" height="400"></canvas>
        <script>
            var myCanvas = document.getElementById("myCanvas");
            var ctx = myCanvas.getContext('2d');
            
            var w = myCanvas.width,
                h = myCanvas.height;
            ctx.fillStyle = 'red'; // 画布填充色 红色
            ctx.fillRect(0, 0, 400, 400); // 范围是整个画布
            // 采用新旧像素合并的方式擦除重叠区域;
            ctx.globalCompositeOperation = 'destination-out'; 
            myCanvas.onmousemove = function(e) {
                ctx.beginPath();
                ctx.arc(e.clientX, e.clientY, 50, 0, Math.PI*2);
                ctx.closePath();
                ctx.fillStyle = 'green';
                ctx.fill();
            };
        </script>
    </body>
</html>
```

```
绘制图像:
    1.drawImage导入图片,并抠图;
    	drawImage(image,x,y); 在画布上定位图像,插入到canvas的起始坐标;
    	drawImage(image,x,y,width,height); 在画布上定位图像,并规定图像的宽度和高度;
    	drawImage(image,sx,sy,swidth,sheight,x,y,width,height); 裁剪起始点坐标(sx,sy),以及裁剪的宽swidth,裁剪的高sheight,剪切图像,并在画布上定位被剪切的部分;在图片的(sx,sy)点为起点,以宽swidth和高sheight为大小进行裁剪,并且把裁剪后的图片放在canvas中的以点(x,y),以及宽和高进行放置;
    2.getImageDate(x,y,dx,dy); //同源策略,需要开服务器,在服务器上进行操作;
    3.createImageDate(w,h); //创建新的空白ImageDate对象;
    4.putImageDate(imgDate,x,y); //将图像数据放回画布上; 
```

```
1.抽取canvas为图片,是dom元素上的方法;
2.canvas.toDateURL();将canvas的内容抽取成一张图片,base64编码格式;
	注:同源策略的限制,要开启服务器,在www目录下打开
3.将canvas的内容放去img元素里;
```

```
模糊问题:
    1.位图像素放大会失真,canvas为位图像素;
    2.canvas绘图时,会从两个物理像素的中间位置开始绘制并向两边扩散0.5个物理像素。由于不存在0.5个像素,两边都取了1个像素,视觉上就造成了模糊。解决方案:放大再缩小。
```



# `SVG`

```
使用:
    在线编辑工具 Method Draw
    地址: http://editor.method.ac/
    只要粘贴path元素放到svg便签中
```

```
html:
	<svg xmlns="http://www.w3.org/2000/svg" version="1.1"></svg>
js:
    var char = "http://www.w3.org/2000/svg";
    var svg = document.createElementNS(char,'svg');
```

```
注意: SVG元素对象一般通过调用setAttribute();方法来设定属性值;
```

```
应用场景:
    1.图形(脑图);百度脑图
    2.图标,logo(矢量图);放大不失真
    3.动效;
```

```
基础元素:
    1.直线(起始点和终点);
    	<line x1="100" y1="100" x2="200" y2="100"></line>
    2.矩形(rx水平方向设置圆角和ry垂直方向设置圆角);
    	<rect x="100" y="100" width="100" height="100" rx="20" ry="50"></rect>
    3.圆形(中心点cx,cy和半径r);
    	<circle cx="100" cy="100" r="50"></circle>
    4.椭圆(圆心rx,ry和水平方向垂直方向的长轴和短轴cx,cy。属性可以写像素px,和canvas不一样);
    	<ellipse rx="100" ry="50" cx="250" cy="250"></ellipse>
    5.多边形(写各个边的顶点坐标);
    	<polygon points="100 100,70 150,130 150"></polygon>
    6.折线(点,像canvas一样会把起始点和结束点自动连接一下,然后自动填充颜色);
    	<polyline points="0 100,100 35,200 150,300 75,400 150,500 20"></polyline>
    7.字体(字体设定的位置坐标x,y);
    	<text x="300" y="300">蝉壳</text>
```

```
基础样式:
    1.fill: transparent;透明
    2.stroke: red;
    3.stroke-width: 10px;
    4.stroke-opacity/fill-opacity: 0.5;
    5.stroke-linecap: butt/round/square;
    6.stroke-linejoin: bevel/round/miter; 两条线交点处的样式
```

```
重要元素:
<path>元素可以定义一个路径,属性说明如下: 
    d:定义路径指令;
    M = moveto 移动到;
    L = lineto 画线到;
    H = horizontal lineto 水平画线到;
    V = vertical lineto 垂直画线到;
    C = curveto 三次贝塞尔曲线画线到;
    S = smooth curveto 光滑三次贝塞尔曲线画线到;
    Q = quadratic Bezier curve 二次贝塞尔曲线画线到,有一个起点终点和控制点;
    T = smooth quadratic Bezier curve 光滑二次贝塞尔曲线画线到;
    A = elliptical Arc 椭圆弧;
        <path d="M 100 100 A 70 120 0 1 1 150 200">
        起始点(100,100);
        终点(150,200);
        A里面的70 120代表椭圆的长轴和短轴;
        0代表旋转,先旋转后相交;
        前一个1代表取两点相交之间较长的部分;
        后一个1代表取顺时针部分;
    Z = closepath 关闭路径,后面没有属性值;
注: 以上所有命令均允许大小写,大写表示绝对定位,小写表示相对定位;
```

```html
<style>
	svg{
        border: 1px solid #000;
	}
	line{
        stroke: red; //画线比较特别
	}
	circle{
        fill: green; //也可以和宽高一样直接写在dom元素上
	}
	path{
        fill: transparent;
        stroke: #000;
	}
</style>
<body>
	<svg width="500" height="500" xmlns="http://www.w3.org/2000/svg" version="1.1">
		<line x1="100" y1="100" x2="200" y2="100"></line>
		<path d="M 100 100 L 400 100"></path>
	</svg>
</body>
```

```
路径属性:
1.stroke-dasharray: 100px; 
    1个值对应画多少空多少 ---> 虚线;
    2个值对应画和空 ---> 虚线;
    循环我们所填的值(顺序是画一下,空一下);
2.stroke-dashoffset: 15px;
	调整线往里缩;
注: getTotalLength获取路径长度
```

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
        <style>
            svg{
                border: 1px solid #000;
                stroke: #000;
                stroke-width: 3px;
                stroke-dasharray: 300px;
                stroke-dashoffset: 15px;
            }
        </style>
    </head>
    <body>
        <svg width="500" height="500" xmlns="http://www.w3.org/2000/svg" version="1.1">
            <path id="move" d="M 100 100 L 400 100"></path>
        </svg>
        <script>
            //做动画计时器
            var stroke = 0;
            var timer = setInterval(function() {
                stroke += 10;
                if(stroke < 300) {
                    move.style.strokeDashoffset = stroke + "px";
                }else {
                    clearInterval(timer);
                    move.style.strokeDashoffset = "300px"; //防止bug
                }
            }, 100);
        </script>
    </body>
</html>
```

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
        <style>
            svg{
                border: 1px solid #000;
                stroke: #000;
                stroke-width: 3px;
                stroke-dasharray: 300px;
                stroke-dashoffset: 15px;
            }
        </style>
    </head>
    <body>
        <svg width="500" height="500" xmlns="http://www.w3.org/2000/svg" version="1.1">
            <path id="move" d="M 100 100 A 70 120 90 1 1 150 200" stroke="orange" stroke-width="3" fill="none"></path>
        </svg>
        <script>
            //做动画计时器
            var total = move.getTotalLength(); // 获取圆弧的总长度
            move.style.strokeDasharray = total + "px";
            var stroke = 0;
            var timer = setInterval(function() {
                stroke += 10;
                if(stroke < total) {
                    move.style.strokeDashoffset = stroke + "px";
                }else {
                    clearInterval(timer);
                    move.style.strokeDashoffset = total + "px";
                }
            }, 100);
        </script>
    </body>
</html>
```



# 渐变

```html
1.线性渐变:
    <defs>
        <linearGradient id="bg1" x1="0" y1="0" x2="0" y2="100%">
            <stop offset="0%" style="stop-color:rgba(255,255,0);"/>
            <stop offset="100%" style="stop-color:rgba(255,0,0);"/>
        </linearGradient>
    </defs>
    <rect x="0" y="0" width="500" height="500" style="fill:yrl(#bg1)"/>
```

```html
2.径向渐变:
    <defs>
        <radialGradient id="bg2" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
            <stop offset="0%" style="stop-color:green;"/>
            <stop offset="100%" style="stop-color:red;"/>
        </radialGradient>
    </defs>
```



# 滤镜

```html
1.高斯滤镜:
	<defs>
		<filter id="Gaussian_Blur">
			<feGaussianBlur in="SourceGraphic" stdDeviation="20"/>
		</filter>
	</defs>
	<rect x="0" y="0" width="500" height="500" fill="yellow" 			style="filter:url(#Gaussian_Blur)"/>
```

```html
2.其他滤镜:
	http://www.w3chool.com.cn/svg/svg_filters_intro.asp
```

