## 1.运算

### 1.1 运算符

运算规则：所有运算一律转为数值后进行计算，除加法外其他运算符都不会发生重载。

```javascript
'a' + 'bc' // "abc"
true + true // 2
false + 'a' // "falsea"
'3' + 4 + 5 // "345"
3 + 4 + '5' // "75"
1 - '2' // -1
1 * '2' // 2
1 / '2' // 0.5
```

总结：

```
除数可以为0;
求模结果的符号和除数无关;
除法的结果为小数;
浮点数的计算结果不精确;
先乘除模,后加减,如果优先级一致,则从左到右依次计算;
```

### 1.2 对象相加

对象会转成原始类型的值`[object Object]`。

原理：

- 先调用对象的`valueOf`方法，返回对象自身
- 再调用对象的`toString`方法，默认返回`[object Object]`，将其转为字符串

```javascript
var obj = {p: 1};
obj + 2 // "[object Object]2"
```

```javascript
// 自定义valueof()

var obj = {
  valueOf: function() {
    return 1;
  }
};

obj + 2 // 3
```

```javascript
// 自定义toString()

var obj = {
  toString: function() {
    return 'hello';
  }
};

obj + 2 // "hello2"
```

加法运算符的特例：

当对象是`Date`对象的实例并且自定义了`valueOf`和`toString`方法，结果会优先执行`toString`方法而忽略`valueOf`方法。

```javascript
var obj = new Date();
obj.valueOf = function () { return 1 };
obj.toString = function () { return 'hello' };

obj + 2 // "hello2"
```

### 1.3 取余运算符

运算结果的正负号由第一个运算子决定。

```javascript
-1 % 2 // -1
1 % -2 // 1
```

```javascript
function isOdd(n) {
  return Math.abs(n % 2) === 1;
}
isOdd(-5) // true
isOdd(-4) // false
```

### 1.4 数值运算符

返回一个新值而不改变原始变量的值。

作用：将任何值转为数值，与`Number`函数的作用相同。

```javascript
+true // 1
+[] // 0
+{} // NaN
```

### 1.5 字符串的比较

按照字典顺序进行比较，比较首字母的`Unicode`码点。

非字符串的比较：

- 除了相等运算符 == 和严格相等运算符 === 外，其他比较运算符都是先转成数值再进行比较
- 任何值（包括`NaN`本身）与`NaN`进行比较，结果都是`false`

### 1.6 对象之间的比较

```javascript
[2] > [1] //true

// [2].valueOf().toString() > [1].valueOf().toString()
// 即 '2' > '1'
```

```javascript
[2] > [11] // true

// [2].valueOf().toString() > [11].valueOf().toString()
// 即 '2' > '11'
```

```javascript
{x: 2} >= {x: 1} // true

// {x: 2}.valueOf().toString() >= {x: 1}.valueOf().toString()
// 即 '[object Object]' >= '[object Object]'
```

其他：

```
NaN与任何值都不相等
```

```javascript
+0 === -0 // true
```

### 1.7 复合类型值的比较

复合类型数据的比较，比较它们是否指向同一地址。

对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值。

```js
{} === {} // false
[] === [] // false
(function () {} === function () {}) // false
```

```javascript
var v1 = {};
var v2 = v1;
v1 === v2 // true
```

```javascript
new Date() > new Date() // false
new Date() < new Date() // false
new Date() === new Date() // false
```

### 1.8 `undefined`和`null`的比较

`null`是一个空对象，转为数值时始终为`0`。

`undefined`转为数值时为`NaN`。

`undefined`和`null`与其他类型值比较时为`false`。互相比较时，为`true`。

```js
Number(null); // 0
5 + null // 5

undefined == null // true
undefined === null // false
```

```javascript
undefined === undefined // true
null === null // true
```

```js
'true' == true // false

// 等同于 Number('true') === Number(true)
// 等同于 NaN === 1
```

```js
'' == 0 // true

// 等同于 Number('') == 0
// 等同于 0 == 0
```

```javascript
'\n  123  \t' == 123 // true

// 字符串转数字时,省略前置和后置的空格
```

### 1.9 对象与原始类型值比较

```javascript
[1] == 1 // true
// 等同于 Number([1]) == 1
```

```javascript
0 == ''             // true
0 == '0'            // true

false == 'false'    // false
false == '0'        // true

' \t\r\n ' == 0     // true
```

两次取反就是将值转为布尔类型：

```javascript
!!x
// 等同于
Boolean(x)
```

短路：

```javascript
() && () 
当前面括号里是true时,返回后面括号里的结果;
当前面括号里是false时,直接返回此false结果;

var x = 1;
(1 - 1) && (x += 1)
console.log(x); // 1
```

```js
true && 'foo' && '' && 4 && 'foo' && true // ''
```

```javascript
if(i) {
  doSomething();
}
// 等价于
i && doSomething();
```

### 1.10 或运算符

```javascript
't' || '' // "t"
't' || 'f' // "t"
'' || 'f' // "f"
'' || '' // ''
```

短路：

```
() || ()
当前面括号里是true时,直接返回true的最后结果;
当前面括号里是false时,返回后面括号内的结果;
```

```javascript
var x = 1;
true || (x = 2) // true
x // 1
```

```javascript
false || 0 || '' || 4 || 'foo' || true
// 4
```

或运算符用于为变量设置默认值：

```javascript
function saveText(text) {
  text = text || '';
  // ...
}

// 或者写成
saveText(this.text || '')
```

总结：优先级 ！ >  &&  >  ||

### 1.11 `void`运算符

```javascript
<script>
    function f() {
      console.log('Hello World');
    }
</script>
<a href="http://example.com" onclick="f();return false;">点击</a>

// 点击链接先执行onclick代码,由于return false,所以浏览器不会跳转到example.com
```

`void`优化：

```js
<a href="javascript: void(f())">文字</a>
```

```javascript
<a href="javascript: void(document.form.submit())">
  提交 // 阻止提交表单时的页面跳转
</a>
```

### 1.12 逗号运算符

对两个表达式进行求值，返回后一个表达式的值。

```javascript
'a','b' // "b"
```

```javascript
var x = 0;
var y = (x++, 10);
x // 1
y // 10
```



## 2.数据类型转换

强制转换数据类型：`Number`、`String`、`Boolean`函数。

### 2.1 `Number()`

依照参数不同，存在两种情况：

- 参数是原始类型
- 参数是对象类型

```javascript
Number(324) // 324
Number('324') // 324 
Number('324abc') // NaN 
Number(undefined) // NaN
Number(null) // 0
```

总结：可被解析为数值的，转换为对应数值。不可解析为数值的，返回`NaN`。空字符串转为`0`。

```javascript
// 返回NaN,包含单个数值的数组除外;

Number({a: 1}) // NaN
Number([1, 2, 3]) // NaN

Number([5]) // 5
```

`Number`转换原理：

- 先调用对象自身的`valueOf`方法，若返回原始类型数值，则直接对该值使用`Number`函数，不再进行后续步骤
- 若`valueOf`方法返回的还是对象，则改为调用对象自身的`toString`方法，如果`toString`方法返回原始类型的值，则对该值使用`Number`函数，不再进行后续步骤；如果`toString`方法返回的是对象，报错

```javascript
Number({}) // NaN
// 先调用obj.valueOf方法,返回对象本身则继续调用obj.toString方法,返回字符串[object Object],对此字符串使用Number函数,得到NaN;
```

默认情况下，对象的`valueOf`方法返回对象本身，所以总是会调用`toString`方法。
而`toString`方法返回对象的类型字符串，如：`[object Object]`。

```javascript
var obj = {x: 1};
Number(obj) // NaN
// 等同于
if(typeof obj.valueOf() === 'object') {
  Number(obj.toString());
}else {
  Number(obj.valueOf());
}
```

总结：先调用对象自身的`valueof`方法，一般都是返回对象自身，再调用对象的`toString`方法，返回`[object, object]`类型字符串，最后调用`Number`包装类，得到`NaN`。

自定义`valueOf`和`toString`方法：

```javascript
Number({
  valueOf: function () {
    return 2;
  },
  toString: function () {
    return 3;
  }
})
```

关于`Number`函数和`parseInt`函数的比较：

相同：`parseInt`和`Number`函数都会自动过滤掉一个字符串，前导和后缀的空格。

不同：

- `parseInt`('42 cats') // 42 逐个解析字符
- `Number`('42 cats') // `NaN` 整体转换字符

总结：`Number`将字符串转为数值比`parseInt`函数严格很多，只要有一个字符无法转换，直接`NaN`

### 2.2 `String()`

原始类型值：

```
数值,字符串,布尔值,null,undefined,都转为对应字符串形式
```

对象：

```js
String({a: 1}) // "[object Object]"
```

```js
// 数组,返回该数组的字符串形式;
String([1, 2, 3]) // "1,2,3"
```

原理：与`Number`方法相似，只是互换了`valueOf`和`toString`方法的执行顺序。

```
先调用对象自身的toString方法,如果返回原始类型的值,则对该值使用String函数,不再进行以下步骤;
如果toString方法还是返回对象,再调用原对象的valueOf方法,如果valueOf方法返回原始类型的值,对该值使用String函数,不再进行以下步骤;如果valueOf返回对象,报错;
```

```javascript
String({a: 1})
// "[object Object]"

// 等同于

String({a: 1}.toString())
// "[object Object]"
```

自定义`toString`和`valueOf`方法

```javascript
String({
  toString: function() {
    return 3;
  }
})
// "3"

String({
  valueOf: function() {
    return 2;
  }
})
// "[object Object]"

String({
  valueOf: function() {
    return 2;
  },
  toString: function() {
    return 3;
  }
})
// "3"

// 第一个对象返回toString方法的值,数值3;
// 第二个对象返回的还是toString方法的值,[object Object];
// 第三个对象表示toString方法先于valueOf方法执行;
```

### 2.3 `Boolean()`

除以下六个值转换结果为`false`外，其余都为`true`。

```
false
+0 / -0
NaN
''
null
undefined
```



## 3.自动转换类型

```javascript
123 + 'abc' // "123abc"
```

```javascript
// 对非布尔值类型的数据求布尔值
if('abc') {
  console.log('hello') 
}  
```

```javascript
// 对非数值类型值使用一元运算符
+{foo: 'bar'} // NaN
-[1, 2, 3] // NaN
+'abc' // NaN
-'abc' // NaN
+true // 1
-false // 0
```

```javascript
// 将表达式转为布尔值,内部调用Boolean函数
expression ? true : false
!! expression
```

```javascript
'5' + {} // "5[object Object]"
'5' + function() {} // "5function() {}"
'5' + undefined // "5undefined"
'5' + null // "5null"
'5' + [] // "5"
'5' * []    // 0
undefined + 1 // NaN
```



## 4.错误处理机制

### 4.1 `Error`实例对象

原生`JavaScript`提供了`Error`构造函数，所有抛出的错误都是这个构造函数的实例。

```javascript
var err = new Error('出错了');
err.message // "出错了"
```

### 4.2 原生错误类型

`SyntaxError`对象：解析代码时发生的语法错误。

`ReferenceError`对象：引用一个不存在的变量时发生的错误。

`RangeError`对象：数值超出有效范围时发生的错误。

`TypeError`对象：变量或参数不是预期类型时发生的错误。

### 4.3 自定义错误

```javascript
// 自定义函数,构建错误对象

function UserError(message) {
  this.message = message || '默认信息';
  this.name = 'UserError';
}
```

```javascript
// 指定新建的错误对象函数的原型继承自Error对象
UserError.prototype = new Error();

UserError.prototype.constructor = UserError;

new UserError('这是自定义的错误！');
```

#### `throw`语句

手动中断程序执行并抛出错误。

```javascript
if(x < 0) {
  throw new Error('x要大于0'); // 程序中断
  console.log('我执行了吗')
}
// Uncaught ReferenceError: x is not defined
```

```javascript
// throw抛出自定义错误

function UserError(message) {
  this.message = message || '默认信息';
  this.name = 'UserError';
}

throw new UserError('出错了');
// Uncaught UserError {message: "出错了！", name: "UserError"}
```

`throw`抛出任何类型的值

```javascript
// 抛出数值
throw 42;
// Uncaught 42

// 抛出字符串
throw 'Error！';
// Uncaught Error！

// 抛出布尔值
throw true;
// Uncaught true

// 抛出对象
throw {
  toString: function () {
    return 'Error!';
  }
};
// Uncaught {toString: ƒ}
```

#### `try…catch`结构

允许对错误进行处理，可选择是否往下执行。

```javascript
try{
  throw new Error('出错了!');
  console.log('这里不会执行')
}catch(e) {
  console.log(e.name + ": " + e.message);
  console.log(e.stack);
}

// Error: 出错了!
//   at <anonymous>:3:9
//   ...

// 总结: 当try代码块抛出错误,JavaScript引擎立即把代码的执行转到catch代码块,被catch代码块捕获了;catch接受一个参数,表示try代码块抛出的值;
```

如果不确定某些代码是否会报错，可把它们放在`try...catch`代码块中，便于进一步对错误进行处理。

```javascript
try{
  f();
}catch(e) {
  // 处理错误
}

// 如果函数f执行报错,就会进行catch代码块,接着对错误进行处理;
// catch代码块捕获错误之后,程序不会中断,按照正常流程继续执行下去;
```

```javascript
try{
  throw "出错了";
}catch(e) {
  console.log(111);
}
console.log(222);
// 111
// 222
```

`catch`代码块中还可再抛出错误，甚至可以使用嵌套的`try...catch`结构

```javascript
var n = 100;
try{
  throw n;
}catch(e) {
  if(e <= 50) {
    // ...
  }else {
    throw e;
  }
}
// Uncaught 100
```

```javascript
try{
  foo.bar();
}catch(e) {
  if(e instanceof EvalError) {
    console.log(e.name + ": " + e.message);
  }else if(e instanceof RangeError) {
    console.log(e.name + ": " + e.message);
  }
  // ...
}

// 上面代码中,catch捕获错误后,会判断错误类型(EvalError还是RangeError),进行不同的处理
```

#### `finally`代码块

`try...catch`结构允许在最后添加一个`finally`代码块。表示不管是否出现错误，都必须运行的语句。

```javascript
function cleansUp() {
  try{
    throw new Error('出错了……');
    console.log('此行不会执行');
  }finally {
    console.log('完成清理工作');
  }
}

cleansUp()

// 完成清理工作
// Error: 出错了……

// 由于没有catch语句块,所以错误没有被捕获
// 执行finally代码块以后,程序就中断在错误抛出的地方
```

```javascript
function idle(x) {
  try{
    console.log(x);
    return 'result';
  }finally {
    console.log("FINALLY");
  }
}

idle('hello')
// hello
// FINALLY
// "result"

// try代码块没有发生错误,而且里面还包括return语句,但是finally代码块依然会执行;注意: 只在其执行完毕后才会显示return语句的值。
```

`return`语句的执行是排在`finally`代码之前的，只是等`finally`代码执行完毕后才返回。

```js
var count = 0;
function countUp() {
  try{
    return count;
  }finally {
    count++;
  }
}

countUp()
// 0
count
// 1
```

`try...catch...finally`三者的执行顺序：

```javascript
function f() {
  try{
    console.log(0);
    throw 'bug';
  }catch(e) {
    console.log(1);
    return true; // 这句原本会延迟到finally代码块结束再执行
    console.log(2); // 不会运行
  }finally {
    console.log(3);
    return false; // 这句会覆盖掉前面那句return
    console.log(4); // 不会运行
  }
  console.log(5); // 不会运行
}

var result = f();
// 0
// 1
// 3
```
