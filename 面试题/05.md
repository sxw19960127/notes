---
title: 重点背诵记忆
date: 2019-08-15 23:56:05
tags: 遗忘曲线
categories: Web前端开发
notshow: true
encrypt: true
enc_pwd: Iverson
---

考题1：一个页面从输入URL到页面加载完成，都发生了什么？

```
1.首先在浏览器地址栏中输入URL;
2.浏览器先查看浏览器缓存-系统缓存-路由器缓存,如果缓存中有,会直接在屏幕中显示页面内容;
3.如果没有,则在发送http请求前,需要域名解析(DNS),解析获取相应的IP地址;
4.浏览器向服务器发起tcp链接,与浏览器建立tcp三次握手;
    a)客户端向服务器发送连接请求报文;
    b)服务器端接收客户端发送的连接请求后回复ACK报文,并为这次连接分配资源;
    c)客户端接收到ACK报文后也向服务端发送ACK报文,并分配资源;
5.握手成功后,浏览器向服务器发送http请求,请求数据包,请求信息包含一个头部和一个请求体;
6.服务器处理收到的请求,将一个相应头和一个响应体返回至浏览器;
7.浏览器收到HTTP响应;
8.读取页面内容,浏览器渲染,解析html源码;
9.生成Dom树,解析css样式,js交互;
10.客户端和服务器交互;
11.ajax查询;
```

考题2：主流浏览器和它的内核

```
主流浏览器             内核
IE                  trident
Firefox             Gecko
Google chrome       Webkit/blink
Safari              Webkit
Opera               presto
```

考题3：CSS权重

```
!important              Infinity
行间样式                  1000
id                       100
class|属性|伪类            10
标签选择器|伪元素            1
通配符                      0
```

考题4：HTML & CSS 基本知识（杂）

```
a) body默认自带8px的margin;
b) position: absolute 和 float 一样,从内部把元素转换成inline-block;
c) 缩小图片应该改变图片的高度;
d) font-style: italic; / font-family: 微软雅黑;
e) text-indent: 2em; //首行缩进;
f) font-size: 16px = 1em ; //默认状态下
g) 打点实现:
		white-space: nowrap; //强制取消换行
        overflow: hidden; //溢出部分隐藏
        text-overflow: clip默认/ellipsis省略号;
h) a标签的作用: 超链接,锚点,打电话,发邮件,黑客技术(协议限定符);
i) 属性选择器:
        <p title="sxw">p1</p>
        p[title=sxw]{
            color: red;
            font-size: 50px;
        }
        p[title^=s]{ //属性值以s开头
            color: red;
        }
        p[title$=s]{ //属性值以s结束
            color: red;
        }
j) 选择器: id选择器,class选择器,标签选择器,通配符选择器,属性选择器,父子选择器,伪类选择器,相邻同级选择器
k) 和文字样式相关的可被继承;
l) 块元素,宽可继承父级,高由内容决定;
m) 行元素和块元素:
    块元素: 独占一行,可以设置宽高,默认宽高100%;
        文字类块元素: p h1~h6
        容器类块元素: div table(tr td th) form(dl dt dd) ul li
    行元素: 不独立成一行,不可以设置宽高;   
        内容决定: a img input span
    行级块元素: 内容决定大小,可以改变宽高,img;
        1.行级元素只能嵌套行级元素;
        2.块级元素可以嵌套任何元素;
        3.文字类块元素不可以嵌套块元素;
n) 清浮动(伪元素是行元素)在父级上设置:
    .container::before, .conainer::after{
        display: table;
        content: "";
    }
    .container::after{
        clear: both;
    }
o) 远视图实现原理: 子元素的 width + 父元素的 padding * 2 = 父元素的 width
```

考题5：margin塌陷 && margin合并

```
a.margin塌陷(父级没有顶棚);
    <style>
        .wrapper{
            width: 100px;
            height: 100px;
            background-color: black;
            margin-left: 100px;
            margin-top: 100px;
        }
        .content{
            width: 50px;
            height: 50px;
            background-color: green;
            margin-left: 50px;
            margin-top: 200px; 
            // 水平方向 margin 没问题
            // 垂直方向 子元素margin-top的值必须设置的比父级大,否则不生效;
            // 当子元素的margin-top生效时,老子和儿子共用这个margin-top;
            // 这就是所谓的margin塌陷!!!
        }
    </style>
    <body>
        <div class="wrapper">
            <div class="content"></div>
        </div>
    </body>
总结: 垂直方向上的margin,父子元素是结合在一起取最大值;
解决方法: bfc(block format context)块级格式化上下文,改变盒子里的语法规则;
触发盒子的bfc: 在子元素里添加样式;
    1.position: absolute;
    2.display: inline-block; 
    3.float: left/right;
------------------------------------------------------------------
b.margin合并(实际开发过程中我们不解决);
    <style>
        .demo1{
            background-color: red;
            margin-bottom: 100px;
        }
        .demo2{
            background-color: green;
            margin-top: 100px; //垂直方向上会导致较小的失效
        }
    </style>
    <body>
        <div class="demo1">a</div>
        <div class="demo2">b</div>
    </body>
```

考题6：画三角形

```
div{
    width: 0px;
    height: 0px; 
    border: 100px solid black; 
    border-left-color: red;
    border-top-color: transparent;
    border-right-color: transparent;
    border-bottom-color: transparent;
}
```

考题7：JavaScript 基础知识（杂）

```
a) js数据类型区分依据: 1)存储空间大小的差异; 2)所支持的操作符的差异;
b) NaN和任何数(包括他自己)进行操作结果都是false;
c) 基础类型: Number String Boolean; 引用类型: Array Function Object; 特殊类型: undefined null
d) typeof: 以"字符串"的形式返回指定变量的数据类型(不能准确判断下面两个类型)
    typeof Null === "Object"
    typeof [] === "Object"
e) js对浮点数的计算结果不精确;
f) 任何数据类型 + 字符串结果都是字符串;
g) if-else语句: 
	如果if/else代码块中仅有一条语句,则可以省略大括号;
	false,空字符串,0,null,undefined 写在if中是false;
h) switch-case-default;
    //传入年份和月份,输出该月最大的天数
    var maxDays = function(year, month) {
        switch(month) {
            case 4:
            case 6:
            case 9:
            case 11:
                return 30;
            case 2:
                if(year % 4 === 0&&year % 100 !== 0||year % 400 === 0) {
                    return 29;
                }else {
                    return 28;
                }
            default:
                return 31;
        };
    };
    var q3 = function() {
        var result = maxDays(2017, 6);
        alert(result);
    }
    q3(); 
---------------------------------------------------------------------------
    //当用户选择男时,告诉用户"你是一个帅哥";选择女时,告诉用户"你是一个美女",其他情况"你是一个..."
    var q7 = function() {
        var sex = prompt("请输入你的性别", "男");
        switch(sex) {
            case "男":
                alert("你是一个帅哥");
                break;
            case "女":
                alert("你是一个美女");
                break;
            default:
                alert("你是一个...");
        }
    };
    q7();
i) 
    c = -3 % 5; //c = -3
    c = -3 % -5; //c = -3 //c的结果与除数的符号无关
    C = 1.0 - 0.9; //c = 0.099999999998  --->  2进制无法准确表示0.1
j)
true && ? ---> 当&&前面为true时,直接返回&&后面的值
false || ? ---> 当||前面为false时,直接返回||后面的值
k)
	var x = 567;
    var a = (x - x % 100) / 100 % 10;
    var b = (x - x % 10) / 10 % 10;
    var c = (x - x % 1) / 1 % 10;
    alert("第一位是："+ a + "第二位是：" + b + "第三位是:" + c);
l)
var f = function() {
    f = function() {
        alert(1);
    }
    alert(2);
};
f(); //2
f(); //1
---------------------
var f = function() {
    var f = function() {
        alert(1);
    };
    alert(2);
};
f(); //2
f(); //2
---------------------------
var f = function(f,a) { 
    //两个参数,第一个参数是方法,第二个是普通参数值,a是代入值代入f,最后结果为1
    return f(a);
};
var result = f(function(f) {
    return f;
},1);
alert(result); //1
------------------------------------
var f = (function(f) {
    return function(f){
        return f + f;
    };
})(1);
f = f(1);
alert(f);
```

考题8：改变this指向

```
在js中,函数也是对象,函数也有自己的属性和方法:
function test(a,b){
    console.log(a+b);
    console.log(this);
}
test(); //this指向window
---------------------------------------
创建一个对象:
var obj = {name: 'sxw'}
--------------------------
a.call方法,用于指定this调用函数,第一参数是指定的this对象,从第二个参数开始,是调用test函数所传递的参数;
test.call(obj,1,3);
----------------------------------------------------------------------------------------
b.apply方法,用于指定this调用函数,第一个参数是指定的this对象,和call的区别是: 第二个参数是一个数组,数组中存放本次调用要传递的参数;
test.apply(obj,[1,3]);
---------------------------------------------------------------------------------------
c.bind方法,不会调用本函数,而是生成一个新的函数,这个函数的代码逻辑和原函数一样,但是this指向不一样,bind用于指定this生成一个新的函数;
    var bar = function() {   
      console.log(this.x);   
    }
    var foo={ 
         x:3   
    }  
    bar(); //undefined  
    bar.bind(foo)(); //3
```

考题9：数组拷贝

```
//传入一个数组,返回一个新数组 (数组常用操作之拷贝)
var arrayClone = function(arr) {
    var newArr = [];
    for(var i = 0;i < arr.length;i ++) {
        newArr[i] = arr[i];
    }
    return newArr;
};

//克隆数组 var newArr = arr.silce(0);
newArr = arr.silce(0,arr.length); //克隆数组功能
深度克隆: 克隆完成的对象,不论是引用值还是原始值,都是各自独立的;
```

考题10：数组常用操作

```
遍历/过滤
拷贝
合并
排序
打乱
查找
插入
删除
查表法
随机数
---------------------
排序			平均时间复杂程度
冒泡(稳定)	   0(n^2)
选择(稳定)     0(n^2)
插入(稳定) 	   0(n^2)
快速(不稳定)	  0(n*log2n)
--------------------------------
冒泡排序:
function mp() {
	var temp;
	var len = arr.length;
	for(var i = 0;i < len - 1;i ++) {
		for(var j = 1;j < len - i;j ++) {
			if(arr[j - 1] < arr[j]) {
				temp = arr[j - 1]
				arr[j - 1] = arr[j]
				arr[j] = temp
			}
		}
	}
}
var arr = [9,2,7,1,3,4]
mp()
console.log(arr)
------------------------------------------
var arr = ["a","e","c","b","d"];
arr.sort(); //排序
console.log(arr);
--------------------------------
var f = function(a,b) {
    console.log(arguments); //伪数组
    for(var i = 0;i < arguments.length;i ++) {
        var item = arguments[i]; //具有数组的一些常用属性,却没有数组的一些常用特征
        console.log(item)
    }
};
f(1,2);
```

考题11：字符串

```
a)
var s = "abc";
var arr = s.split(""); //["a","b","c"]
b)
var arr = [1,2,3];
var str = arr.join(""); //"123"
c)
var arr = "a-b1-c-d".split("-c"); //["a-b1","-d"];
d)
var arr = [1,2,3];
var s = arr.join("-"); //1-2-3
e)
"abc".charAt(1); //b
f)
"abdcd".indexOf("d",3); //4 表示从做左到右第4位开始找
g)
"abcdefg".substring(1,5); //bcde 包含第一位不包含第二位的
"abcdefg".substring(1,-1); //a
```

考题12：对象

```
构造器:
var Student = function(name,age,sex) {
    this.name = name;
    this.age = age;
    this.sex = sex;
    this.study = function() {

    };
};
var s1 = new Student("张三",18,male);
var s2 = new Student(10087,"李四",19,false);
---------------------------------------------
输出当前时间:
var q1 = function() {
    var format = function(n) {
        return n < 10?("0" + n):String(n); //补0操作;
    };
    var now = new Date();
    var y = now.getFullYear();
    var M = now.getMonth() + 1;
    var d = now.getDate();
    var h = now.getHours();
    var m = now.getMinutes();
    var s = now.getSeconds();
    var str = y + "年" + format(M) + "月" + format(d) + "日 " + format(h) + ":" + format(m) + ":" + format(s);
    console.log(str)
};
q1();
```

考题13：数组对象

```
a.concat
    var arr1 = [1,2,3];
    var arr2 = ["a","b","c"];
    arr1 = arr1.concat(arr2); //[1, 2, 3, "a", "b", "c"]
b.join
c.pop 删除数组最后一个元素
    f = function() {
        var arr = [1,2,3];
        arr.shift(); //[2,3]
        arr.pop(); //[2]
        arr.unshift(0); //[0,2]
    };
d.reverse
e.shift/unshift
f.slice分割/splice结合
var arr = [1,2,3,4,5,6,7];
newArr = arr.silce(2,-1); //[3,4,5,6];
--------------------------------------
arr = [1,2,3,4,5,6];
arr.splice(2,3,"a","b"); //[1,2,"a","b",6] 在下标是2的位置开始往后删除3个数,然后再插入"a","b"
g.
var arr = [1,2,3,4,5,4];
alert(arr.indexOf(4)); //找4元素的索引为3
```

考题14：数组循环遍历

```
1.forEach 没有办法终止循环
var arr = ['abc', 'bcd', 'cde']
arr.forEach(function(element, index) {
    console.log(element);
    console.log(index);
});
abc 0
bcd 1
cde 2
2.some 返回true/false,true时停止遍历
var arr = ['abc', 'bcd', 'cde']
var bool = arr.some(function(element,index) {
   console.log(index);
   return element === 'abc'
})
console.log(bool)
0 true
3.every 返回true和false
var arr = ['abc', 'bcd', 'cde']
var rets = arr.every(function (element,index) {
return element.length === 3
})
console.log(rets);
true
4.find
var user = [
   {name:'张三',age:15},
   {name:'张三',age:16},
   {name:'张三',age:12},
   {name:'张三',age:12},
   {name:'张三',age:11},
   {name:'张三',age:19}
]
var result = user.find(function (element,index) {
   return element.age >= 15
})
console.log(result);//{name: "张三", age: 15}
5.findIndex
var user = [
   {name:'张三',age:15},
   {name:'张三',age:16},
   {name:'张三',age:12},
   {name:'张三',age:12},
   {name:'张三',age:11},
   {name:'张三',age:19}
]
var results = user.findIndex(function (element,index) {
   return element.age >= 15
})
console.log(results); //0
6.filter找到所有符合条件的元素然后放到一个数组中 如果没有符合条件的那么返回空数组
var user = [
      {name:'张三',age:15},
      {name:'张三',age:16},
      {name:'张三',age:12},
      {name:'张三',age:12},
      {name:'张三',age:11},
      {name:'张三',age:19}
   ]
var sameAge = user.filter(function(element,index) {
      return element.age >= 15
});
console.log(sameAge); //返回3个对象
7.map对所有的元素进行操作 
//值类型
var arr2 = [1,2,3,4]
var After = arr2.map(function (element,index) {
   return ++element
})
console.log(After) // [2,3,4,5]
----------------------------------------------------
// 复杂数据类型
var user = [
      {name:'张三',age:15},
      {name:'张三',age:16},
      {name:'张三',age:12},
      {name:'张三',age:12},
      {name:'张三',age:11},
      {name:'张三',age:19}
   ]
var age = user.map(function (element,index) {
   element.age++
   return element
})
console.log(age);
console.log(user); //浅拷贝
8.includes
var  arr3 = [1,3,4,1,5]
var has = arr3.includes(3)
console.log(has) //true
```

考题15：闭包

```
function a() { 
	var i = 0; 
	function b() { alert(++i); } 
	return b;
}
var c = a();
c(); //1
c(); //2
c(); //3
特点: 
1.函数b嵌套在函数a内部;
2.函数a返回函数b;
当函数a的内部函数b被函数a外的一个变量引用的时候,就创建了一个闭包;
在a执行完并返回后,闭包使得Javascript的垃圾回收机制GC不会收回a所占用的资源,因为a的内部函数b的执行需要依赖a中的变量;
---------------------------------------
function a() {
    function b() {
        var bbb = 234;
        console.log(aaa); //124
    }
    var aaa = 124;
    return b; 
    //把b保存到外面去了,即a执行所返回的结果是函数b的引用,demo存完函数b之后a才算真正执行完
}
var glob = 100;
var demo = a();
demo(); //124 执行demo,相当于在外部执行函数b
* * *
闭包: 内部的函数被保存到了外部,一定形成闭包;
(内部函数一定会保存外部函数的劳动成果,保存完成之后并没有被执行,而是直接被扔到了外部,依旧保存着
外部函数已被销毁的AO);
闭包会导致原有作用域链不释放,造成内存泄露; ---> (内存越来越少)
闭包的作用:
1.实现公有变量;
	eg:函数累加器
2.可以做缓存(存储结构);
	eg:eater
3.可以实现封装,属性私有化;
	eg:Person()
4.模块化开发,防止污染全局变量;
* * *
函数累加器就是用闭包来实现的,不依赖于外部变量,实现函数的累加效果;
    function add() {
        var count = 0;
        function demo() {
            count ++;
            console.log(count);
        }
        return demo; //让demo保存add的劳动成果,所以demo外面定义的变量就能随便用了
    }
    var counter = add();
* * *
闭包
定义: 当内部函数被保存到外部时,将会生成闭包。闭包会导致原有作用域链不释放,造成内存泄露。
												  (过多占用内存资源叫内存泄露)
触发闭包:
	1.存在两个函数互相嵌套;
	2.把里面的函数保存到了外部,即保存到了全局;
	3.里面函数在外面执行的时候,一定能够调用的了原来包含他的函数里面的变量;
	4.里面的函数被保存到了外面函数的外部,即全局,就一定会形成闭包。里面的函数会保存外面函数的劳动成果;
```

考点16：DOM

```
通过js来操作网页中的标签;
img1.getAttribute("dat"); //获取
img1.setAttribute("dat","11"); //添加
img1.removeAttribute("dat"); //移走
screenX 屏幕的左上角
clientY 浏览器的左上角
e.preventDefault();//取消默认事件
节点类型: ---> 调用nodeType返回数值
a)元素节点   1
b)属性节点   2
c)文本节点   3
d)注释节点   8
e)document  9
<div></div>
var div = document.getElementsByTagName('div')[0];
var text = document.createTextNode('邓宝宝');
var span = document.createElement('span');
div.appendChild(text); 
div.appendChild(span);
var text1 = document.createTextNode('demo');
span.appendChild(text1); //appendChild类似于剪切的功能
* * *
请编写一段js脚本生成下面这段DOM结构,要求使用标准的DOM方法或属性;
提示 dom.className可以读写class
    <div class="example">
    	<p class="slogan">sxw</p>
    </div>
    <script>
    	var div = document.createElement('div');
    	var p = document.createElement('p');
    	div.setAttribute('class','example');
    	p.setAttribute('class','slogan');
    	var text = document.createTextNode('sxw');
    	p.appendChild(text);
    	div.appendChild(p);
    	document.body.appendChild(div);
* * *
查看滚动条滚动距离:
window.pageXOffset/pageYOffset ie8及以下不能使用
document.body.scrollLeft === documentElement.scrollLeft/scrollTop ie8以下这两个有效
* * *
查看视口的尺寸:
window.innerWidth/innerHeight (IE8及IE8以下不兼容)
document.documentElement.clientWidth/clientHeight //标准模式下,任意浏览器都兼容
document.body.clientWidth/clientHeight //适用于怪异模式下的浏览器
* * *
查看元素的几何尺寸 (了解即可)
domEle.getBoundingClientRect();
兼容性很好,该方法返回一个对象,对象里面有left,top,right,bottom等属性,left和top代表该元素左上角的X和Y坐标,right和bottom代表元素右下角的X和Y坐标,height和width属性老版本IE并未实现,返回的结果并不是实时的;
```

考点17：定时器

```
setInterval(); 非常不准,循环执行
setTimeout(); 延迟执行,执行一次
```

考点18：执行期上下文

```
function a() {
    function b() {
        function c() {
            
        }
        c();
    }
    b();
}
a();
----------------------------------
            作用域        执行期上下文
a defined a.[[scope]] --> 0 : GO
a doing   a.[[scope]] --> 0 : aAO
						  1 : GO

b defined b.[[scope]] --> 0 : aAO
						  1 : GO
b doing   b.[[scope]] --> 0 : bAO
						  1 : aAO
						  2 : GO

c defined c.[[scope]] --> 0 : bAO
						  1 : aAO
						  2 : GO
c doing   c.[[scope]] --> 0 : cAO
						  1 : bAO
						  2 : aAO
						  3 : GO
```



考点？？：

```
<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8">
      <title>demo小狗运动</title>
      <style>
         /* 5.设置父级高度100% */
         html{
            height: 100%;
         }
         /* 4.为解决body高度为0,设置高度100%,往上继承html的高度,并且清除自带的margin值 */
         body{
            margin: 0;
            height: 100%;
         }
         /* 2.设置图片位置和大小 */
         img{
            position: fixed;
            width: 90px;
            height: 90px;
         }
      </style>
   </head>
   <body>
      <!-- 1.添加图片 -->
      <img src="./dog.jpg" alt="" id="dog">
      <script>
         // 3.打印查看窗口的宽度和高度,发现宽度是好的,但是高度为0
         console.log(document.body.offsetWidth);
         console.log(document.body.offsetHeight); //打印出来body的高度为0

         // 6.封装对象函数
         var Dog = function(el) {// el表示标签对象
            // 需要提取到的数值: 
            //    1.对象距离窗口左侧的距离 x;
            //    2.对象距离窗口上侧的距离 y;
            //    3.对象自身宽度w和高度h; this.dom.offsetWidth / this.dom.offsetHeight
            //    4.获取完整浏览器窗口的宽和高; document.body.offsetWidth / document.body.offsetHeight

            this.dom = el; //el标签对象赋给this.dom,便于下面操作            
            this.x = 0; //对象距离窗口左侧的x距离
            this.y = 0; //对象距离窗口上侧的y距离
            this.w = this.dom.offsetWidth; //el对象整体宽度
            this.h = this.dom.offsetHeight; //el对象整体高度
            this.maxX = document.body.offsetWidth; //获取整个body的宽
            this.maxY = document.body.offsetHeight; //获取整个body的高
            this.speed = 50; //定义运动速度

            // 6.1 封装对象属性
            this.init = function() {
               var el = this.dom; //this.dom赋给el
               this.x = el.offsetLeft; //对象离左边距离
               this.y = el.offsetTop; //对象离上面距离
            }

            // 6.2 向右移
            this.moveRight = function() {
               if(this.x + this.speed + this.w < this.maxX) { //对象距离窗口左侧的x距离 + 自身宽度 + 运动速度 < 整个body的宽度
                  this.x += this.speed; //对象距离窗口左侧的x距离 + 运动的速度距离
                  this.dom.style.left = this.x + "px"; //实现定位
               }
            }

            // 6.3 向左移
            this.moveLeft = function() {
               if(this.x - this.speed >= 0) {
                  this.x -= this.speed;
                  this.dom.style.left = this.x + "px";
               }
            }

            // 6.4 向上移
            this.moveUp = function() {
               if(this.y - this.speed >= 0) {
                  this.y -= this.speed;
                  this.dom.style.top = this.y + "px";
               }
            }
            
            // 6.5 向下移
            this.moveDown = function(){
               if(this.y + this.speed + this.h < this.maxY) {
                  this.y += this.speed;
                  this.dom.style.top = this.y + "px";
               }
            }
         }

         // 7.创建一只狗
         var dog = new Dog(document.getElementById("dog"));
         document.addEventListener("keydown", function(evt) {
            var key = evt.keyCode;
            switch(key) {
               case 37: //left
               case 65: //a
                  dog.moveLeft();
                  break;
               case 38: //up
               case 87: //w
                  dog.moveUp();
                  break;
               case 39: //right
               case 68: //d
                  dog.moveRight();
                  break;
               case 40: //down
               case 83: //s
                  dog.moveDown();
                  break;
            }
         })
      </script>
   </body>
</html>
```

```
选项卡功能:
.active{
    background-color: pink;
}
.content{
	display: none;
    width: 100px;
    height: 100px;
    border: 1px solid black;
}
<div class="wrapper">
	<button class="active">1</button>
	<button>2</button>
	<button>3</button>
	<div class="content" style="display: block">a</div>
	<div class="content">b</div>
	<div class="content">c</div>
</div>
<script>
	var btn = document.getElementsByTagName('button'),
		div = document.getElementsByClassName('content'),
		len = btn.length;
	for(var i = 0;i < len;i ++) { //遍历出每一个button
            (function(n) { //立即执行函数
                btn[n].onclick = function() { //给遍历出的button绑定点击事件
                for(var j = 0;j < btn.length;j ++) { //初始化
                    btn[j].className = "";  
                    div[j].style.display = "none";
                }
                this.className = "active"; //当前button变效果
                div[n].style.display = "block"; //对应的改变遍历出的div
            }
		}(i))
	}
</script>
```

```
让滚动条滚动:
	window上有三个方法
	scrollTo()效果不累加,   scrollBy()效果累加;
	三个方法功能类似,用法是将x,y坐标传入。即实现让滚动轮滚动到当前位置。
	区别:scrollBy()会在之前的数据基础之上做累加;
	eg:利用scrollBy()快速阅读的功能;
自动阅读功能:
<div style="width:100px;height:100px;background-color:orange;color:#fff;font-size: 40px;font-weight:bold;text-align:center;line-height:100px;position:fixed;bottom:200px;right:50px;border-radius:50%;opacity:0.5">start</div>
<div style="width:100px;height:100px;background-color:orange;color:#0f0;font-size: 40px;font-weight:bold;text-align:center;line-height:100px;position:fixed;bottom:50px;right:50px;border-radius:50%;opacity:0.5">stop</div>
var start = document.getElementsByTagName('div')[0];
var stop = document.getElmentsByTagName('div')[1];
var timer = 0;
var key = true; //加锁性思维,解决产生多个定时器清除不了的问题
start.onclick = function() {
    if(key) {
            timer = setInterval(function() {
                window.scrollBy(0, 10);
            },100);
            key = false;
        }
}
stop.onclick = function() {
    clearInterval(timer);
    key = true;
}
```

```
方块运动:
<div style="width: 100px;height: 100px;background-color:red;position:absolute;left:0;top:0;"></div>
function getStyle(elem, prop) {
    if(window.getComputedStyle) {
        return window.getComputedStyle(elem, null)[prop];
    }else {
        return elem.currentStyle[prop];
    }
}
var div = document.getElementsByTagName('div')[0];
var speed = 3;
var timer = setInterval(function() {
	speed += speed/7;
    div.style.left = parseInt(getStyle(div, 'left')) + speed + 'px';
    if(parseInt(div.style.left) > 500) {
        clearInterval(timer);
    }
}, 10);
```

```
1.HTML顶部DOCTYPE有什么作用？有什么影响？
DOCTYPE是document type的简写,它并不是HTML标签,也没有结束标签,是一种标记语言的文档类型声明,即告诉浏览器当前HTML是用什么版本编写的;在所有HTML文档中规定DOCTYPE是非常重要的,这样浏览器就能了解预期的文档类型,告诉浏览器要通过哪一种规范(DTD)解析文档(如:HTML或XHTML规范);DOCTYPE会影响代码验证,并决定了浏览器最终如何显示你的Web文档。
```

```
5.父元素为一个div,宽高不固定,子元素是一个块元素,宽高已知,如何实现子元素在父元素内水平,垂直都居中?
方法1: 相对定位 (操作son)
    .father{
        width: 600px;
        height: 600px; //宽高不固定
        border: 1px solid yellow;
    }
    .son{
        width: 160px;
        height: 160px;
        border: 1px solid blue;
     ***margin: 0 auto; //左右居中
     ***position: relative;
     ***top: 50%;
     ***margin-top: -80px; //负的高度的一半,上下居中
    }
    <div class="father">
        <div class="son"></div>
    </div>
方法2: Flex弹性布局 (操作father)
    .father{
        width: 600px;
        height: 600px; //宽高不固定
        border: 1px solid yellow;
     ***display: flex;
     ***align-items: center; //垂直方向居中
     ***justify-content: center; //水平方向居中
    }
    .son{
        width: 160px;
        height: 160px;
        border: 1px solid blue;
    }
    <div class="father">
        <div class="son"></div>
    </div>
方法3: transform属性 (操作son)
    .father{
        width: 600px;
        height: 600px; //宽高不固定
        border: 1px solid yellow;
    }
    .son{
        width: 160px;
        height: 160px;
        border: 1px solid blue;
     ***position: relative;
     ***top: 50%;
     ***left: 50%;
     ***transform: translate(-50%, -50%); //改变中心点,向左向上移动自身宽高的一半
    }
    <div class="father">
        <div class="son"></div>
    </div>
```

```
7.写一个函数,实现n的阶乘;
//使用递归的思想解决问题
//使用递归要注意两点: 1.找规律; 2.找出口;
//规律: n! = n * (n - 1)!
//出口: 0! = 1
    function mul(n) {
        if(n == 1 || n == 0) {
            return 1; //出口
        }
        return n * mul(n - 1); //规律,递归就是return公式实现循环计算;
    };
```

```
function test(a,b) {
    console.log(a); //1
    c = 0;
    var c;
    a = 3;
    b = 2;
    console.log(b); //2
    function b() {}
    function d() {}
    console.log(b); //2
    console.log(d); //function d() {}
}
test(1);
---------------------------
预编译四部曲:
1.创建AO对象(执行期上下文);
    AO{

    }
2.找形参和变量声明;
(AO找的是局部范围里的,GO找的是全局范围里的),将形参和变量名作为AO属性名,值为undefined;
    AO{
        a : undefined,
        b : undefined,
    }
3.将实参值和形参相统一;
    AO{
        a : 1,
        b : undefined,
    }
4.在函数体里面找函数声明,值赋予函数体;
    AO{
        a : function a() {},
        b : undefined,
        d : function d() {},
    }
* * *
function test(a,b) {
    console.log(a); //function a() {}
    console.log(b); //undefined
    var b = 234;
    console.log(b); //234
    a = 123;
    console.log(a); //123
    function a() {}
    var a;
    var b = function() {}
    console.log(a); //123
    console.log(b); //function() {}
}
test(1);
1.函数声明整体提升: 不管是在函数声明之前调用函数还是在函数声明之后调用函数,其本质都是在函数声明之后
调用函数,他始终会把函数声明提升到逻辑的最前面;
    console.log(a); //function a() {}
    var a = 123;
    function a() {};
2.变量 声明提升: 只是将定义变量部分提升,赋值部分不提升;
    console.log(a); //undefined
    var a = 123;
3.GO全局状态下,预解析没有第三步,并且第一步是生成一个GO对象; GO === window
    var a = 123;
    function a() {};
    console.log(a); //123
4.
function test() {
    var a = b = 123;
    console.log(window.a); //undefined GO里面没有a定义
    console.log(window.b); //123
    console.log(a); //123
    console.log(b); //123 AO里面没有的话往上找GO
}
test();
----------
GO{
    b : undefined,123
}
AO{
    a : undefined,123
}
5.
console.log(test); //function test() {} 和下面打印出来的fun指的不一样
function test(test) {
    console.log(test); //function test() {}
    var test = 234;
    console.log(test); //234
    function test() {}
}
test(1);
----------
GO{
    test : function test() {} 
}
AO{
    test ; undefined,1,function test() {},234
}
6.
var global = 100;
function fn() {
    console.log(global); //100 先去AO里面找,AO里面没有,再去GO上找
}
fn();
---------------
GO{
    global : undefined,100
    fn : function fn() {},
}
AO{
    
}
7.
global = 100;
function fn() {
    console.log(global); //undefined
    global = 200; //可以改变AO里对应属性的值
    console.log(global); //200
    var global = 300;
}
fn();
console.log(global); //100
var global;
--------------
GO{
    global : undefined,100
    fn : function fn() {}
}
AO{
    global : undefined,200,300
}
8.
function test() {
    console.log(b); //undefined
    if(a) { //a = undefined,所以b = 100不执行
        var b = 100; //AO 提升
    }
    console.log(b); //undefined
    c = 234;
    console.log(c); //234
}
var a;
test();
console.log(a); //undefined
a = 10;
console.log(a); //10
console.log(c); //234
-------------------------
GO{
    a : undefined,10
    c : 234,
    test : function test() {}
}
AO{
	b : undefined
}
9.
function bar() {
    return foo; //function foo() {} 在完成预编译第四步后进来走程序直接return,必然返回function
    foo = 10;
    function foo() {}
    var foo = 11;
}
console.log(bar());
10.
console.log(bar());
function bar() {
	console.log(foo); //function foo() {}
    foo = 10;
    console.log(foo); //10
    function foo() {}
    var foo = 11;
    return foo; //11 
}
11.
a = 100;
function demo(e) {
    function e() {}
    arguments[0] = 2; //实参列表,传参与传参的形参位相映射即 e = 2
    console.log(e); //2
    if(a) { //a = undefined,所以if里面的语句不执行
        var b = 123;
        function c() {
        
        }
    }
    var c;
    a = 10;
    var a;
    console.log(b); //undefined
    f = 123;
    console.log(c); //理想状态下是function,因为规定里刚刚新添if语句里面不能定义函数
    console,log(a); //10
}
var a;
demo(1);
console.log(a); //100
console.log(f); //123
-------------
GO{
    a : undefined,100
    demo : function demo() {}
    f : 123
}
AO{
    e : undefined,1,function e() {},2
    b : undefined
    c : undefined,function c() {}
    a : undefined,10
}
```

```
14.
只有一种情况使用没有定义的变量是不报错的,就是typeof(a) ---> 返回的是字符串类型的undefined;
typeof(null) ---> "object" 
(null本来是原始值,但在typeof这里被认为是给对象占位的,所以认为null是个对象)
```

```
typeof([]); --> object
typeof({}); --> object
区分数组与对象的三种方法:
1.
[].constructor --> array;
var obj = function() {}	;
obj.constructor --> Object;
2.
[] instanceof Array --> true;
var obj = {};
obj instanceof Array ---> false;
3.
Object.prototype.toString.call([]); --> [object Array];
Object.prototype.toString.call({}); --> [object object];
```

```
null == undefined
```

```
经典this指向:
var name = "222";
var a = {
    name : "111",
    say : function() {
        console.log(this.name);
    }
}
var fun = a.say;
fun(); //fun在全局范围下执行,也没人去调用他,所以打印222
a.say(); //111
```

```
//会打印出9次x
var f7 = function() {
    var i = 1; j = 1;
    while(i < 10) {
        while(j < 10) {
            j = j + 1;
            docunemnt.write("x");
        }
        i = i + 1;
    }
};

//会打印出81次x
var f7 = function() {
    var i = 1; var j;
    while(i < 10) {
        j = 1; //不要在循环体内创建变量
        while(j < 10) {
            j = j + 1;
            docunemnt.write("x");
        }
        i = i + 1;
    }
};
```

```
加号左右两边有字符串的,转换为字符串处理,没有字符串的按数字处理;
除加号外其余都是转成数字处理;
1 - "A" = NaN
++a(一元) > a+b(二元); //一元运算符优先级高于二元
JavaScript中的数据类型包括: Number String Boolean Object undefined Null
	基本类型: Number String Boolean undefined Null
	引用类型: Object
两种类型的区别:
	储存方式的区别: (基本类型以栈的方式存储,引用类型以堆的方式存储);
	基本类型是没有属性和方法的,引用类型有;
为啥String类型有那么多的方法呢？ 
	其实质是创建String类型的实例 --> 在实例上调用方法 --> 销毁实例
声明一个基本类型并复制一份:
	var a = 3;
	var b = a;
	首先开辟一个名叫a的数字类型的空间,值为3;
	然后开辟一个名为b的数字类型空间,值为a;
	此时两者是独立的空间,b复制了a的值开辟了自己独立的栈空间,当改变其中一个值的时候,另一个值不变;
	var obj1 = new Object();
	var obj2 = obj1;
	obj2复制了obj的实例对象,建立的对象在栈中存储了一个指针,指向堆内存中该对象的内存地址;
	通过复制一个对象,指针指向的内存地址是不变的,当改变其中一个值的时候另一个也会改变;
typeof(null); --> object
typeof(undefined); --> undefined
系统自带的对象: 数组 函数
switch(1) {
    case 1:
    	console.log("sxw");
    	break;
    case 2:
    	break;
    default: //默认值
    	break;
}
---
var a = 1;
while(a <= 10) {
    console.log(a + "我是舒小伟");
    a += 1;
}
---
var a = 1;
while(true) {
    console.log(a + "好好学习,天天向上");
    a += 1;
    if(a <= 10) {
        continue;
    }
    break;
}
---
var a = 1;
do{
    console.log(a + "我是舒小伟");
    a += 1;
}while(a <= 10);
---
function slogan(num,time) {
    for(var a = 1;a <= num;a ++) {
        console.log(time + "点" + a + "好好学习,天天向上");
    }
}
slogan(10, 12);

预解析: 浏览器获得js文件的时候,不是立刻去执行代码,而是全篇快速扫描一遍,把变量预先解析;
把变量的声明提前:
    var x;
    function add();
--------------------------------------
闭包: 解决变量的私有化问题;
计时器:
function add() {
    var counter = 0;
    counter ++;
    console.log(counter);
}
add(); //1
add(); //1
--------------------
var counter = 0;
function add() {
    counter ++;
    console.log(counter);
}
add(); //1
add(); //2
--------------------------
function add() {
    var counter = 0;
    plus = function() {
        counter ++;
        console.log(counter);
    }
}
add();
plus();
plus();
------------------
简化:
function add() {
    var counter = 0;
    return function() {
        counter ++;
        console.log(counter);
    };
};
var plus = add();
plus(); //1
plus(); //2
console.log(counter); //访问不到,报错,即counter只能在函数作用域中访问到,不会污染全局变量;
--------------------------------------
闭包的传统写法:
var plus = (function() {
    var counter = 0;
    return function() {
        counter ++;
        console.log(counter);
    }
})();
plus(); //1
plus(); //2
---------------------------------------
删除对象上的属性: delete person.name;
遍历: 
	对象:
    var obj = {a:"123",b:"456"};
    for(var i in obj) {
        console.log(i); //a  b
        console.log(obj[i]); //123  456
    }
    数组:
    var arr = ['a','b','c'];
    for(var i in arr) {
        console.log(i); //0  1  2
        console.log(arr[i]); //a  b  c
    }

构造函数方式:
function Person(Name,Sex,Age) {
    this.name = Name;
    this.sex = Sex;
    this.age = Age;
    this.slogan = function() {
        console.log(this.name);
    }
}
var person1 = new Person("sxw","male",18);

页面 DOM
底层 BOM

浏览器:多线程
	1.js引擎
	2.UI渲染
	3.事件线程
	4.发起请求的线程
	5.定时器的线程

js单线程 

js时间线:
1.创建Document对象,开始解析web页面,解析HTML元素和他们的文本内容后添加Element对象和Text节点到文档
中,这个阶段document.readyState = 'loading',(生成document对象,document状态位变为loading);
2.遇到link外部css,创建线程加载,并继续解析文档;
3.遇到script外部js,并且没有设置async、defer,浏览器加载并阻塞,等待js加载完成并执行该脚本,然后继续;
4.遇到script外部js,并且设置有async、defer,浏览器创建线程加载,并继续解析文档;
	对于async属性的脚本,脚本加载完成后立即执行,异步禁止使用document.write();
	document.write();特别特殊,他是把里面的东西当成HTML文档输出到页面里去,但是有一点就是,有的时候
当你整个文档全部都解析的差不多的时候再用document.write()的话会把你之前所有的文档流都清空,用它里面
的文档流代替;
	例: 整个页面只显示a,这里的document.write();有消除文档流的功能,连script都消除了;
		<div style="height:100px;width:100px;background-color:red;"></div>
	    <script type="text/javascript">
	        window.onload = function(){
	            document.write('a');
	        }
	    </script>
5.遇到img等,先正常解析dom结构,然后浏览器异步加载src,并继续解析文档;
6.当文档解析完成,document.readyState = 'interactive';
	先解析完再加载完,然后状态位变为interactive(活跃);
	查看状态位的转换：
    	console.log(document.readyState);
        document.onreadystatechange = function(){
            console.log(document.readyState);
        }
7.文档解析完成后,所有设置有defer的脚本会按照顺序执行,注意与async的不同,但同样禁止使用document.write();
8.document对象触发DOMContentLoaded事件,这也标志着程序执行从同步脚本执行阶段,转化为事件驱动阶段;
9.当所有async脚本加载完执行,img加载完成后,document.readyState='complete',window对象触发load事件;
10.从此,以异步响应方式处理用户输入,网络事件等;
总结就是三个点: 先生成document对象,代表js可以运行了;再就是文档解析完了,最后文档加载完并且执行完;

延迟加载 
async和defer一样,都不会阻塞其他资源下载,所以不会影响页面的加载,唯一的缺点是不能控制加载的顺序;
	1.defer属性
		脚本会被延迟到整个页面都解析完毕之后再执行,立即下载但延迟执行,适用外部脚本文件;
	2.async属性
		不让页面等待脚本下载和执行,从而异步加载页面其他内容;

js三种弹窗:
	1.alert(); 一般用于提示或者警告信息的展示;
	2.confirm(option); 用户点击确定或取消按钮,弹窗会返回一个布尔值,由此可以判断用户的操作;
					console.log( confirm("你开心吗?") ) 根据用户操作会返回true / false
	3.prompt(); 第一个参数是输入框要求,第二个参数输入框内默认值,培养用户懒习惯;
					prompt('请输入你的幸运数字','3'); 
	
浏览器的前进/后退:
	history.back(); 
	history.forward(); 
	history.go(-2); 
浏览器的信息(版本/厂家): window.navigator
获取浏览器的分辨率: window.screen
	
计时器:
(循环执行)
	var sil = setInterval(函数名,时间);
	clearInterval(sil);
(一次执行)
	var sil = setTimeout(函数名,时间);
	clearTimeout(sil);
var num = 0;
var timer1 = setInterval(function() { //每隔1秒执行一下timer1
   console.log(num ++)
},1000)
var timer2 = setTimeout(function() { //3秒后执行函数
   console.log(num ++)
}, 3000)
    
数据结构:
	线性: 单链表 循环链表 队列 栈 数组
	树形: 二叉图 平衡图 红黑树
	网状: 有向图 无向图 寻路算法 A*算法

创建一个P标签: var p = document.createElement("p");
创建一个文本节点: var txt = document.creatTextNode("txt");
	p.appendChild("txt"); 

var div2 = document.getElementById("div2");
div2.parentNode.removeChild(div2); //自己把自己干掉

var img1 = document.getElementById("img1");
img1.style.height= "100px"; //css样式修改
img1.getAttribute("id"); //获取属性
img1.setAttribute("class","sxw"); //设置属性
img1.removeAttribute("class"); //移除属性
```

```
HTML&CSS
1.什么是HTML5? 
(讲述H5推出的设计目标,现在市场的使用情况,以及浏览器支持的情况)
	HTML5的设计目的是为了在移动设备上支持多媒体;
	新的语法特征被引进以支持这一点,如video,audio,canvas...;
	H5还引进了新的功能,可以真正改变用户与文档的交互方式,包括:
		a.新的解析规则增强了灵活性;
		b.新属性;
		c.淘汰过时的属性;
		d.一个HTML5文档到另一文档间的拖放功能;

2.HTML5中什么是不同的新表单元素类型? 
(本地验证表单需要在外面添加form标签包起来,才能查看效果)
color date datetime-local email time url range telephone number search

3.HTML5的页面结构同HTML4或者更前的HTML有什么区别?
	一个典型的web页面包含头部,导航,中心区域,侧边栏,尾部;
	如果我们想在HTML4的HTML区域中呈现这些内容,要使用DIV标签;
	但在H5中通过为这些区域创建元素名称使它们更加清晰,也使得你的HTML更加可读;
	以下是形成页面结构的H5元素的更多细节:
    	<header>: 头部区域
    	<footer>: 尾部区域
    	<nav>: 导航区域
    	<article>: 自己包含的内容
    	<section>: 使用内部article去定义区域或者把分组内容放到该区域里
    	<aside>: 侧边栏内容

4.哪些浏览器支持HTML5?
几乎所有的高版本浏览器 Safari Chrome Firefox Opera IE8以上 都支持H5;

5.为什么HTML5里面我们不需要DTD(Document Type Definition文档类型定义)?
HTML5没有使用SGML或者XHTML,他是一个全新的东西,因此你不需要参考DTD;
对于H5你仅需放置下面的文档类型代码告诉浏览器识别这是H5文档即可;

6.HTML5的离线储存?
localStorage 长期存储数据,浏览器关闭后数据不丢失;
sessionStorage 数据在浏览器关闭后自动删除;

7.浏览器是怎么对H5的离线储存资源进行管理和加载的呢?
在线的情况下,浏览器发现html头部有manifest属性,它会请求manifest文件;
如果是第一次访问app,那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储;
如果已经访问过app并且资源已经离线存储了,那么浏览器就会使用离线的资源加载页面;
然后浏览器会对比新的manifest文件与旧的manifest文件,如果文件没有发生改变,就不做任何操作;
如果文件改变了,那么就会重新下载文件中的资源并进行离线存储;
离线的情况下,浏览器就直接使用离线存储的资源;

8.请描述一下cookies,sessionStorage和localStorage的区别?
1) cookie在浏览器和服务器间来回传递,sessionStorage和localStorage不会; 
2) sessionStorage和localStorage的存储空间更大; 
3) sessionStorage和localStorage有更多丰富易用的接口;
4) sessionStorage和localStorage有各自独立的存储空间;

9.页面可见性(Page Visibility)API可以有哪些用途?
在页面被切换到其他后台进程时,自动暂停音乐或视频的播放;

10.H5的form如何关闭自动完成功能?
给不想要提示的input设置 autocomplete=off 即可;

JavaScript:
1.获取一堆name名相同的div,点击弹出显示第几个div; 
方法一:
var div = document.getElementsByTagName("div");
for(var i = 0;i < div.length;i ++) {
	div[i].index = i + 1; 
	div[i].onclick = function() { 
		console.log(this.index);  //关键是通过this进行访问
	} 
}
方法二:
var div = document.getElementsByTagName("div");
for(var i = 0;i < div.length;i ++) { 
	(function(j) { 
		div[j].onclick = function() { 
			console(j+1); 
		} 
	})(i); 
}

2.abcdefgsdds 获取字面最多的字母:
	var str = 'abcdefgsdds';
	var obj = {};
	var letter;
	for(var i = 0;i < str.length;i ++) {
	   letter = str[i];
	   if( !obj[letter] ) {
	      obj[letter] = 1;
	   }else {
	      obj[letter] ++;
	   }
	}
	console.log(obj);
	var maxKey;
	var maxNum = 0;
	for(key in obj) {
	   if(maxNum < obj[key]) {
	      maxNum = obj[key];
	      maxkey = key;
	   }
	}
	console.log("字母:"+ maxKey + "次数:" + maxNum)

3.截取 'ghi'   
"abcdefghi".substring(6); 

4.截取 'asd'
console.log("asdjhklzxc".substring(0,3));
console.log("asdjhklzxc".substring(3,-1));
总结: 使用substring()截取的时候,当参数是1个时,包括;当参数是2个的时候,不包括;你知道什么叫包括?

5.翻转字符串:
var arr = 'abc';
var newArr = arr.split('').reverse().join(''); //拆分反转拼接
console.log(newArr)

6.删除数组中第一个元素;
arr.shift();

7.数组去重:
思路: 将循环出来的旧数组元素一个个验证添加到新数组中！
   var arr = [1,1,2,2,3,4,5];
   var newArr = []; 
   for(var i = 0;i < arr.length;i ++) {
      // 站在newArr角度考略
      // newArr.indexOf( 遍历出arr的每一项作为子项 ), newArr 中包不包含啊？
      if( newArr.indexOf(arr[i]) == -1) {
         newArr.push(arr[i]);
      }
   }
   console.log(newArr)

8.js中有几种数据类型分别是哪几种;
(6种) Number,String,Boolean,Object,Null,Undefined 

9.说一下拖拽的原理?
原生js实现拖拽的两种方法:
1.mousedown,mousemove,mouseup 拖着目标元素在页面任意位置;
注意: 
	a.要设置物体拖拽,必须使用这3个事件,并且这3个事件的使用顺序不能颠倒;
	b.一定要绝对定位,脱离文档流,才可以移动;
	c.mousedown绑定拖拽的元素,移动和鼠标松开是对document的绑定;
实现思路:
在鼠标按下,移动,抬起过程中鼠标在div部分位置是不变的;
其实很简单,在鼠标按下时判断鼠标在div内部距离距离左侧,上部距离; (注意: 这个距离时不会变化的) -- A
B = 在鼠标移动过程中判断鼠标距离浏览器左侧距离 - A
B就是新元素的新位置;
这里要注意处理两个边界问题: 即div向左(向上)移除浏览器窗口部分,需要判断强制置为0;还有div
向右(向下)移除浏览器窗口部分,需要判断强制置为浏览器总宽(高)度 - div自身宽(高)
	<style>
      .box{
         position: absolute;
         width: 100px;
         height: 100px;
         background: red;
         cursor: move;
      }
   </style>
   <div class="box" id="drag"></div>
   window.onload = function() {
         var drag = document.getElementById('drag');
         // 点击物体时,用drag对象
         // 物体移动move 和 鼠标抬起up 是全局区域
         drag.onmousedown = function(event) {
            var event = event || window.event; // 兼容IE
            // event.clientX 鼠标距离浏览器左侧距离
            // drag.offsetLeft div距离浏览器左侧距离
            var diffX = event.clientX - drag.offsetLeft; // 鼠标距div左侧距离
            var diffY = event.clientY - drag.offsetTop; // 鼠标距div上部距离
            document.onmousemove = function(event) {
               // 鼠标按下到移动到释放之间,鼠标在div中的位置是不会发生变化的
               var event = event || window.event;
               var moveX = event.clientX - diffX;
               var moveY = event.clientY - diffY;

               // a.边界状态的判断
               // 第一个if判断div部分向左移出,强制归为 0
               // 第二个if判断div部分向右移出,强制归为 window.innerWidth - drag.offsetWidth
               if(moveX < 0) {
                  moveX = 0
               }else if(moveX > window.innerWidth - drag.offsetWidth) {
                  moveX = window.innerWidth - drag.offsetWidth
               }

               // b.边界状态的判断
               // 第一个if判断div部分向上移出,强制归为 0
               // 第二个if判断div部分向下移出,强制归为 window.innerHeight - drag.offsetHeight
               if(moveY < 0) {
                  moveY = 0
               }else if(moveY > window.innerHeight - drag.offsetHeight) {
                  moveY = window.innerHeight - drag.offsetHeight
               }

               drag.style.left = moveX + 'px';
               drag.style.top = moveY + 'px'
            }

            // 鼠标释放置空
            document.onmouseup = function(event) {
               this.onmousemove = null;
               this.onmouseup = null;
            }
         }
      }
   </script>

2.H5元素拖拽drag与拖放drop
元素拖拽:
   浏览器默认允许我们拖拽图像,文本以及链接;
   让其它元素被拖动也是可以实现的,只需要在元素标签上添加一个属性 draggable="true";
   <div class="box1" draggable="true" id="source"></div>
拖拽事件:
   拖拽事件应该分为两类: 一类是被拖拽元素触发的事件,另一类是拖放目标元素触发的事件;
   <div class="box1" draggable="true" id="source"></div>
   <br>
   <div class="box2" id="target"></div>
拖拽元素:
拖拽元素的时候,被拖拽元素会触发以下事件: 
   dragstart 当鼠标点中元素并且开始移动时,就会触发dragstart事件（类似mousedown） 
   drag 拖拽过程中会持续不断地触发drag事件（类似mousemove） 
   dragend 松开鼠标取消拖拽时就会触发dragend事件（类似mouseup）
      source.ondragstart = function(event){
         var e = event || window.event
         console.log('开始拖拽');
      }
      source.ondrag = function(){
            console.log('拖拽中');
      }
      source.ondragend = function(){
            console.log('拖拽结束')
      }
目标元素:
当拖拽的元素拖到目标元素上时,目标元素会触发以下事件:  
   dragenter 拖拽元素到目标上,就会触发dragenter事件（类比mouseover）
   dragover 当拖动元素在目标元素中,就会持续触发dragover事件 
   dragleave 离开目标元素,触发dragleave事件（类比mouseout）
   drop 若拖放元素到了目标元素中（在目标元素中松开鼠标）,就会触发drop事件而不会触发dragleave事件
      target.ondragenter = function(){
         console.log('进入目标元素')
      }
      target.ondragover = function(event){
            var event = event || window.event;
            console.log('在目标元素中拖拽');
            event.preventDefault()
      }
      target.ondragleave = function(){
            console.log('拖放离开目标元素')
      }
      target.ondrop = function(event){
            console.log('拖放');
            var e = event || window.event;
      }
注意: 元素默认是不能够拖放,只要我们在目标元素的dragover事件中取消默认事件就可以解决问题;
数据交换:
数据交换的对象就是事件对象的属性dataTransfer:
dataTransfer的两个核心方法是setData()和getData();
   setData()用于设置数据,getData()用语接收数据;
举个拖放的例子:
   <div class="box1" draggable="true" id="source"></div>
   <br>
   <div class="box2" id="target"></div>
   .box1{
      width: 100px;
      height: 100px;
      background: salmon;
   }
   .box2{
         width: 300px;
         height: 300px;
         border: 1px solid black;
   }
   window.onload = function(){
      var source = document.getElementById('source');
      var target = document.getElementById('target');
      source.ondragstart = function(event){
         var e = event || window.event
         console.log('开始拖拽');
         e.dataTransfer.setData('text',e.target.id);
      }
         target.ondragenter = function(){
            console.log('进入目标元素')
         }
         target.ondragover = function(event){
            var event = event || window.event;
            console.log('在目标元素中拖拽');
            event.preventDefault()
         }
         target.ondragleave = function(){
            console.log('拖放离开目标元素')
         }
         target.ondrop = function(event){
            console.log('拖放');
            var e = event || window.event
            var data = e.dataTransfer.getData('text');
            e.target.appendChild(document.getElementById(data));
         }
   }
拖拽设置:
在dataTransfer中还有两个重要的属性:
dropEffect 属性值为字符串,表示被拖动元素可以执行哪一种放置行为;
           要使用这个属性,必须在dragenter事件处理函数中设置;
   none 不能把元素拖放至此（除文本框外全部元素的默认值）
   move 移动到目标
   copy 复制到目标
   link 目标打开拖动元素（拖动元素必须是链接并有URL）
effectAllowed属性值也是字符串,表示允许拖动元素哪种dropEffect,要使用这个属性;
             必须在dragst事件处理函数中设置;
   uninitialized 没有设置任何拖放行为
   none 不能由任何行为
   copy 仅允许dropEffect值为copy
   link 仅允许dropEffect值为link
   move 仅允许dropEffect值为move
   copyLink 允许dropEffect值为copy和link
   copyMove 允许dropEffect值为copy和move
   linkMove 允许dropEffect值为link和move
   all 允许任意dropEffect

10.需求: 用js动态创建一个a标签,需要在body中显示,并且点击在新窗口打开;
	var linkTo = document.createElement('a');
	linkTo.innerHTML = '百度一下,你就知道';
	linkTo.href = "http://www.baidu.com";
	linkTo.target = '_black';
	document.body.appendChild(linkTo);

11.substring
xx.substring(0,2); //从字符串索引第0位开始截取,往后截2位(不包含第二位),返回一个新字符串;
xx.substring(2); //从字符串索引第2位开始往后截取全部(包含第2位),返回一个新字符串;
	var str = 'hello';
	console.log( str.substring(0,3) ); // hel
	console.log( str.substring(1,2) ); // e
	console.log( str.substring(3) ); // lo

12.indexOf 可以用来判断字符串之间是否有包含的关系
a.单词字符串之间的包含:
	var str = 'water';
	console.log( str.indexOf('w') ); // 0
	console.log( str.indexOf('b') ); // -1
	console.log( str.indexOf('wat') ); // 0
	console.log( str.indexOf('wbt') ); // -1
b.数字字符串之间的包含:
indexOf 会做简单的类型转换: 把数字转换成字符串再执行;
	var str = '2016';
	console.log( str.indexOf(2) ); // 0 
	console.log( str.indexOf(8) ) // -1
	console.log( str.indexOf(201) ) // 0
	console.log( str.indexOf(202) ) // -1
c.数组中的包含:
	var arr = ['apple','2019','sxw']
	console.log( arr.indexOf('apple') ); // 0
	console.log( arr.indexOf( 2019 ) ); // -1 数组中数字不会进行隐式转换
	console.log( arr.indexOf('a') ); // -1
	
13.列举不少于6条 IE 与 FF 脚本兼容性问题;
FF(遵循W3c标准)
1)window.event: 表示当前的事件对象,IE有这个对象;FF没有,FF通过给事件处理函数传递事件对象;
2)获取事件源: IE用srcElement获取事件源,而FF用target获取事件源;
3)添加,去除事件:
	IE: element.attachEvent(“onclick”, function) 
	    element.detachEvent(“onclick”, function)
	FF: element.addEventListener(“click”, function, true) 
	    element.removeEventListener(“click”, function, true)
4)获取标签的自定义属性:
	IE: div1.value或div1[“value”]
	FF: div1.getAttribute(“value”)
5)document.getElementByName()和document.all[name]
	IE: document.getElementByName()和document.all[name]均不能获取div元素
	FF: 可以
6)input.type的属性
	IE: input.type只读
	FF: input.type可读写
7)innerText textContent outerHTML
	IE: 支持innerText, outerHTML
	FF: 支持textContent
8)是否可用id代替HTML元素
	IE: 可以用id来代替HTML元素
	FF: 不可以

14.哪些操作会造成内存泄漏？
内存泄漏是指任何对象在您不再拥有或需要它之后任然存在;
垃圾回收器定期扫描对象,并计算引用了每个对象的其他对象的数量;
如果一个对象的引用数量为0,或对该对象的唯一引用是循环的,那么该对象的内存即可回收;
setTimeout 第一个参数使用字符串而非函数的话,会引发内存泄漏;
闭包,控制台日志,循环(在两个对象彼此引用且彼此保留时,就会产生一个循环);

15.js延迟加载的方式有哪些？
	Defer(只支持 IE)和async
	动态创建DOM方式（用得最多）
	按需异步载入js
```

```
flex布局: https://blog.csdn.net/SXW19960127/article/details/96874799
```

```
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>Document</title>
	<style>
		* {
			margin: 0;
			padding: 0;
		}
		.other {
			width: 100%;
			height: 200px;
			background-color: yellow;
		}
		#container {
			width: 100px;
			height: 100px;
			background-color: red;
		}
		.seckill-navfixed{ /*向下滚动能保证导航栏始终呈现在最上面*/
    		position: fixed;
    		top: 0px;
		}
	</style>
</head>
<body>
	<div class="other"></div>
	<div id="container">
		<div class="target"></div>
	</div>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
	<script>
		var container = document.getElementById("container");
		window.onscroll = function () {
			var scrollTop = document.documentElement.scrollTop || window.pageYOFFset || document.body.scrollTop;
			if (scrollTop >= 200) {
				container.className = "container seckill-navfixed"
			} else {
				container.className = "container";
			}
			console.log(scroollTop);
		}
	</script>
</body>
</html>
```

```
Doctype (标准模式/怪异模式)
验证:
	console.log(document.compatMode);
        返回BackCompat --> 表示怪异模式(按照各个浏览器来解析)
        返回CSS1Compat --> 表示标准模式(按照规范来解析)
区别:
    1.标准盒模型和IE6混杂模式盒模型;
    2.table字体在标准模式下继承body,怪异模式下不继承body;
    3.怪异模式IE6以下版本中可以给span等行级元素设置宽高;
    4.怪异模式下即使父级没有高度,也可以设置百分比高度;
    5.怪异模式IE6以下margin:0 auto不能左右居中;
    6.怪异模式IE6以下图片的padding失效;
    7.只有在IE6之前的浏览器才会触发IE6混杂模式;
    8.IE6混杂模式盒模型是微软超前的意识提出的,所以只有IE浏览器才会有;
    9.在怪异模式下盒模型的总宽度和高度是包含内边距padding和边框border在内的,所以盒子宽度即为width;
```

```
计时器做动画存在以下3个问题:
	1.当前窗口不在动画页面时,计时器仍在继续工作,比较浪费CPU,尤其是在移动端;
	2.回调函数执行耗时,像是在排队,就像计时器执行每次时间间隔为100ms,我们函数执行一次需要200ms,这就会导致计时器时间间隔到了,而函数还没开始执行,对应的应该执行的第一次,第二次就会排队在队列中,当回调函数在队列排队较多时,浏览器就会瘫痪;
	3.设置动画频率高,像是过度绘制,会出现掉频。浏览器屏幕刷新频率为1000/60=16.7ms;当计时器执行的频率比浏览器刷新的频率还要快的时候,并没啥子软用,用户看到的还是依照浏览器刷新的频率来看的;
----------------------------------------------------------------------
requestAnimationFrame优势:
	1.当前窗口不在动画页面时便停止工作;
	2.浏览器刷新屏幕时自动执行,无需设置时间间隔;
	3.浏览器内部自带优化;
requestAnimationFrame使用:
	1.req=requestAnimationFrame(cb); 屏幕每次绘制时执行回调函数cb
	2.cancelAnimationFrame(req);
```

```
requestAnimationFrame使用小例子:
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
        <style>
            .demo{
                position: absolute;
                left: 0;
                top: 100px;
                width: 100px;
                height: 100px;
                background: pink;
            }
        </style>
    </head>
    <body>
        <div class="demo"></div>
        <script>
            var oDemo = document.getElementsByClassName('demo')[0];
            function move() {
                var l = oDemo.offsetLeft;
                if(l < 500) {
                    oDemo.style.left = l + 9 + 'px';
                    requestAnimationFrame(move); //不需要设置执行时间
                }else {
                    oDemo.style.left = '500px';
                }
            };
            move();
        </script>
    </body>
</html>
```

```
rgba和opacity区别:
在给父级设置opacity时,子元素默认继承opacity;
但是rgba不会出现这种情况;
```

```
columns 多列布局
columns: column-width|column-count;
	column-width: 设置每列的宽度(不小于);
	column-count: 固定列数;
	column-gap: 列宽,默认会继承font-size的值;
	column-span: none|all; (标题横跨所有列);
	column-rule: column-rule-width column-rule-style column-style-color; 列边框样式
		column-rule: 1px dashed #ccc; (线不占宽度)
```

```
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
        <style>
            .wrapper{
                border: 4px double #000;
                column-width: 300px; //每列宽度
                width: 900px;
                column-gap: 0; //列宽
                column-rule: 1px dashed #666; //列与列之间的分割线,不占宽度;
            }
            h1{
                text-align: center;
                column-span: all; //标题横跨所有列
            }
        </style>
    </head>
    <body>
        <div class="wrapper">
            <h1>出师表</h1>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。宫中府中，俱为一体。</p>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。臣本布衣，躬耕于南阳，苟全性命于乱世。</p>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。</p>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。今当远离，临表涕零，不知所言。</p>
        </div>
    </body>
</html>
```

```
瀑布流效果
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
        <style>
            body, ul, li{
                margin: 0;
                padding: 0;
                list-style: none;
            }
            ul{
                /* border: 1px solid #000; */
                /* 给父级设置多列布局columns属性,子元素就会实现多列布局,注意子元素必须都是块元素才能使用多列布局 */
                column-width: 300px; //每列宽度
                margin: 30px 50px; 
            }
            li{
                display: inline-block; /*设置图片一个个排开*/
                width: 300px; /*li宽度是300px*/
                border: 1px solid #ccc;
                padding: 10px; 
                box-sizing: border-box; /*按照IE6混杂模式盒模型属性实现所设置的border和padding同时成立*/
                border-radius: 10px; 
                margin: 10px 5px; 
                /*li上线链接的太紧密了,设置一下margin值,上下margin都设置成10px会导致margin塌陷的问题,最后上下只有10px,而不是20px*/
                /* 注意: 如果margin设置上下10px,左右的5px我们设置为0,然后通过column-gap: 10px;设置列宽,就会出现一个bug,因为是行级块元素,就会出现布局混乱,解决办法是:再次通过改变margin左右的值为5px,即为10px,让出一个10px,来解决 */
            }
            img{
                width: 100%;
            }
        </style>
    </head>
    <body>
        <ul>
            <li><img src="./video/1.jpg" alt=""></li>
            <li><img src="./video/2.jpg" alt=""></li>
            <li><img src="./video/3.jpg" alt=""></li>
            <li><img src="./video/4.jpg" alt=""></li>
            <li><img src="./video/5.jpg" alt=""></li>
            <li><img src="./video/6.jpg" alt=""></li>
            <li><img src="./video/7.jpg" alt=""></li>
            <li><img src="./video/8.jpg" alt=""></li>
            <li><img src="./video/9.png" alt=""></li>
        </ul>
    </body>
</html>
```

```
Media媒体查询
常见页面布局:
    1.静态布局;
    2.流式布局;
    3.自适应布局;
    4.响应式布局;
媒体查询:
	1.媒体类型: 媒体查询中指定的媒体类型匹配展示文档所使用的设备类型;
	2.媒体特性: 媒体特性表达式(0或多个)最终会被解析为true或false;
	3.link元素中的css媒体查询:
		<link rel="stylesheet" href="demo.css" media="screen and (max-width: 600px)">
	4.样式表中的css媒体查询:
		在彩色屏幕下并且最大宽度值不能超过600px,.demo里面的css样式生效
    @media screen and (max-width: 600px) { //screen媒体类型,(max-width:600px)媒体特性
        .demo{
            background: pink;
            color: deeppink;
        }
    }
    @media screen and (min-width: 600px) and (max-width: 800px) {
        .demo{ //(600-800px)宽度之间生效
            background: green;
            color: yellow;
        }
    }
媒体查询的逻辑操作符:
1.and操作符
用于合并多个媒体属性或合并媒体属性与媒体类型
@media screen and (min-width: 500px) and (max-width: 800px)
2.逗号分隔列表
逗号分隔效果等同于or逻辑操作符,只要任意一个媒体查询返回真,样式就是有效的
@media (max-width: 300px), screen and (orientation: landscape)
3.not操作符
在媒体查询为假时返回真
@media not screen and (min-width: 500px) and (max-width: 800px)
4.only操作符
防止老旧的浏览器不支持带媒体属性的查询而应用到给定的样式
@media only screen and (min-width: 500px) and (max-width: 800px)
```

```
<style>
    .wrapper{
        display: flex;
        border: 1px solid #000;
    }
    .left, .right{
        width: 200px;
        height: 200px;
        background: orange;
    }
    .center{/*宽度由内容撑开,高度由内容决定*/
        background: pink; 
        flex-grow: 1;
        width: 100px; /*定宽实现三列布局*/
    }
</style>
<body>
    <div class="wrapper">
        <div class="left">我是left</div>
        <div class="center">我是center我是center我是center我是center我是center我是center我是center</div>
        <div class="right">我是right</div>
    </div>
</body>
```

```
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>三列布局</title>
        <style>
            body, ul, li{
                margin: 0;
                padding: 0;
                list-style: none;
            }
            .nav{
                display: none;
                background: #ccc;
                justify-content: flex-end;
            }
            @media screen and (max-width: 800px) { // <= 800px 生效
                .nav{
                    display: flex;
                }
                .left{
                    display: none;
                }
            }
            .nav li{
                display: inline-block;
                border-left: 1px solid rgba(0, 0, 0, 0.2);
                padding: 5px 30px;
                margin: 10px 0;
                text-align: center;
            }
            .wrapper{
                display: flex;
                border: 1px solid #ccc;
                min-width: 600px; //界面小于600px出现横向滚动条
            }
            .left{
                width: 200px;
                height: 200px;
                background: orange;
            }
            .left ul{
                display: flex;
                flex-direction: column;
                height: 200px;
            }
            .left li{
                display: inline-block;
                width: 100%;
                height: 30px;
                line-height: 30px;
                text-align: center;
                flex-grow: 1;
                background: #999;
                margin-bottom: 1px;
            }
            .center{
                flex-grow: 1;
                width: 100px;
                background: pink;
            }
            .right{
                width: 200px;
                height: 200px;
            }
        </style>
    </head>
    <body>
        <nav class="nav">
            <ul>
                <li>1</li>
                <li>2</li>
                <li>3</li>
                <li>4</li>
                <li>5</li>
            </ul>
        </nav>
        <div class="wrapper">
            <div class="left">
                <ul>
                    <li>1</li>
                    <li>2</li>
                    <li>3</li>
                    <li>4</li>
                    <li>5</li>
                </ul>
            </div>
            <div class="center">我是center我是center我是center我是center我是center我是center</div>
            <div class="right">我是right</div>
        </div>
    </body>
</html>
```

```
实现元素水平垂直居中:
	1.父级设置 position: relative;
    2.子元素{
        position: absolute;
        top: 50%;
        margin-top: -高度的一半;  <--效果相同-->  transform: translateY(-50%);
        left: 50%;
        margin-left: -宽度的一半;  <--效果相同-->  transform: translateX(-50%);
    }
```

```
1.实现元素的垂直水平居中方式?
a.设置定位,margin为自身的的一半,top: 50%;left: 50%;position: absolute;
.wrapper{
    width: 500px;
    height: 500px;
    border: 1px solid #ccc;
    position: relative;
}
.wrapper .box {
    position: absolute;  
    top:50%;                
    left: 50%;
    margin: -50px -50px;   
    width: 100px;
    height: 100px;
    background-color: blueviolet;
}
-----------------------------------------------
b.transform: translate(-50%,-50%);
c.flex布局 justify-center: center;align-items: center;
.wrapper {
   width: 500px;
   height: 500px;
   border: 1px solid #ccc;
   display: flex;
   justify-content: center;
   align-items: center;
}
.wrapper .box {
   width: 100px;
   height: 100px;
   background-color: blueviolet;
}
--------------------------------------------------
d.margin:auto;position:absolute;left:0;top:0;right:0;bottom:0;
.wrapper {
    width: 500px;
    height: 500px;
    position: relative;
    border: 1px solid #ccc;
}
.wrapper .box {
    position: absolute;
    left: 0;
    right: 0;
    top:0;
    bottom: 0;
    margin: auto;
    width: 100px;
    height: 100px;
    background-color: blueviolet;
}
```

```
transform形状变换
transform属性向元素应用2D或3D转换;
该属性允许我们对元素进行 移动translate, 缩放scale, 旋转rotate等;
	1.移动: translate
		translateX() 左右
		translateY() 上下
		translateZ() 里外
		translateX(100%) ---> 向右移动自身宽度的尺寸
		transform: translate(100px, 100px);
	2.缩放: scale
		scaleX()
		scaleY()
		scaleZ()
		写一个值表示的是x,y两个方向,值等于1不缩放,大于1放大,小于1缩小;
	3.旋转: rotate
		rotateX(45deg);
		rotateY()
		rotateZ()
		写一个值默认沿z轴旋转;
transform-origin: 改变中心点位置,所有图形变换都是以中心点为标准进行的;
    transform-origin: 50% 50% 0;(默认值)
    X轴方向: left|center|right|length|%
    Y轴方向: top|center|bottom|length|%
    Z轴方向: length
```

```
动画: transition过渡
transition: property duration timing-function delay;
	transition-property: 设置过渡效果的CSS属性名称;
	transition-duration: 完成过渡效果需要多少毫秒;
	transition-timing-function: 速度效果的速度曲线;
	transition-delay: 定义过渡效果何时开始;
	transition: all 4s linear; //all所有元素只要最初状态和当前状态有差异了,就会发生过渡;
transition-timing-function: linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(n,n,n,n);
        linear 匀速 
        ease 慢快慢 
        ease-in 慢速开始的过渡 
        ease-out 慢速结束的过渡 
        ease-in-out 慢速开始和结束的过渡 
        cubic-bezier(n,n,n,n); 在cubic-bezier函数中定义自己的值,0~1之间的数值。
```

```
阻塞加载,延迟加载,异步加载
* * *
阻塞加载(同步加载): 平常默认使用的都是阻塞加载;
		 阻塞加载会阻止浏览器的后续处理,停止了后续文件的解析,执行;
		 为了可以让页面先显示出来,我们通常会把要加载的js放到body结束标签之前,尽量减少阻塞页面的渲染;
defer 延迟加载: 脚本可以延迟到文档完全被解析和显示之后再执行,加载脚本顺序一定;
    <script defer src="1.js"></script>
    <script defer="defer" src="1.js"></script>
async 异步加载: 立即下载脚本,但不妨碍页面中的其他操作,加载脚本顺序不一定;
    <script async src="1.js"></script>
    <script async="async" src="1.js"></script>
    异步加载三种方式: 
    	async、
    	await、
    	onload: 在window.onload方法里执行函数,这样就解决了阻塞onload事件触发的问题;
```

```
判断数据类型(4种):
1.typeof (无法判别某个对象的具体类型)
    typeof(function(){}) ---> function
    typeof (new Function()) ---> function
    typeof(NaN) ---> number
    typeof(undefined) ---> undefined
    typeof(null) ---> object 基本数据类型就这个null不能够准确判断 
    typeof([1,2,3]) ---> object
    typeof(new Date()) ---> object
2.Object.prototype.toString.call() //无法判断自定义对象的类型
	Object.prototype.toString.call(''); //[object String]
3.instanceof //仅能判断'对象'的具体类型,判断A是否为B的实例,表达式为: A instanceof B,检测的是原型;
4.constructor //查看对象对应的构造函数
	(1).constructor; //将1转换为对象,其构造函数为Number();
	当执行var f = new F()时,F被当成了构造函数,f是F的实例对象,此时F原型上的constructor传递到了f上,因此f.constructor == F;
	null和undefined是无效的对象,不存在constructor,这两种类型的数据需要通过typeof来判断;
```

```
浅拷贝
	在定义一个对象或数组时,变量存放的往往只是一个地址,当我们使用对象拷贝时,如果属性是对象或数组时,这时候我们传递的也只是一个地址,因此子对象在访问该属性时,会根据地址回溯到父对象指向的堆内存中,即父子对象发生了关联,两者的属性值会指向同一内存空间;
const object1 = {
  a: 1,
  b: 2,
  c: 3
};
const object2 = Object.assign({c: 4, d: 5}, object1);
console.log(object2); //Object2 = { c: 3, d: 5, a: 1, b: 2 }
浅拷贝,返回的不是一个新对象,而是把一个或多个源对象添加到目标对象;
* * *
let object1 = {
  a: 1,
  b: 2,
  c: 3
};
let object2 = {...object1};
object1.a=11;
console.log(object2); //Object2 = { a: 11, b: 2, c: 3 } 浅拷贝
* * *
var obj = {x: 1,y : {x: 2}}
var obj1 = {}
for(var i in obj) {
	obj[i] = obj[i];
}
* * *
深拷贝
	在实际编码中,我们不希望父子对象之间产生关联,那么这时候可以用到深拷贝,既然属性值类型是数组和对象时只会传址,那么我们就用递归来解决这个问题,把父对象中所有属于对象的属性类型都遍历赋给子对象即可,测试代码如下:
JSON.stringify()和JSON.parse()
先把对象使用JSON.stringify()转为字符串赋值给另外一个变量,然后使用JSON.parse()转回来;
let object1 = {
  a: 1,
  b: 2,
  c: 3
};
let object2 = JSON.parse(JSON.stringify(object1));
object2.a = 11;
console.log(object1,object2);
//Object1 = { a: 1, b: 2, c: 3 }; 
//Object2 = { a: 11, b: 2, c: 3 };
* * *
递归实现深克隆
function clone(obj) {
	var obj1 = {};
	for(var i in obj) {
		if(typeof obj[i] == "object") {
			obj1[i] = clone(obj[i])
		}else {
			obj1[i] = obj[i];
		}
	}
	return obj1
}
* * *
在原型链上操作实现深克隆
function clone1(obj) {
	function Temp() {}
	Temp.prototype = obj;
	return new Temp();
}
```

```
函数的call和apply
* * *
function add(a,b) {
    return a + b;
};
var obj = {};
console.log(add.call(obj,2,3)); //5
* * *	
function add() {
    console.log(this); //obj对象
    return this.x + this.y; //4
}
var obj = {
    x: 2,
    y: 2,
};
console.log(add.call(obj));
--------------------------------------
function add2(a,b) {
    return a + b;  
};
var obj = {};
console.log(add2.apply(obj,[2,3])); //5
console.log(add2.call(obj,2,3)); //5
-------------------------------------
两者区别: 传递参数的形式不一样,apply传递的参数是数组;
```

```
bind: 把函数拷贝一份,并插入到对象作用域上面;
* * *
function add() {
  	return this.x + this.y;  
};
var obj = {
  	x: 1,
    y: 2,
};
var func = add.bind(obj);
console.log(func());
* * *
function add() {
  	return this.x + this.y;  
};
var obj = {
  	x : 1,
    y : 2,
    e : function() {
        return this.x + this.y;
    }
};
obj.e = add.bind(obj); //在对象obj里加一个属性值并赋给属性名e
* * *
function add(a,b) {
  	return this.x * a + this.y * b;  
};
var obj = {
  	x : 1,
    y : 2,
};
obj.e = add.bind(obj);
console.log(obj.e(10,100));
* * *
function add(a,b) {
  	return this.x * a + this.y * b;  
};
var obj = {
    x : 1,
    y : 2,
}
obj.e = add.bind(obj,10); //这里先输入一个形参a
console.log(obj.e(100)); //这里输入一个形参b
----------------------------------------------------------
总结: call()、apply()、bind()
相同点: 都是用来改变this指向;
call()和apply()相同点: 都是调用一个对象的一个方法,用另一个对象替换当前对象;
	例如: B.call(A,args1,args2);即A对象调用B对象的方法 
		 F.apply(G,arguments);即G对象调用F对象的方法
			   不同点: 参数书写方式不同;
		 call()第一个参数是this要指向的对象,后面传入的是参数列表,参数可以是任意类型,当第一个参数为null、undefined的时候,默认指向window;
		 apply()第一个参数是this要指向的对象,第二个参数是数组;
* * *
var obj = {} 
function f(x,y){
    console.log(x,y)
    console.log(this) //this是指obj
}
f.apply(obj,[1,2]) //后面的值需要用[]括起来
f.call(obj,1,2) //直接写
* * *
call()和bind()的区别:
	不同点: call()改过this指向后,会再执行函数;
	       bind()改过this后,不执行函数,会返回一个绑定新this的函数;
* * *
function f(){
    console.log("看我怎么被调用");
    console.log(this) //指向this
}
var obj = {};
f.call(obj) //直接调用函数
var g = f.bind(obj); //bind()不能调用函数
g();  //此时才调用函数
```

```
递归:
1.函数自己调用自己;
2.需要有终止条件;
-----------------
function f(n) { //实现数字的递减关系
  	console.log(n);
    if(n <= 1) {
        return;
    }else f(n-1);
}; 
--------------------------
function f(n) { //递归实现n的阶乘 n!
  	if(n === 0) {
        return 1;
  	}  
  	return n * f(n-1);
};
-------------------------------------
function f2(x,n) { //用递归实现x的n次方
  	if(n === 0) {
        return 1;
  	}  
  	return x * f2(x,n-1);
};
```

```
闭包:
    1.嵌套结构的函数;
    2.内部函数访问了外部函数的变量;
    3.在外部函数的外面,调用内部函数;
function f() {
  	var a = 1;
    function e() {
        a ++;
        console.log(a);
    }
    return e;
};
var fe = f();
fe();
```

```
数组去重:
1.for循环嵌套,利用splice去重
function newArr(arr){
    for(var i=0;i<arr.length;i++){
        for(var j=i+1;j<arr.length;j++)
            if(arr[i]==arr[j]){ 
            //如果第一个等于第二个，splice方法删除第二个
            arr.splice(j,1);
            j--;
            }
        }
    }
    return arr;
}
var arr = [1,1,2,5,6,3,5,5,6,8,9,8];
console.log(newArr(arr))
-------------------------------------------------
2.建新数组,利用indexOf去重
function newArr(array){ 
    //一个新的数组 
    var arrs = []; 
    //遍历当前数组 
    for(var i = 0; i < array.length; i++){ 
        //如果临时数组里没有当前数组的当前值，则把当前值push到新数组里面 
        if (arrs.indexOf(array[i]) == -1){ 
            arrs.push(array[i])
        }; 
    } 
    return arrs; 
}
var arr = [1,1,2,5,5,6,8,9,8];
console.log(newArr(arr))
---------------------------------------------------
3.ES6中利用Set去重
function newArr(arr){
    return Array.from(new Set(arr))
}
var arr = [1,1,2,9,6,9,6,3,1,4,5];
console.log(newArr(arr))
```

```
块级作用域:
1.{ 块级作用域 };
2.两个关键字 let const (通过这两个关键字定义出来的变量遵循块级作用域特点);
3.let和const区别:
    let
        a.不能变量声明提升;
        b.不能重复声明变量,防止变量污染;
    const 
        a.定义时要有初始化值;
        b.初始化值不能改变(注意是内存地址的绑定不能改变);
```

```
模板字符串:
	1.反引号 `字符串`
	2.替换位的使用 ${}
```

```
解构赋值
let x = 1;
let y = 2;
[x,y] = [y,x] //x = 2;y = 1
注意: 
let [x = 10,y = 20] = []; //当指定位置的项'不存在'或严格等于'undefined'时,走默认值;
```

```
var foo = (a,b) => {
  return (a + b)
}
foo(1,2)
注意:
1.如果参数只有一个可以省略形参小括号;
2.当逻辑语句里只有一条语句时,{}可以省略;
3.如果该逻辑语句用reture返回值,return也可省略;
var foo = (a,b) => a + b
------------------------------------------
var arr = [1,2,3];
console.log(arr.map((x) => {
  return x * x; //[1,4,9]
}))
// 简写形式: console.log(arr.map(x => x * x ))
注意: 箭头函数里不能使用arguments获取参数的,不能使用箭头函数当作构造函数;
----------------------------------------------------------------
this指向:
var obj = {
  init: function() {
    var that = this //改变this指向的第一种方式
    document.addEventListener('click',function(event) {
      console.log(this)
      that.output(event.type)
    })
  },
  output: function(value) {
    console.log(value)
  }
}
obj.init()
* * *
var obj = {
  init: function() {
    document.addEventListener('click',function(event) {
      console.log(this)
      this.output(event.type)
    }.bind(this)) //通过 .bind 去改变this指向
  },
  output: function(value) {
    console.log(value)
  }
}
obj.init()
* * *
var obj = {
  init: function() {
    document.addEventListener('click',(event) => { 
      //箭头函数中是没有this指向的,它借用的是父级作用域里面的this指向
      this.output(event.type)
    })
  },
  output: function(value) {
    console.log(value)
  }
}
obj.init();
---------------------------------------------------------------
var obj = {
  init: () => {
    console.log(this) //window,箭头函数去找父级作用域里面的this,这里父级是window;
  }
}
obj.init.call(obj); //依旧指向window,改变不了this指向;
-----------------------------------------------------------------------------
this指向在函数定义的时候是确定不了的,只有函数执行时才能确定this到底指向谁;
实际上this指向那个调用它的对象;
* * *
function a(){
    var user = "sxw";
    console.log(this.user); //undefined
    console.log(this); //Window
}
a(); //相当于window.a();
* * *
var obj = {
    user: "sxw",
    fn: function(){
        console.log(this.user); //sxw
        console.log(this); //{user: "sxw", fn: ƒ}
    }
}
obj.fn();
* * *
var obj = {
    a: 10,
    b: {
        fn: function(){
            console.log(this.a); //undefind
        }
    },
    fn1: function(){
        console.log(this.a);  //10 
    }
}
obj.fn1();
obj.b.fn();
* * *
function fn()  
{  
    this.user = '追梦子';  
    return {};  
}
var a = new fn;  
console.log(a.user); //undefined
* * *
function fn()  
{  
    this.user = '追梦子';  
    return function(){};
}
var a = new fn;  
console.log(a.user); //undefined
* * *
function fn()  
{  
    this.user = '追梦子';  
    return 1;
}
var a = new fn;  
console.log(a.user); //追梦子
* * *
function fn()  
{  
    this.user = '追梦子';  
    return null;
}
var a = new fn;  
console.log(a.user); //追梦子
* * *
总结: 如果return一个对象,则this指向那个返回的对象,如果返回值不是一个对象那么this还是指向函数实例; 
虽然null也是对象,但是this还是指向函数实例,因为null比较特殊;
* * *
var o = {
    a:10,
    b:{
        a:12,
        fn:function(){
            console.log(this.a); //undefined
            console.log(this); //window
        }
    }
}
var j = o.b.fn;
j();
this指向window,this永远指向最后调用它的对象,也就是看它执行的时候是谁调用的;
例4中虽然函数fn是被对象b所引用,但是在将fn赋值给变量j的时候并没有执行所以最终指向的是window;
--------------------------------------------------------------------------------
this指向梳理:
1.自己执行时this指向;
2.隐式this指向变化;
3.显式this指向变化;
4.new指向;
5.箭头函数this指向;
----------------------------
改变this指向:
1)new关键字改变this指向
function Fn(){
    this.user = "追梦子";
}
var a = new Fn();
console.log(a.user); //追梦子
用变量a创建了一个Fn实例(相当于复制了一份Fn到对象a里),此时仅仅只是创建,并没有执行;
调用这个函数Fn的是对象a,那么this指向的自然是对象a;
那么为什么对象a中会有user,因为你已经复制了一份Fn函数到对象a中;
2)call()
var a = {
    user:"追梦子",
    fn:function(){
        console.log(this.user); //追梦子
    }
}
var b = a.fn;
b.call(a);  //若不用call,则b()执行后this指的是Window对象
* * *
var a = {
    user:"追梦子",
    fn:function(e,ee){
        console.log(this.user); //追梦子
        console.log(e+ee); //3
    }
}
var b = a.fn;
b.call(a,1,2);
把b添加到第一个参数的环境中,this就会指向那个对象;
call方法除了第一个参数以外还可以添加多个参数;
3)apply()
var a = {
    user:"追梦子",
    fn:function(){
        console.log(this.user); //追梦子
    }
}
var b = a.fn;
b.apply(a);
apply和call相似,可以改变this指向,也可以有多个参数,但是不同的是,apply的第二个参数必须是一个数组;
var a = {
    user:"追梦子",
    fn:function(e,ee){
        console.log(this.user); //追梦子
        console.log(e+ee); //11
    }
}
var b = a.fn;
b.apply(a,[10,1]);
// 注意: 如果call和apply的第一个参数写的是null,那么this指向的是window对象;
var a = {
    user:"追梦子",
    fn:function(){
        console.log(this); //Window {external: Object, chrome: Object, document: document, a: Object, speechSynthesis: SpeechSynthesis…}
    }
}
var b = a.fn;
b.apply(null);
* * *
4)bind()
var a = {
    user:"追梦子",
    fn:function(){
        console.log(this.user);
    }
}
var b = a.fn;
b.bind(a);  //代码没有被打印,bind方法返回的是一个修改过的函数;
* * *
var a = {
    user:"追梦子",
    fn:function(){
        console.log(this.user);
    }
}
var b = a.fn;
var c = b.bind(a);
console.log(c); //function() { [native code] }
* * *
var a = {
    user:"追梦子",
    fn:function(e,d,f){
        console.log(this.user); //追梦子
        console.log(e,d,f); //10 1 2
    }
}
var b = a.fn;
var c = b.bind(a,10);
c(1,2);
同样bind也可以有多个参数,并且参数可在执行的时候添加,需要注意的是,参数是按照形参的顺序进行的;
-------------------------------------------------------------------------------------
总结: 
call和apply都是改变上下文中的this并立即执行这个函数;
bind方法可以让对应的函数想什么时候调就什么时候调用,并且可以将参数在执行的时候添加,这是它们的区别;
```

```
数组遍历:
1.arr.forEach(); //遍历数组,利用回调函数对数组进行操作,无法中途跳出循环也就不支持return操作输出;
    let arr = [1,2,3,4,5,6,7]
    arr.forEach( (item) => {
       console.log(item)
    })
2.arr.map(); //创建新数组,回调函数参数(item,index,arr);
    var arr = [1,2,3]
    var newArr = arr.map( (item,index,arr) => {
       return item * 2
    })
    console.log(newArr) // [2,4,6]
3.arr.filter();
    var arr = [1,2,3,4,5,6];
    var newArr = arr.filter( (item,index,arr) => { //创建新数组
       return item > 2 && item < 5; //输出判断为true的元素
    })
    console.log(newArr); //[3,4]
    console.log(arr) // 原数组
4.arr.includes();
    var arr = [1,2,3,4,5] ;
    var new1 = arr.includes(5);  
    console.log(new1);
5.arr.find();与findIndex相同;
var arr = [1,2,3,4,5] ;
var new1 = arr.find( (item,index) => {
		return item > 2 && item < 5; //碰到符合条件的第一个元素就终止循环;
})
var new2 = arr.find(function(item,index){
		return item.toString().indexOf(5) > -1;
})
console.log(new1); //3
console.log(new2); //5
console.log(arr); //[1,2,3,4,5]
6.arr.some();
    var arr = [1,2,3,4,5] ;
    var new1 = arr.some((item,index) => {
        return item > 2 && item < 5;// 判断出一个符合条件则跳出循环并输出true
    })
    var new2 = arr.some((item,index) => {
        return item > 5;// 判断出数组全部元素都不符合条件则输出flase
    })
    console.log(new1); //true
    console.log(new2); //false
    console.log(arr); //[1,2,3,4,5]
7.arr.every() 与arr.some相反;
8.arr.reduce() 叠加数组;
```

```
function value() {
  return 20;
}
function fn(a=value(),b=2,c=3) {// 惰性求值,实参严格等于undefined时走默认值;
  console.log(a,b,c)
}
fn()
* * *
const c = 3;
function fn(a = c,b = a) {// 只能获取到外部作用域的值,获取不到函数体内作用域的值;
  const c = 4;
  console.log(a,b) //3,3
}
fn()
-------------------------------------------------------------------------
剩余运算符: 把散列的元素变成一个集合,在函数或者解构中使用;
function add() {
  console.log(arguments) //类数组,由元素1,2组成;
  let arr = Array.prototype.slice.call(arguments); //将类数组变成数组;
  console.log(arr) //数组 [1,2]
}
add(1,2)
* * *
function add(...arr) {// ...arr ---> 将散列的元素拼接成一个数组
  console.log(arr) //数组 [1,2]
}
add(1,2)
* * *
let [a,...b] = [1,2,3];
console.log(a,b); //a = 1,b = [2,3]
* * *
let {a,b,...c} = {a:1,b:2,c:3,d:4}
console.log(a,b,c); //a = 1,b = 2,c = {c:3,d:4}
-------------------------------------------------------------------
扩展运算符:
function fn(a,b,c) {
  console.log(a,b,c) //1,2,3
}
fn(...[1,2,3]) //数组变成散元素
* * *
let arr = [1,2,3];
let arr2 = arr.concat(); //浅拷贝
arr2.push(4);
console.log(arr2); //[1,2,3,4]
console.log(arr); //[1,2,3]
* * *
let arr = [1,2,3];
let arr2 = [...arr,4,5,6]; //浅拷贝
arr.push(4)
console.log(arr) //[1,2,3,4]
console.log(arr2) //[1,2,3,4,5,6]
* * *
let obj = {
  a : 1,
  b : 2,
  c : 3
}
let obj2 = {
  ...obj
}
obj.d = 4;
console.log(obj2) //{a:1,b:2,c:3}
```

```
对象的遍历
1.Object.keys //遍历对象的属性名,以数组的形式返回;
2.Objecy.values(es7) //遍历对象的属性值,以数组的形式返回;
3.Object.entries(es7) //遍历对象的键值对,以数组的形式返回,数组中是键值对的形式;
```

```
模块化基本语法: 导入(import) 导出(export)
ES6只是定义了语法,并没有定义在浏览器中的加载方式;
    <script type="module">
        import {add} from "./add.js";
    </script>
在add.js中
function add(a,b) {
	console.log(a+b)
}
export {add} //到处最好是在最后导出
* * *
默认导出,适用于当前我们只导出一个对象的时候;
export default function add(a,b) {
	console.log(a+b)
}
那么我们在导入的时候命名就可以自定义取名字了;
* * *
当我们导入的参数较多的时候,在导出时可以这样写:
import * as obj from "./add.js"
console.log(obj)
```

```
创建数组:
let arr1 = [1,2,3]; //以前定义数组的两种方式
let arr2 = new Array(10); //存在问题,这里10被识别为数组长度,与我们想要让他是数组中1个元素,10不匹配
Array.of //此方法就是用来解决上面出现的这个问题的,用的不多;
* * *
Array.from 将类数组转换为数组
只存在两种情况需要将类数组转换为数组的: 1.获取dom节点的时候; 2.arguments中;
Arr.map((item) => {
	return item.textContent;
})
* * *
//结合操作,将类数组myP转换为数组,并且数组调用.map方法,.map方法的回调函数所执行的操作就是我们写在第二个参数里面的值;
let myArr = Array.from(myP, (item) => {
	return item.textContent;
})
* * *
arguments中:
function add() { //将传进来的arguments先转换为数组才能调用reduce方法
	return Array.from(arguments).reduce((item,sum) => {//reduce传递两个参数,第二个参数是求和
		return sum += item
	}, 0) //初始sum为0
}
console.log(add(1,2,3,4,5))
* * *
数组新方法
find 查找当前数组中有没有我们想要的数据
* * *
var data = [{
	id: 1,
	name: 'sxw'
},{
	id: 2,
	name: 'kebo'
},{
	id: 3,
	name: 'AI'
}]
console.log(data.find((item,index,arr) => { //三个参数分别是 item单纯的一个接收变量,这里定义什么下面就使用什么; index 索引; arr表示整个数组;
	return item.id === 2;
}))
find只会遍历到第一次出现想要匹配的值的时候就停止了,想要遍历出对象上的所有符合条件的属性可以使用filter;
* * *
findIndex 查找当前数组中有没有我们想要的数据,返回数据的索引
var data = [{
	id: 1,
	name: 'sxw'
},{
	id: 2,
	name: 'kebo'
},{
	id: 3,
	name: 'AI'
}]
console.log(data.findIndex((item,index,arr) => { 
	return item.id === 2; //返回1
}))
* * *
fill 填充数组
var arr = new Array(10); //10个空数组;
arr.fill(1); //10个1
arr.fill(1,4,10); //用1在索引位第4位开始填充到第10位,不包含第10位进行填充
* * *
copyWithin 数组内部进行复制
var arr = [1,2,3,4,5,6,7,8,9]
arr.copyWithin(0,6,9) //从索引第0位开始,将索引第6位到第9位不包含第9位数值复制到第0位位置处;
* * *
some 
var ages = [10,20,30];
console.log(ages.some((item) => {return item >= 18})); //判断下遍历出来的item有没有大于等于18的,有就返回true;
* * *
every (同some,但是要求是需要每一项都要大于等于18才行)
* * *
includes 判断数组中有没有我们想要的元素
var arr = [1,2,3,NaN]
console.log(arr.indexOf(1)); //返回索引,没有的话返回 -1
console.log(arr.includes(NaN)); //true,此方法还可以用来判断NaN,但是indexof不行
* * *
数组的浅拷贝
let arr = [1,2,3]
let arr1 = arr.concat() //合并,当我们不传值的时候,默认就实现了拷贝,复制了一份出来,与arr没有关联了
let arr2 = arr.slice() //切割,当我们不传值的时候,默认实现了拷贝,复制了一份出来,与arr没有关联了
let arr3 = Array.from(arr) //同上
```

```
迭代器的出现:
迭代器是一个统一的接口,是一个对象,对象里面有next方法,每次调用这个方法就会输出数据结构的成员,第一次输出第一个成员,第二次输出第二个,以此类推；
输出成员的形式为 {value:值,done:true/false}
let colors = ["red","pink"]
let iterator = createIterator(colors);
iterator.next(); //{value: 'red',done: flase}
iterator.next(); //{value: 'pink',done: flase}
iterator.next(); //{value: undefined,done: true}
```

```
生成器 Generator 
基础语法: function*fn() {}
* * *
// 普通函数的特点,如果没有return语句,就会从头到尾执行下来
function fn() {
	console.log("sxw")
	console.log("kebo")
}
* * *
function* fn() { //指针,执行到yield语句会输出yield后面的内容并且暂停;
	yield "sxw";
	yield "kobe";
	yield "ice"
}
const people = fn();
* * *
function* fn(x) {
	var y = yield(x + 2); //y=6
	var z = yield(y / 3); //z=undefined
	return (x+y+z);
}
const it = fn(4);
console.log(it.next());
console.log(it.next(6));
console.log(it.next());
* * *
for of循环
function* fn() { 
	console.log("a")
	yield "sxw";
	console.log("b")
	yield "kobe";
	console.log("c")
	yield "ice"
}
const people = fn();
for(var person of people) {
	console.log(person)
}
* * *
var obj = {a:1}
obj[Symbol.iterator] = function* () {
	yield 1;
	yield 2;
	yield 3;
}
for(var prop of obj) {
	console.log(prop)
}
```

```
ES6 异步的处理 Promise async await 
Promise 用来解决回调函数问题的
//js单线程的 js一段时间之内只能做一件事情
//js需要跟浏览器交互 请求数据 等待 异步编程 回调函数
setTimeout(function() {
	console.log("111")
}, 1000)
console.log(222)
先执行222,再执行111
* * *
Promise是用来解决这种问题的,但这也仅仅是一个表面原因
//回调地狱 回调金字塔
setTimeout(function() {
	setTimeout(function() {
		setTimeout(function() {
			setTimeout(function() {
				setTimeout(function() {
				
				}, 1000)
			}, 1000)
		}, 1000)
	}, 1000)
}, 1000)
* * *
Promise的三个状态: pending 成功 失败
创建pending状态的promise对象
const p = new Promise((resolved,rejected) => {
	rejected(new Error("错误了"))
});
p.then(function(val) {
	console.log(val)
},function(err) {
	console.log(err)
})
* * *
const p = new Promise((resolved,rejected) => {
	setTimeout(function() {
		resolved(1000);
	})
});
p.then(function(val) {
	console.log(val)
},function(err) {
	console.log(err)
})
思路: 先执行setTimeout中的代码,发现是一个异步操作,就会把这个异步放到事件队列中去,继续往下执行,去执行p.then,这时候p的状态是pending,既没有调用resolved方法,也没有调用rejected方法;.then什么都不执行,仅仅注册了一个事件,将成功的事件和失败的事件注册了,等1秒后成功了就会调用成功的事件,失败了就会调用失败的事件,promise相当于一个占位符,对未来的值进行了操作;
* * *
链式调用promise,解决了回调金字塔问题:
p.then会但会一个新的promise对象,p.then返回的promise对象,它看回调函数的返回值,如果return值不是promise对象的话,就是成功的状态,如果return的值是一个promise对象的话,继续看promise中的状态以作决定;
const p = new Promise((resolved,rejected) => {
	setTimeout(function() {
		resolved(1000);
	})
});
p.then(function(val) {
	console.log(val)
	return undefined //成功状态
},function(err) {
	console.log(err)
}).then(function() {
	console.log(111) //返回111
},function() {
	console.log(222)
})
* * *
链式调用解决回调地狱的问题:
function fakeAjax(ms, val) {
	return new Promise((resolved,rejected) => {
		setTimeout(function() {
			resolved(val);
		}, ms)
	})
}
fakeAjax(1000,10).then((val) => {
	console.log(val)
	return fakeAjax(2000,20)
}, () => {}).then((val) => {
	console.log(val)
	return fakeAjax(3000,30)
}).then(function(val) {
	console.log(val)
})
```

```
1.
<script>
   var arr = [];
   for(var i = 0;i < 10;i ++) { //循环10次
      arr.push(function() { //这里只是push,函数并没有被立即执行,所以i=?
         console.log(i)
      })
   } //arr数组中有10个元素,每个元素都是一个函数: function() {console.log(i)},此时i=10
   arr.forEach(function(func) { //遍历arr数组,将数组中每个元素(函数)作为参数func传递,执行
      func() //打印10个10
   })
</script>
-----------------------------------------------------------------------------------
把以上代码使用两种方法,来依次输出0到9:
使用ES5的闭包;
<script>
   var arr = [];
   for(var i = 0;i < 10;i ++) {
      arr.push(function(j) {
         console.log(j)
      }(i))
   }
   arr.forEach(function(func) {
      func()
   })
</script>
------------------------------------
使用ES6的let;
<script>
   var arr = [];
   for(let i = 0;i < 10;i ++) {
      arr.push(function() {
         console.log(i)
      })
   }
   arr.forEach(function(func) {
      func()
   })
</script>
```

```
2.ES6的模板字符串有哪些新特性?
第一个用途,基本的字符串格式化,将表达式嵌入字符串中进行拼接,用${}来界定;
<script>
   var name = 'sxw'
   console.log(name + '123')
   const name = 'sxw'
   console.log(`sxw${321}`)
</script>
第二个用途,在ES5时我们通过反斜杠(\)来做多行字符串或者字符串一行行拼接,ES6反引号(``)直接搞定;
<script>
   var msg = "sxw\
   123"
</script>
<script>
   var template = `<div>
      <p>我是模板字符串</p>
   </div>`
</script>
对于字符串es6当然也提供了很多厉害的方法,说几个常用的:
<script>
   // 1.includes: 判断是否包含然后直接返回布尔值
   let str = 'haha'
   console.log(str.includes('h')) //true
   // 2.repeat: 获取字符串重复n次
   let s = 'ha'
   console.log(s.repeat(2)); //haha
   // 3.如果你带入小数, Math.floor(num) 来处理
   let num = 3.14
   console.log(Math.floor(num))
</script>
```

```
3.箭头有哪些新特点？
	不需要function关键字来创建函数;
    省略return关键字;
    继承当前上下文的 this 关键字;
```

```
4.以下代码依次输出内容是？
setTimeout(function() {
  console.log(1)
}, 0);
new Promise(function executor(resolve) {
  console.log(2);
  for( var i=0 ; i<10000 ; i++ ) {
    i == 9999 && resolve();
  }
  console.log(3);
}).then(function() {
  console.log(4);
});
console.log(5);
------------------------------------------------
首先先碰到一个 setTimeout，于是会先设置一个定时，在定时结束后将传递这个函数放到任务队列里面，因此开始肯定不会输出 1 。 然后是一个 Promise，里面的函数是直接执行的，因此应该直接输出 2 3 。 然后，Promise 的 then 应当会放到当前 tick 的最后，但是还是在当前 tick 中。 因此，应当先输出 5，然后再输出 4 。 最后在到下一个 tick，就是 1 。 “2 3 5 4 1”
```

```
5.promise的原理？jquery的ajax返回的是promise对象吗？(百度面试)
jquery的ajax返回的是deferred对象,通过promise的resolve()方法将其转换为promise对象;
var jsPromise = Promise.resolve($.ajax('/whatever.json'));
```

```
6.promise 只有2个状态,成功和失败,怎么让一个函数无论成功和失败都能被调用？ 
Promise.all() 是干什么用的,怎么用？
Pomise.all方法用于将多个Promise实例,包装成一个新的Promise实例;Promise.all方法接受一个数组作为参数,数组里的元素都是Promise对象的实例,如果不是,就会先调用下面讲到的Promise.resolve方法,将参数转为Promise实例,再进一步处理;（Promise.all方法的参数可以不是数组,但必须具有Iterator接口,且返回的每个成员都是Promise实例;）
var p = Promise.all([p1,p2,p3]);p的状态由p1、p2、p3决定,分为两种情况;
a.当该数组里的所有Promise实例都进入Fulfilled状态,Promise.all**返回的实例才会变成Fulfilled状态,并将Promise实例数组的所有返回值组成一个数组,传递给Promise.all返回实例的回调函数**;
b.当该数组里的某个Promise实例都进入Rejected状态,Promise.all返回的实例会立即变成Rejected状态,并将第一个rejected的实例返回值传递给Promise.all返回实例的回调函数;
```

```
7.es6新特性,哪些在项目中使用举例说明?
let const 解构 箭头函数 Set去重 新增数据类型Symbol 模板字符串`` 类怎么实现继承 模块化 
promise / async / await
```

```
8.var let const 区别
```

```
9.Set 怎么去重
ES6中新增了Set数据结构,类似于数组,但是它的成员都是唯一的,其构造函数可以接受一个数组作为参数,如:
<script>
   let arr = [1,1,2,2,2,3,4,5,5,5]
   let set = new Set(arr);
   console.log(set) //此时打印的是set结构 Set(5) {1, 2, 3, 4, 5}
</script>
ES6中Array新增了一个静态方法Array.from,可以把类似数组的对象转换为数组,如通过querySelectAll方法得到HTML DOM Node List,以及ES6中新增的Set和Map等可遍历对象,如:
<script>
   let arr = [1,1,2,2,2,3,4,5,5,5]
   let set = new Set(arr);
   let array = Array.from(set);
   console.log(array) //(5) [1, 2, 3, 4, 5]
</script>
```

```
10.模板字符串怎么使用
主要是针对变量;
```

```
11.promise 实现原理? promise的三种状态?
promise实际上解决jquery的ajax回调地域(解决层层嵌套),只是异步编程的一种解决方案;
代码实现:
    new promise(function(resolve,reject) {
        // 111111111
        resolve('...')
    } ).then(function(value) {
        console.log(value)
    }).catch(function(error){
    console.log(error)
    })
----------------------------
    const p1 = new Promise(function (resolve, reject) {
      setTimeout(() => reject(new Error('fail')), 3000)
    })

    const p2 = new Promise(function (resolve, reject) {
      setTimeout(() => resolve(p1), 1000)
    })

    p2
      .then(result => console.log(result))
      .catch(error => console.log(error))
--------------------------------------------
三种状态: pending（进行中）,fulfilled（已成功）,rejected（已失败）
promise两个特点:
(1) 对象的状态不受外界影响;
(2) 一旦状态改变,就不会再变,任何时候都可以得到这个结果;
promise缺点: 无法取消promise,如果不设置回调函数,promise内部抛出错误;
第三,当处于pending状态时,无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）;
```

```
12.es6继承和es5继承的区别?
```

```
13.箭头函数 this指向
指向包裹她的父函数
```

```
14.对async 和 await的认识
项目中应用可以讲异步改成同步执行
```

```
15.新增数据类型是谁,有什么作用?
```

```
16.es6中对数组遍历的几种方式和不同之处?
```

```
17.es6解构
数组解构和对象解构,项目中返回的response.data 可以解构成自己需要的数据;
```

```
18.对es6的了解
ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准,已经在 2015 年 6 月正式发布了,它的目标,是使得 JavaScript 语言可以用来编写复杂的大型应用程序,成为企业级开发语言;
```

```
19.正确区分数组map方法 和 es6的Map结构
```

```
20.rem的理解:(关于页面的适配--手写)
rem 的62% 是什么意思,16px=1rem,1px=62.5%rem;
https://mp.weixin.qq.com/s/-22kMEXf0S-1okqXw40OqQ
```

```
21.对promise的理解:
https://mp.weixin.qq.com/s/baiyaLF9Xv6ECabCOlIlAg
其余的作用,其实不大:(看下面代码)
function runAsync1(){
    var p = new Promise(function(resolve, reject){
        //做一些异步操作
        setTimeout(function(){
            console.log('异步任务1执行完成');
            resolve('随便什么数据1');
        }, 1000);
    });
    return p;
}
function runAsync2(){
    var p = new Promise(function(resolve, reject){
        //做一些异步操作
        setTimeout(function(){
            console.log('异步任务2执行完成');
            resolve('随便什么数据2');
        }, 2000);
    });
    return p;
}
function runAsync3(){
    var p = new Promise(function(resolve, reject){
        //做一些异步操作
        setTimeout(function(){
            console.log('异步任务3执行完成');
            resolve('随便什么数据3');
        }, 2000);
    });
    return p;
}

runAsync1()
    .then(function(data){
        console.log(data);
        return runAsync2();
    })
    .catch(function(reason){
        console.log('rejected');
        console.log(reason);
    })
    .then(function(data){
        console.log(data);
        return runAsync3();  //这里直接返回数据
    })
    .catch(function(reason){
        console.log('rejected');
        console.log(reason);
    }).then(function (data) {
    console.log(data)
})
```

```
22.关于async的理解:
https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function
```

```
23.在vue里面的异步
问的这么专业  就是axios  mmp
```

```
24.迭代器和生成器的理解
https://www.cnblogs.com/xiaohuochai/p/7253466.html
迭代器和生成器:
 1.迭代器的代码:
/* 迭代器和生成器的区别,之后再说 */
//ES5的迭代器,就是一个闭包而已
function literator(arr) {
    let i=0;  //计数器
    return{
        next(){
            let done=(i>=arr.length);  //指示循环是否完成
            let value=(!done?arr[i++]:undefined); //当前循环的值

            return {
                value:value,
                done:done
            }
        }
    }
}
let myCase=literator([1,2,3,4,5]);
console.log(myCase.next());
console.log(myCase.next());
console.log(myCase.next());
console.log(myCase.next());
console.log(myCase.next());
console.log(myCase.next());
2.生成器:
function* show() {
    yield "hello";
    yield "world";
    yield "ni hao";
    return "返回值"
}

let res = show();
console.log(res.next());
console.log(res.next());
console.log(res.next());
console.log(res.next());

function* myGenerator(arr) {
    for (let i = 0; i < arr.length; i++) {
        yield arr[i];
    }
}

let test=myGenerator([1,2,3]);
console.log(test.next()); //这儿的next方法,属于test对象
console.log(test.next());
console.log(test.next());
console.log(test.next());
```

```
25.ES6新增的类型: map set 
https://www.jb51.net/article/110487.htm
理解:
1.array,set,map
都属于迭代器 iterable(可迭代),类型 ,可以使用for in 来遍历
2.一直对for in  的误解
for in 只可以遍历对象,而数组就是一个对象
3.迭代器的遍历:
iterable内置的forEach方法
4.如何初始化 ,创建实例
var s = new Set(['A', 'B', 'C']);
var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);
5.常用的map操作
/*
* clear
    从映射中移除所有元素。
    删除
    从映射中移除指定的元素。
  forEach
    对映射中的每个元素执行指定操作。
  get
    返回映射中的指定元素。
    有
    如果映射包含指定元素，则返回 true。
  set
    添加一个新建元素到映射。
  toString
    返回映射的字符串表示形式。
  valueOf
    返回指定对象的原始值。
* */
var m = new Map();
m.set(1, "black");
m.set(2, "red");
m.set("colors", 2);
m.set({x:1}, 3);

console.log(m);
m.forEach(function (item, key, mapObj) {
  document.write(item.toString() + "<br />");
});
```

```
26.操作日期的API
代码:(常用的就这几个)
let TheDay=new Date();
let year=TheDay.getFullYear();
let mounth=('00'+(TheDay.getMonth()+1)).slice(-2);
let day=('00'+TheDay.getDate()).slice(-2);
console.log(year+'-'+mounth+'-'+day)

//获取今天星期几
let weekend=['星期日','星期一','星期二','星期三','星期四','星期五','星期六']
console.log( TheDay.getDay(),weekend[TheDay.getDay()])
```

```
27.切割字符串的使用
let str='hello world';
console.log(str.slice(-2))
```

```
28.你开发过vue的插件吗
没有,咋地了  mmp( 插件的使用 )
官方的流程: https://cn.vuejs.org/v2/guide/plugins.html
自己写vue插件的流程
    1.main.js
        1.导入vue的插件文件
            import Loading from '/loading'   //loading 目录下面有index.js文件   
        2.显式的引用插件:
            Vue.use(Loading)
        3.好向不需要注入子组件    
    2.在子组件里面引用:
        <loading>  </loading>  //直接使用好像就可以    
    3.插件的写法:
        1.插件模板的写法:./loading.vue  --vue文件
            正常的组件写法:
                <template><div>正在加载中....</div></template>
                <script> export default {}</script>
                <style scoped></style>
        2.在loading文件夹下面index.js
            1.引入vue的模板文件
                import LoadingComponent from './loading'
            2.核心部分,在使用Vue.use()的时候,自动调用install
                const Loading={
                    install:function(Vue){
                        Vue.component('loading',LoadingComponent)   // loading就是插件名 随便起 
                    }
                }
            3.导出组件 
                export default Loading
```

```
29.数组去重
写三个数组去重的方法  就会写俩  而且强调是函数 (双层循环,就不要用了  太麻烦了)
代码:
arr=[1,2,2,3,4,5,6,7,8,5,4,3]
function f1(arr){
    return Array.from(new Set(arr))
}
console.log(f1(arr))
function f2(arr) {
    let newArr=[];
    arr.forEach(function (item,key,index) {
        if(newArr.indexOf(item)==-1){
            newArr.push(item)
        }
    })
    return newArr;
}
console.log(f2(arr))

function f3(arr){
    let noReat=arr.sort((a,b)=>a-b);
    for(var i=0;i<noReat.length-1;i++){
        if(arr[i]==arr[i+1]){
            arr.splice(i,1)
        }
    }
    console.log(noReat)
}
f3(arr)
```

```
30.遍历对象的方法
for in 不要使用for of + object.keys(obj)
```

```
31.数组和对象解构
let {a,d}={a:12,d:[13,14]}
还有就是  ... 的使用
代码:
function add(...arr) {
  console.log(arr);
  console.log(arguments);
  //arguments  不是数组的,不可以使用数组的方法的

}
add(1,2,3,4,5,6,7,8);
```

```
32.模板字符串的使用
代码:
var c=` ${a+d}======${ b }===${++a}

  hello

  world
`;
理解:
` ${ 写计算  } 
在里面,字符串是可以随便换行的
```

```
33.ES6  对于 数组,字符串的扩展
https://www.haorooms.com/post/es6_string_object_array
```

```
34.vue 的传值
1.使用父子组件传值
2.使用vuex
3.使用bus 来进行传值
https://juejin.im/post/5a4353766fb9a044fb080927
```

```
35.事件的委托
事件捕获--->目标对象---->向上冒泡
```

```
36.vuex的实现原理
就是那张图
```

```
37.谈谈你对vue的理解
mvvm
vue的生命周期
```

```
38.生命周期的理解:
vue的说明周期
    beforeCreate:创建之前
        这个阶段数据是读不到的,时间段,刚调用初始化函数  new...
    created:创建之后
        完成了数据观测,属性和方法的运算,但是没有挂在$el
        所以没有渲染在DOM树上,
        初始化完成....
    beforeMounted:安装之前
        挂载之前调用,在之前,寻找编译的模板和虚拟挂在节点
        在他之前,执行的动作
            1.找el:"'或者vm.$mount(""),确定虚拟挂在点
            2.找template或者 直接找外部的挂载点,确定挂在位置
    mounted:安装之后
        在此之前,执行的动作:
            el选项的节点,被$el代替(挂在到了DOM树上),已经挂载完成(渲染完毕)
            数据被渲染了,render(第一次)执行完毕
    beforeUpdate:更新之前
        有数据更新的时候,立即触发:
            不进行DOM的渲染,执行时间,当有数据更新之后,立马执行
    updated:更新之后
        绑定的数据进行更新(渲染),并且渲染DOM
        之前的动作:
            虚拟DOM的渲染和关在完成
    beforedestroy:销毁之前
        实例销毁之前,调用销毁函数,但没有执行销毁函数
        调用销毁函数,立即执行:
            在此之前,销毁函数被调用
    destroy:销毁之后
        在这个事件点之前:
            VUE实例销毁
            数据,方法,组件..的解绑
```

```
39.生命周期阶段,实例生命中的是时间点,在这个时间点执行函数
mounted:function(){
    ................
}
```

```
40.web socket的理解
https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651227675&idx=1&sn=024b01082bef3b344edcca5f92bafb55&chksm=bd495f9f8a3ed689dc585d0a27f42dd5c787e974da2a5f22938f8a32de1b43c739f49b1b399a&scene=0#rd
```

```
41.https协议的理解
https://mp.weixin.qq.com/s?__biz=MzAwNDcyNjI3OA==&mid=2650840874&idx=1&sn=d2fe0b2f1efa77f79c28e380fd221ceb&chksm=80d3b443b7a43d55cc9437b2c3bd3b46c121acb0eb21c57f4ce08578e21d1788306b0c7a3aa3&scene=0#rd
```

```
42.TCP连接,http,https,udp,webSocket  ...
```

```
43.web woker
https://mp.weixin.qq.com/s?__biz=MzI1ODE4NzE1Nw==&mid=2247486700&idx=1&sn=9ed4fb635f55002bab7f322eb753bc17&chksm=ea0d4616dd7acf009cddea635890c8586e5a9cab9fe0e6b16925bd54f496a884dd685677df2b&scene=0#rd
```

```
44.谈谈你对const 和let 的理解
const (常量标识):
初始化,必须赋值  
常量的名称 默认为大写
常量不可以再次被修改的(否则,直接报错)
let:
js 函数的作用域问题
let是块级作用域,不进行声明提前
代码:(比较这两者的区别 )
使用var 变量的声明提前,打印 indefined   
{
    console.log(str)
    var str = 'hello world'
}
使用let 直接报错,没有声明提前,就没有定义这块内存
{
    console.log(str)
    let str = 'hello word';
}
还有:
let 声明一个变量,在同一个作用域里面 ,只能声明一次
否则报错:
Uncaught SyntaxError: Identifier 'str' has already been declared
下面的写法,是可以的  因为他们不是一个作用域
let a = '666'

function fun() {
    let a = '777'
    console.log(a)
}

fun();
```

```
45.变量提升的理解(hoisting)
1.变量提升只是提升变量的声明，并不会把赋值也提升上来。
代码测试:
bar();
var foo = 1;
function bar() {
    console.log(foo)   //undefind
    if (!foo) {
        var foo = 10;
    }
    console.log(foo);  //打印10
}
理解:
function 变量名 (){   }    可以进行声明提升
2.先提升函数  ,之后提升使用var  声明的变量;
foo();   //输出1
function foo() {    //先提升函数(函数整个提升)
    console.log('1');
}
var foo = function () {    //提升变量 var foo;  之后的函数不会被提升的
    console.log('2');
}
foo();	//输出2
```

```
46.eventLoop
https://cn.vuejs.org/v2/guide/plugins.html
eventloop是事件环，JS分为一个主线程和一个专门放异步的线程，遇到异步要执行的函数时，会先放到这个异步线程中，待同步主线程执行完后再去执行这个异步线程，异步线程是先进先出型的栈，这个线程中又分为宏任务和微任务，执行的顺序也是不一样的，浏览器的事件环和NODE的事件环执行顺序也是有区别的，我只是说个大概，说的不好勿喷，可自行去查。
```

```
https://blog.csdn.net/cmy0816/article/details/81291766
https://www.cnblogs.com/fengxiongZz/p/8191503.html
https://blog.csdn.net/u012860063/article/details/62218564
https://blog.csdn.net/yuwq123/article/details/53835271
https://blog.csdn.net/weixin_37719279/article/details/80950713
```

```
1.git可视化管理;
2.个人主页的搭建; three.js
3.后台管理系统的搭建; ant-design-vue
4.算法; 冒泡排序
5.看大厂面经;
6.切图要回;
7.后端也要会一点;
8.薪资问题;
```

```
基本功: HTML JS CSS *网络 框架 (优化 计算机基础知识,栈,队列)
```

```
1.如何判断一个js变量是否是数组?
    arr instanceof Array
    arr.constructor == Array
    Object.prototype.toString.call(arr) == '[object Array]'
    Array.isArray(arr)
```

```
2.变量提升
console.log(fn) //function fn() {}
var fn = 1;
function fn() {}; //函数是声明和赋值一起提升的
console.log(fn); //1
{
	let fn = 2;
	console.log(fn); //2
}
console.log(fn) //1
```

```
3.分析下面代码的运行逻辑,如何正确输出0-2,如何在每次setTimeout回调之后才进行下一次延时;
for(var i = 0;i < 3;i ++) {
	setTimeout(function() {
		console.log(i);
	}, 1000)
}
console.log(i);
//3 3 3 3
* * *
for(let i = 0;i < 3;i ++) {
	setTimeout(function() {
		console.log(i); //0 1 2
	}, 1000)
}
* * *
function fn(j) {
	setTimeout(function() {
		console.log(j); //0 1 2
	}, 1000)
}
for(var i = 0;i < 3;i ++) {
	fn(i)
}
console.log(i); //3
* * *
回调实现每隔1秒打印,每隔一段时间的等待再去执行函数
const sleep = time => new Promise(resolve => {
	setTimeout(resolve, time);
});
let p = Promise.resolve();
for(let i = 0;i < 3;i ++) {
	p = p.then(() => sleep(1000));
    p = p.then(() => console.log(i));
} //0 1 2
* * *
使用ES7去实现
const sleep = time => new Promise(resolve => {
	setTimeout(resolve, time);
});
箭头函数分解还原
const sleep = function(time) {
	return new Promise(function(resolve) {
		setTimeout(resolve,time);
	})
}
(async () => {
	for(let i = 0;i < 3;i ++) {
		await sleep(1000);
		console.log(i);
	}
})();
```

```
4.在指定input输入时,实时删掉除数字外的字符?如果该页面要求焦点不在该input时输入空格则自动刷新页面怎么办?
用jQ解决:
<input type="text" id="abc" />
$('#abc').on('input', function() {
	let v = $(this).val();
	v = v.replace(/[^\d\w]/, '');
	console.log(v);
	$(this).val(v);
})
*
第二问,阻止冒泡,实现我们在input框中输入空格时候,input框内的内容不会被冒泡触发打印出来
$('#abc').on('input', function() {
	let v = $(this).val();
	v = v.replace(/[^\d\w]/, '');
	console.log(v);
	$(this).val(v);
});
$('#abc').on('keypress', function(e) {
	e.stopPropagation(); //阻止冒泡
})
$(document).on('keypress', function(e) {
	console.log(e.keyCode);
})
*
如果有很多input都要实现这个功能的时候,我们可以使用事件委托实现;
还可以:
$('#abc').on('input', function() {
	let v = $(this).val();
	v = v.replace(/[^\d\w]/, '');
	console.log(v);
	$(this).val(v);
});
$(document).on('keypress', function(e) {
	if(e.target.tagName != 'INPUT') {
		location.reload();
	}
})
```

```
面试的注意事项:
梳理自己做过的项目;
	能够讲清整体架构,自己做的工作,如何解决问题;
根据企业招聘要求写简历,介绍自己;
	着重介绍自己擅长的部分;
	一知半解的部分不要写;
冷静,问题没有标准答案,重点是表达自己的想法;
准备一个问题问面试官;
	如: 团队的规模,开发流程,职位具体分工等;
你解决过的印象最深刻的问题;
```

```
js
1.闭包
概念:能够读取其他函数内部变量的函数,或简单理解定义在一个函数内部的函数,内部函数持有外部函数内变量的引用;
用途:
	a.读取函数内部的变量;
	b.让这些变量的值始终保持在内存中,不会在f1调用后被自定清除;
	c.方便调用上下文的局部变量,利于代码封装;
	原因:f1是f2的父函数,f2被赋给了一个全局变量,f2始终存在内存中,f2的存在依赖f1,因此f1也始终存在内存中,不会在调用后,被垃圾回收机制回收;
缺点:
	1.由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除;
	2.闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值;
闭包应用场景:
setTimeout
	<script>
      // 原生setTimeout传递的第一个函数不能带参数
      setTimeout(function(param) {
         alert(param)
      }, 1000)   
      // 通过闭包可以实现传参效果
      function func(param) {
         return function() {
            alert(param)
         }
      }
      var f1 = func(1);
      setTimeout(f1, 1000);
   </script>
回调
    <body>
       <p>哈哈哈</p>
       <h1>hhhhh</h1>
       <h2>qqqqq</h2>
       <a href="#" id="size-12">12</a>
       <a href="#" id="size-14">14</a>
       <a href="#" id="size-16">16</a>
       <script>
          function changeSize(size) {
             return function() {
                document.body.style.fontSize = size + 'px';
             }
          }
          var size12 = changeSize(12);
          var size14 = changeSize(14);
          var size16 = changeSize(16);
          console.log(changeSize(12))
          document.getElementById('size-12').onclick = size12;
          document.getElementById('size-14').onclick = size14;
          document.getElementById('size-16').onclick = size16;
       </script>
    </body>
2.js函数执行
在 ES5.1 里面函数是这样执行的（不讨论use strict和一些特殊情况，JS好复杂的），按如下顺序执行：
    a. 确定“this”的值 (确切的来说，this在JS里面不是一个变量名而是一个关键字)
    b. 创建一个新的作用域
    c. 处理形参/实参（没有定义过才声明，无论如何都重新赋值，没有对应实参则赋值为"undefined"）：
    对于每一个传入的实参，按照从左往右的顺序依次执行：如果对应的形参在本作用域中还没有定义，则在本作用域中声明形参，并赋值。如果已经定义过了，则重新给其赋值。(没有对应实参则赋值为"undefined"）（没有定义：就是“没有声明”的意思）
    d. 处理函数定义（没有定义过才声明，无论如何都重新赋值）：
    对该函数中所有的定义的函数，按照代码写的顺序依次执行：如果这个变量名在本作用域中还没有定义，则在本作用域中声明这个函数名，并且赋值为对应的函数，如果定义了这个变量，在可写的情况下重新给这个变量赋值为这个函数，否则抛出异常。
    e. 处理 "arguments"（没有定义过才声明和赋值）:
    如果在本作用域中没有定义 arguments，则在本作用域中声明arguments并给其赋值。
    f. 处理变量声明（没有定义过才声明，不赋值）：
    对于所有变量声明，按照代码写的顺序依次执行：如果在本作用域中没有定义这个变量，则在本作用域中声明这个变量，赋值为undefined
    g. 然后执行函数代码。（当然是去变量定义里面的 var 执行）
3.new一个对象的过程中发生了什么？
    a. 创建空对象；
    var obj = {};
    b. 设置新对象的constructor属性为构造函数的名称，设置新对象的__proto__属性指向构造函数的prototype对象；
    obj.__proto__ = ClassA.prototype;
    c. 使用新对象调用函数，函数中的this被指向新实例对象：
    ClassA.call(obj);//{}.构造函数();
    d. 将初始化完毕的新对象地址，保存到等号左边的变量中
4.宏任务和微任务
    macro-task(宏任务)：包括整体代码script，setTimeout，setInterval
    micro-task(微任务)：Promise，process.nextTick
5.防抖和节流
综合应用场景
防抖(debounce):就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。
    search搜索联想，用户在不断输入值时，用防抖来节约请求资源。
    window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次
节流(throttle):就是指连续触发事件但是在 n 秒中只执行一次函数。节流会稀释函数的执行频率。
    鼠标不断点击触发，mousedown(单位时间内只触发一次)
    监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断 所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。
防抖函数分为非立即执行版和立即执行版。
非立即执行版的意思是触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。
立即执行版的意思是触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果。
/**
 * @desc 函数防抖
 * @param func 函数
 * @param wait 延迟执行毫秒数
 * @param immediate true 表立即执行，false 表非立即执行
 */
function debounce(func,wait,immediate) {
    let timeout;

    return function () {
        let context = this;
        let args = arguments;

        if (timeout) clearTimeout(timeout);
        if (immediate) {
            var callNow = !timeout;
            timeout = setTimeout(() => {
                timeout = null;
            }, wait)
            if (callNow) func.apply(context, args)
        }
        else {
            timeout = setTimeout(function(){
                func.apply(context, args)
            }, wait);
        }
    }
}
所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。节流会稀释函数的执行频率。
对于节流，一般有两种方式可以实现，分别是时间戳版和定时器版。
	时间戳版的函数触发是在时间段内开始的时候
	定时器版的函数触发是在时间段内结束的时候。
/**
 * @desc 函数节流
 * @param func 函数
 * @param wait 延迟执行毫秒数
 * @param type 1 表时间戳版，2 表定时器版
 */
function throttle(func, wait ,type) {
    if(type===1){
        let previous = 0;
    }else if(type===2){
        let timeout;
    }
    return function() {
        let context = this;
        let args = arguments;
        if(type===1){
            let now = Date.now();

            if (now - previous > wait) {
                func.apply(context, args);
                previous = now;
            }
        }else if(type===2){
            if (!timeout) {
                timeout = setTimeout(() => {
                    timeout = null;
                    func.apply(context, args)
                }, wait)
            }
        }
    }
}
6.数组的常用方法
改变原数组的方法
splice() 添加/删除数组元素
语法：arrayObject.splice(index,howmany,item1,.....,itemX)
参数:
   1.index：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。
   2.howmany：可选。要删除的项目数量。如果设置为 0，则不会删除项目。
   3.item1, ..., itemX：可选。向数组添加的新项目。
返回值: 如果有元素被删除,返回包含被删除项目的新数组。
sort() 数组排序
语法：arrayObject.sort(sortby)
参数:
   1.sortby	可选。规定排序顺序。必须是函数。。

返回值: 返回包排序后的新数组。
pop() 删除一个数组中的最后的一个元素
语法：arrayObject.pop()
参数:无

返回值: 返回被删除的元素。
shift() 删除数组的第一个元素
语法：arrayObject.shift()
参数:无

返回值: 返回被删除的元素。
push() 向数组的末尾添加元素
语法：arrayObject.push(newelement1,newelement2,....,newelementX)
参数:
   1.newelement1	必需。要添加到数组的第一个元素。
   2.newelement2	可选。要添加到数组的第二个元素。
   3.newelementX	可选。可添加若干个元素。

返回值: 返回被删除的元素。
unshift() 向数组的开头添加一个或更多元素
语法：arrayObject.unshift(newelement1,newelement2,....,newelementX)
参数:
   1.newelement1	必需。要添加到数组的第一个元素。
   2.newelement2	可选。要添加到数组的第二个元素。
   3.newelementX	可选。可添加若干个元素。

返回值: arrayObject 的新长度。。
reverse() 颠倒数组中元素的顺序
语法：arrayObject.reverse()
参数:无

返回值: 颠倒后的新数组。
copyWithin() 指定位置的成员复制到其他位置
语法：array.copyWithin(target, start = 0, end = this.length)
参数:
   1.target（必需）：从该位置开始替换数据。如果为负值，表示倒数。
   2.start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。
   3.end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。

返回值: 返回当前数组。
fill() 填充数组
语法：array.fill(value, start, end)
参数:
   1.value	必需。填充的值。
   2.start	可选。开始填充位置。
   3.end	可选。停止填充位置 (默认为 array.length)

返回值: 返回当前数组。

不改变原数组的方法
slice() 浅拷贝数组的元素
语法：array.slice(begin, end);
参数:
   1.begin(可选): 索引数值,接受负值，从该索引处开始提取原数组中的元素,默认值为0。
   2.end(可选):索引数值(不包括),接受负值，在该索引处前结束提取原数组元素，默认值为数组末尾(包括最后一个元素)。

返回值: 返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，且原数组不会被修改。
join() 数组转字符串
语法：array.join(str)
参数:
   1.str(可选): 指定要使用的分隔符，默认使用逗号作为分隔符。

返回值: 返回生成的字符串。
concat() 合并两个或多个数组
语法：var newArr =oldArray.concat(arrayX,arrayX,......,arrayX)
参数:
   1.arrayX（必须）：该参数可以是具体的值，也可以是数组对象。可以是任意多个。

返回值: 返回返回合并后的新数组。
indexOf() 查找数组是否存在某个元素
语法：array.indexOf(searchElement,fromIndex)
参数:
   1.searchElement(必须):被查找的元素
   2.fromIndex(可选):开始查找的位置(不能大于等于数组的长度，返回-1)，接受负值，默认值为0。

返回值: 返回下标
lastIndexOf() 查找指定元素在数组中的最后一个位置
语法：arr.lastIndexOf(searchElement,fromIndex)
参数:
   1.searchElement(必须): 被查找的元素
   2.fromIndex(可选): 逆向查找开始位置，默认值数组的长度-1，即查找整个数组。

返回值: 方法返回指定元素,在数组中的最后一个的索引，如果不存在则返回 -1。（从数组后面往前查找）
includes() 查找数组是否包含某个元素
语法：array.includes(searchElement,fromIndex=0)
参数:
   1.searchElement(必须):被查找的元素
   2.fromIndex(可选):默认值为0，参数表示搜索的起始位置，接受负值。正值超过数组长度，数组不会被搜索，返回false。负值绝对值超过长数组度，重置从0开始搜索。

返回值: 返回布尔
7.立即执行函数
声明一个匿名函数，马上调用这个匿名函数。目的是保护内部变量不受污染。
(function(n1, n2) {
    console.log("这是匿名函数的自执行的第一种写法，结果为:" + (n1 + n2))
})(10, 100);
(function start(n1, n2) {
    console.log("这是函数声明方式的自执行的第一种写法，结果为:" + (n1 + n2))
})(10, 100);
(function(n1, n2) {
    console.log("这是匿名函数的自执行的第二种写法，结果为：" + (n1 + n2))
}(10, 100));
(function start(n1, n2) {
    console.log("这是函数声明方式的自执行的第二种写法，结果为：" + (n1 + n2))
}(10, 100));
8.js原型和原型链
每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念。

关系：instance.constructor.prototype = instance.proto

特点：JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本，当我们修改原型时，与之相关的对象也会继承这一改变。当我们需要一个属性时，JavaScript引擎会先看当前对象中是否有这个属性，如果没有的话，就会查找它的prototype对象是否有这个属性，如此递推下去，一致检索到Object内建对象。
function Func(){}
Func.prototype.name = "汪某";
Func.prototype.getInfo = function() {
   return this.name;
}
var person = new Func();
console.log(person.getInfo());//"汪某"
console.log(Func.prototype);//Func { name = "汪某", getInfo = function() }
9.js中call,apple,bind
百度JavaScript中call,apply,bind方法的总结。
10.Promise
一句话概括Promise：Promise对象用于异步操作，它表示一个尚未完成且预计在未来完成的异步操作。

promise是用来解决两个问题的：

回调地狱，代码难以维护，常常第一个的函数的输出是第二个函数的输入这种现象
promise可以支持多个并发的请求，获取并发请求中的数据
这个promise可以解决异步的问题，本身不能说promise是异步的
/*Promise 的简单实现*/

class MyPromise {
    constructor(fn) {
        this.resolvedCallbacks = [];
        this.rejectedCallbacks = [];
        this.state = "PADDING";
        this.value = "";
        fn(this.resolve.bind(this), this.reject.bind(this));
    }
    resolve(value) {
        if (this.state === "PADDING") {
            this.state = "RESOLVED";
            this.value = value;
            this.resolvedCallbacks.forEach(cb => cb());
        }
    }
    reject(value) {
        if (this.state === "PADDING") {
            this.state = "REJECTED";
            this.value = value;
            this.rejectedCallbacks.forEach(cb => cb());
        }
    }
    then(resolve = function() {}, reject = function() {}) {
        if (this.state === "PADDING") {
            this.resolvedCallbacks.push(resolve);
            this.rejectedCallbacks.push(reject);
        }
        if (this.state === "RESOLVED") {
            resolve(this.value);
        }
        if (this.state === "REJECTED") {
            reject(this.value);
        }
    }
}
11.async/await
如何使用 Async 函数
async function timeout(ms) {
  await new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}

async function asyncPrint(value, ms) {
  await timeout(ms);
  console.log(value);
}

asyncPrint('hello world', 50);
上面代码指定50毫秒以后，输出hello world。进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。

待补充。。。
12.深拷贝,浅拷贝
浅拷贝和深拷贝都只针对于引用数据类型，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存；但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象；

区别：浅拷贝只复制对象的第一层属性、深拷贝可以对对象的属性进行递归复制；
```

```
浅拷贝的实现方式
1.自定义函数
function simpleCopy (initalObj) {
   var obj = {};
   for ( var i in initalObj) {
    obj[i] = initalObj[i];
   }
   return obj;
}
2.ES6 的 Object.assign()
let newObj = Object.assign({}, obj);
3.ES6 的对象扩展
let newObj = {...obj};
深拷贝的实现方式

1.JSON.stringify 和 JSON.parse
用 JSON.stringify 把对象转换成字符串，再用 JSON.parse 把字符串转换成新的对象。
let newObj = JSON.parse(JSON.stringify(obj));
2.lodash
用 lodash 函数库提供的 _.cloneDeep 方法实现深拷贝。
var _ = require('lodash');
var newObj = _.cloneDeep(obj);
3.自己封装
function deepClone(obj) {
    let objClone = Array.isArray(obj) ? [] : {};
    if (obj && typeof obj === "object") {
        // for...in 会把继承的属性一起遍历
        for (let key in obj) {
            // 判断是不是自有属性，而不是继承属性
            if (obj.hasOwnProperty(key)) {
                //判断ojb子元素是否为对象或数组，如果是，递归复制
                if (obj[key] && typeof obj[key] === "object") {
                    objClone[key] = this.deepClone(obj[key]);
                } else {
                    //如果不是，简单复制
                    objClone[key] = obj[key];
                }
            }
        }
    }
    return objClone;
}
13.跨域
跨域需要针对浏览器的同源策略来理解，同源策略指的是请求必须是同一个端口，同一个协议，同一个域名，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。

受浏览器同源策略的影响，不是同源的脚本不能操作其他源下面的对象。想要操作另一个源下的对象是就需要跨域。
jsonp
iframe
跨域资源共享(CORS)
nginx 代理跨域
14.for in和for of
for in
1.一般用于遍历对象的可枚举属性。以及对象从构造函数原型中继承的属性。对于每个不同的属性，语句都会被执行。
2.不建议使用for in 遍历数组，因为输出的顺序是不固定的。
3.如果迭代的对象的变量值是null或者undefined, for in不执行循环体，建议在使用for in循环之前，先检查该对象的值是不是null或者undefined
for of
1.for…of 语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句
遍历对象
var s = {
    a: 1,
    b: 2,
    c: 3
}
var s1 = Object.create(s);
for (var prop in s1) {
    console.log(prop); //a b c
    console.log(s1[prop]); //1 2 3
}
for (let prop of s1) {
    console.log(prop); //报错如下 Uncaught TypeError: s1 is not iterable
}
for (let prop of Object.keys(s1)) {
    console.log(prop); // a b c
    console.log(s1[prop]); //1 2 3
}
15.如何阻止冒泡？
冒泡型事件：事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。

w3c的方法是e.stopPropagation()，IE则是使用e.cancelBubble = true。
//阻止冒泡行为
function stopBubble(e) {
//如果提供了事件对象，则这是一个非IE浏览器
if ( e && e.stopPropagation )
    //因此它支持W3C的stopPropagation()方法
    e.stopPropagation();
else 
    //否则，我们需要使用IE的方式来取消事件冒泡
    window.event.cancelBubble = true;
}
16.如何阻止默认事件？
w3c的方法是e.preventDefault()，IE则是使用e.returnValue = false
//阻止浏览器的默认行为
function stopDefault( e ) {
    //阻止默认浏览器动作(W3C)
    if ( e && e.preventDefault )
        e.preventDefault();
    //IE中阻止函数器默认动作的方式
    else 
        window.event.returnValue = false;
    return false;
}
17.var let const
//变量提升
console.log(a);  // undefined
console.log(b);  // 报错
console.log(c);  // 报错
var a = 1;
let b = 2;
const c = 3;

// 全局声明
console.log(window.a) //  1

// 重复声明
let b  = 200;//报错
其实这里很容易理解，var是可以变量提升的。而let和const是必须声明后才能调用的。对于let和const来说，这里就是暂缓性死区。
```

```
18.Class
es6新增的Class其实也是语法糖，js底层其实没有class的概念的，其实也是原型继承的封装。
class People {
    constructor(props) {
        this.props = props;
        this.name = '汪某';
    }
    callMyName() {
        console.log(this.name);
    }
}
class Name extends People { // extends 其实就是继承了哪个类
    constructor(props) {
        //  super相当于 把类的原型拿过来
        //  People.call(this, props)
        super(props)
    }
    callMyApple() {
        console.log('我是汪某！')
    }
}

let a = new Name('啊啊啊')
a.callMyName(); //汪某
a.callMyApple(); // 我是汪某！
19.Set
Set数据结构类似数组，但所有成员的值唯一。
let a = new Set();
[1,2,2,1,3,4,5,4,5].forEach(x=>a.add(x));
for(let k of a){
    console.log(k)
};
// 1 2 3 4 5
基本使用
let a = new Set([1,2,3,3,4]);
[...a]; // [1,2,3,4]
a.size; // 4

// 数组去重
[...new Set([1,2,3,4,4,4])];// [1,2,3,4]
方法:
add(value)：添加某个值，返回 Set 结构本身。
delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
has(value)：返回一个布尔值，表示该值是否为Set的成员。
clear()：清除所有成员，没有返回值。
let a = new Set();
a.add(1).add(2); // a => Set(2) {1, 2}
a.has(2);        // true
a.has(3);        // false
a.delete(2);     // true  a => Set(1) {1}
a.clear();       // a => Set(0) {}
20.Map
Map结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。
let a = new Map();
let b = {name: 'leo' };
a.set(b,'my name'); // 添加值
a.get(b);           // 获取值
a.size;      // 获取总数
a.has(b);    // 查询是否存在
a.delete(b); // 删除一个值
a.clear();   // 清空所有成员 无返回
基本使用:
传入数组作为参数，指定键值对的数组。
let a = new Map([
    ['name','wzx'],
    ['age',23]
])
如果对同一个键多次赋值，后面的值将覆盖前面的值。
let a = new Map();
a.set(1,'aaa').set(1,'bbb');
a.get(1); // 'bbb'
如果读取一个未知的键，则返回undefined。
new Map().get('asdsad'); // undefined
同样的值的两个实例，在 Map 结构中被视为两个键。
let a = new Map();
let a1 = ['aaa'];
let a2 = ['aaa'];
a.set(a1,111).set(a2,222);
a.get(a1); // 111
a.get(a2); // 222
方法

keys()：返回键名的遍历器。
values()：返回键值的遍历器。
entries()：返回所有成员的遍历器。
forEach()：遍历 Map 的所有成员。
let a = new Map([
    ['name', 'leo'],
    ['age', 18]
])
for (let i of a.keys()) {
    console.log(i)
};
//name
//age

for (let i of a.values()) {
    console.log(i)
};
//leo
//18

for (let i of a.entries()) {
    console.log(i)
};
//["name", "leo"]

a.forEach((v, k, m) => {
    console.log(`key:${k},value:${v},map:${m}`)
})
//["age", 18]
三。手撸代码
1.实现一个new操作符
function New(func) {
    var res = {};
    if (func.prototype !== null) {
        res.__proto__ = func.prototype;
    }
    var ret = func.apply(res, Array.prototype.slice.call(arguments, 1));
    if ((typeof ret === "object" || typeof ret === "function") && ret !== null) {
        return;
        ret;
    }
    return;
    res;
}
var obj = New(A, 1, 2);
// equals to
var obj = new A(1, 2);
2.实现一个call或apply
call
Function.prototype.call2 = function (context) {
    var context = context || window;
    context.fn = this;

    var args = [];
    for(var i = 1, len = arguments.length; i < len; i++) {
        args.push('arguments[' + i + ']');
    }

    var result = eval('context.fn(' + args +')');

    delete context.fn
    return result;
}
apply
Function.prototype.apply2 = function (context, arr) {
    var context = Object(context) || window;
    context.fn = this;

    var result;
    if (!arr) {
        result = context.fn();
    }
    else {
        var args = [];
        for (var i = 0, len = arr.length; i < len; i++) {
            args.push('arr[' + i + ']');
        }
        result = eval('context.fn(' + args + ')')
    }

    delete context.fn
    return result;
}
参考文献：JavaScript深入之call和apply的模拟实现
3.实现一个Function.bind
Function.prototype.bind2 = function (context) {
    if (typeof this !== "function") {
      throw new Error("Function.prototype.bind - what is trying to be bound is not callable");
    }
    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);
    var fNOP = function () {};
    var fbound = function () {
        self.apply(this instanceof self ? this : context, args.concat(Array.prototype.slice.call(arguments)));
    }
    fNOP.prototype = this.prototype;
    fbound.prototype = new fNOP();
    return fbound;
}
参考文献：JavaScript深入之bind的模拟实现
4.实现一个继承
function Parent(name) {
    this.name = name;
}

Parent.prototype.sayName = function() {
    console.log('parent name:', this.name);
}

function Child(name, parentName) {
    Parent.call(this, parentName);
    this.name = name;
}

function create(proto) {
    function F() {}
    F.prototype = proto;
    return new F();
}
Child.prototype = create(Parent.prototype);
Child.prototype.sayName = function() {
    console.log('child name:', this.name);
}

Child.prototype.constructor = Child;
var parent = new Parent('汪某');
parent.sayName();// parent name: 汪某
var child = new Child('son', '汪某');
5.5、手写一个Promise(中高级必考)
function myPromise(constructor) {
    let self = this;
    self.status = "pending"
        //定义状态改变前的初始状态
    self.value = undefined;
    //定义状态为resolved的时候的状态
    self.reason = undefined;
    //定义状态为rejected的时候的状态
    function resolve(value) {
        //两个==="pending"，保证了状态的改变是不可逆的
        if (self.status === "pending") {
            self.value = value;
            self.status = "resolved";
        }
    }
    function reject(reason) {
        //两个==="pending"，保证了状态的改变是不可逆的
        if (self.status === "pending") {
            self.reason = reason;
            self.status = "rejected";
        }
    }
    //捕获构造异常
    try {
        constructor(resolve, reject);
    } catch (e) {
        reject(e);
    }
}

//同时，需要在 myPromise的原型上定义链式调用的 then方法：
myPromise.prototype.then = function(onFullfilled, onRejected) {
    let self = this;
    switch (self.status) {
        case "resolved":
            onFullfilled(self.value);
            break;
        case "rejected":
            onRejected(self.reason);
            break;
        default:
    }
}

//测试一下：
var p = new myPromise(function(resolve, reject) {
    resolve(1)
});
p.then(function(x) {
    console.log(x)
})
高级版请参考文献：史上最最最详细的手写Promise教程
6、手写防抖(Debouncing)和节流(Throttling)
// 防抖函数
function debounce(fn, wait = 50, immediate) {
    let timer;
    return function() {
        if (immediate) {
            fn.apply(this, arguments)
        }
        if (timer) clearTimeout(timer)
        timer = setTimeout(() => {
            fn.apply(this, arguments)
        }, wait)
    }
    // 节流函数
function throttle(fn, wait) {
    let prev = new Date();
    return function() {
        const args = arguments;
        const now = new Date();
        if (now - prev > wait) {
            fn.apply(this, args);
            prev = new Date();
        }
    }
}
7.手写一个JS深拷贝
function deepCopy(obj) {
    //判断是否是简单数据类型，
    if (typeof obj == "object") {
        //复杂数据类型
        var result = obj.constructor == Array ? [] : {};
        for (let i in obj) {
            result[i] = typeof obj[i] == "object" ? deepCopy(obj[i]) : obj[i];
        }
    } else {
        //简单数据类型 直接 == 赋值
        var result = obj;
    }
    return result;
}
四。Vue
1、Vue的双向数据绑定原理是什么？
vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。
//vue实现数据双向绑定的原理就是用Object.defineproperty()重新定义（set方法）对象设置属性值和（get方法）获取属性值的操纵来实现的。
//Object.property()方法的解释：Object.property(参数1，参数2，参数3)  返回值为该对象obj
//其中参数1为该对象（obj），参数2为要定义或修改的对象的属性名，参数3为属性描述符，属性描述符是一个对象，主要有两种形式：数据描述符和存取描述符。这两种对象只能选择一种使用，不能混合使用。而get和set属于存取描述符对象的属性。
//这个方法会直接在一个对象上定义一个新属性或者修改对象上的现有属性，并返回该对象。

<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
</head>
<body>
    <div id="myapp">
        <input v-model="message" /><br>
        <span v-bind="message"></span>
    </div>
    <script type="text/javascript">
        var model = {
            message: ""
        };
        var models = myapp.querySelectorAll("[v-model=message]");
        for (var i = 0; i < models.length; i++) {
            models[i].onkeyup = function() {
                model[this.getAttribute("v-model")] = this.value;
            }
        }
        // 观察者模式 / 钩子函数
        // defineProperty 来定义一个对象的某个属性
        Object.defineProperty(model, "message", {
            set: function(newValue) {
                var binds = myapp.querySelectorAll("[v-bind=message]");
                for (var i = 0; i < binds.length; i++) {
                    binds[i].innerHTML = newValue;
                };
                var models = myapp.querySelectorAll("[v-model=message]");
                for (var i = 0; i < models.length; i++) {
                    models[i].value = newValue;
                };
                this.value = newValue;
            },
            get: function() {
                return this.value;
            }
        })
</script>
</body>
</html>
2.请详细说下你对vue生命周期的理解？
总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后

beforeCreate 创建前执行（vue实例的挂载元素$el和数据对象data都为undefined，还未初始化）
created 完成创建 （完成了data数据初始化，el还未初始化）
beforeMount 载入前（vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。）
mounted 载入后html已经渲染(vue实例挂载完成，data.message成功渲染。)
beforeUpdate 更新前状态（view层的数据变化前，不是data中的数据改变前）
updated 更新状态后
beforeDestroy 销毁前
destroyed 销毁后 （在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在）
说一下每一个阶段可以做的事情

beforeCreate:可以在这里加一个loading事件，在加载实例时触发。
created:初始化完成时的事件写这里，如果这里结束了loading事件，异步请求也在这里调用。
mounted:挂在元素，获取到DOM节点
updated:对数据进行处理的函数写这里。
beforeDestroy:可以写一个确认停止事件的确认框。
附上一张中文解析图
```

```
3.动态路由定义和获取
在 router 目录下的 index.js 文件中，对 path 属性加上 /:id。

使用 router 对象的 params.id 获取
4.vue-router 有哪几种导航钩子?
三种

1.全局导航钩子（跳转前进行判断拦截）
router.beforeEach(to, from, next),
router.beforeResolve(to, from, next),
router.afterEach(to, from ,next)
2.组件内钩子
beforeRouteEnter
beforeRouteUpdate
beforeRouteLeave
3.单独路由独享组件
beforeEnter

5.组件之间的传值通信？
父组件向子组件传值：
    子组件在props中创建一个属性，用来接收父组件传过来的值；
    在父组件中注册子组件；
    在子组件标签中添加子组件props中创建的属性；
    把需要传给子组件的值赋给该属性
子组件向父组件传值：
    子组件中需要以某种方式（如点击事件）的方法来触发一个自定义的事件；
    将需要传的值作为$emit的第二个参数，该值将作为实参传给响应事件的方法；
    在父组件中注册子组件并在子组件标签上绑定自定义事件的监听。
6.vuex
是一个能方便vue实例及其组件传输数据的插件 方便传输数据，作为公共存储数据的一个库
state: 状态中心

mutations: 更改状态，同步的

actions: 异步更改状态

getters: 获取状态

modules: 将state分成多个modules，便于管理
应用场景：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车。

网上找的一个通俗易懂的了解vuex的例子
公司有个仓库

1.State（公司的仓库）

2.Getter（只能取出物品，包装一下，不能改变物品任何属性）

3.Muitation（仓库管理员，只有他可以直接存储到仓库）

4.Action（公司的物料采购员，负责从外面买东西和接货， 要往仓库存东西，告诉仓库管理员要存什么）

非常要注意的地方：只要刷新或者退出浏览器，仓库清空。
```

```
1.下面代码的输出是什么？
function sayHi() {
  console.log(name); //undefined
  console.log(age); //ReferenceError
  var name = "Lydia";
  let age = 21;
}
sayHi();

var关键字声明变量在创建阶段会被提升(JavaScript会在创建变量创建阶段为其分配内存空间),默认值为undefined,直到我们实际执行到使用该变量的行,我们还没有为name变量赋值,所以它仍然保持undefined;
let关键字(和const)声明的变量也会变量提升,但与var不同,初始化没有被提升;
在我们声明它们之前是不可访问的,这被称为“暂时性死区”;
当我们在声明变量之前尝试访问变量时,JavaScript会抛出一个ReferenceError;
* * *
2.下面代码的输出是什么？
let name = 'ConardLi'
{
  console.log(name) // Uncaught ReferenceError: name is not defined
  let name = 'code秘密花园'
}

let变量如果不存在变量提升, console.log(name) 会输出ConardLi,结果却抛出了ReferenceError,那么这很好的说明了,let也存在变量提升,但是它存在一个“暂时性死区”,在变量未初始化或赋值前不允许访问;
变量的赋值可以分为三个阶段:
	创建变量,在内存中开辟空间;
	初始化变量,将变量初始化为undefined;
	真正赋值;
关于let、var、function:
	let的「创建」过程被提升了,但是初始化没有提升;
	var 的「创建」和「初始化」都被提升了;
	function 的「创建」「初始化」和「赋值」都被提升了;
* * *
3.下面代码的输出是什么？
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1); //3 3 3
}
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1); //0 1 2
}

由于JavaScript的事件执行机制,setTimeout函数真正被执行时,循环已经走完;
由于第一个循环中的变量i是使用var关键字声明的,因此该值是全局的,在循环期间,我们每次使用一元运算符++都会将i的值加1,因此在第一个例子中,当调用setTimeout函数时,i已经被赋值为3;
在第二个循环中,使用let关键字声明变量,let和const关键字声明的变量是具有块作用域的,在每次迭代期间,i将被创建为一个新值,并且每个值都会存在于循环内的块级作用域,是一个独立的个体;
* * *
4.下面代码的输出是什么?
const shape = {
  radius: 10,
  diameter() {
    return this.radius * 2;
  },
  perimeter: () => 2 * Math.PI * this.radius
};
shape.diameter(); //20
shape.perimeter(); //NaN

diameter是普通函数,perimeter是箭头函数;
对于箭头函数,this指向是它所在上下文的环境,与普通函数不同,这意味着当我们调用perimeter时,它不是指向shape对象,而是指其定义时的环境（window）,没有值radius属性,返回undefined;
* * *
5.下面代码的输出是什么?
+true; //1
!"Lydia"; //false

一元加号会尝试将boolean类型转换为数字类型,true被转换为1,false被转换为0;
字符串'Lydia'是一个真值,我们实际上要问的是“这个真值是假的吗？”,这会返回false;
* * *
6.哪个选项是不正确的? (A)
const bird = {
  size: "small"
};
const mouse = {
  name: "Mickey",
  small: true
};

A: mouse.bird.size
B: mouse[bird.size]
C: mouse[bird["size"]]
D: All of them are valid

在JavaScript中,所有对象键都是字符串（除了Symbol）,尽管有时我们可能不会给定字符串类型,但它们总是被转换为字符串;
JavaScript解释语句,当我们使用方括号表示法时,它会看到第一个左括号[，然后继续，直到找到右括号],只有在那个时候,它才会对这个语句求值;
mouse [bird.size],首先它会对bird.size求值,得到small,mouse [“small”]返回true;
但是,使用点表示法,这不会发生,mouse没有名为bird的键,这意味着mouse.bird是undefined,然后我们使用点符号来询问size: mouse.bird.size,由于mouse.bird是undefined,我们实际上是在询问undefined.size,这是无效的,并将抛出Cannot read property "size" of undefined。
* * *
7.下面代码的输出是什么?
let c = { greeting: "Hey!" };
let d;
d = c;
c.greeting = "Hello";
console.log(d.greeting); //Hello

在JavaScript中,当设置它们彼此相等时,所有对象都通过引用进行交互;
首先,变量c为对象保存一个值,之后,我们将d指定为c与对象相同的引用,更改一个对象时,可以更改所有对象;
* * *
8.下面代码的输出是什么?
let a = 3;
let b = new Number(3);
let c = 3;
console.log(a == b); //true
console.log(a === b); //false
console.log(b === c); //false

new Number（）是一个内置的构造函数,虽然它看起来像一个数字,但它并不是一个真正的数字: 它有一堆额外的功能,是一个对象; == 会引发隐式类型转换,右侧的对象类型会自动拆箱为Number类型,然而当我们使用 === 操作符时,类型和值都需要相等,new Number()不是一个数字,是一个对象类型,两者都返回 false;
* * *
9.下面代码的输出是什么? // TypeError
class Chameleon {
  static colorChange(newColor) {
    this.newColor = newColor;
  }
  constructor({ newColor = "green" } = {}) {
    this.newColor = newColor;
  }
}
const freddie = new Chameleon({ newColor: "purple" });
freddie.colorChange("orange");

colorChange方法是静态的,静态方法仅在创建它们的构造函数中存在,并且不能传递给任何子级;
由于freddie是一个子级对象,函数不会传递,所以在freddie实例上不存在freddie方法: 抛出TypeError;
* * *
10.下面代码的输出是什么?
let greeting;
greetign = {}; // Typo!
console.log(greetign); //{}

控制台会输出空对象,因为我们刚刚在全局对象上创建了一个空对象,当我们错误地将greeting输入为greetign时,JS解释器实际上在浏览器中将其视为global.greetign = {}（或window.greetign = {}）;
为了避免这种情况,我们可以使用“use strict”,这可以确保在将变量赋值之前必须声明变量;
* * *
11.当我们这样做时会发生什么? // Nothing,this is totally fine!
function bark() {
  console.log("Woof!");
}
bark.animal = "dog";

这在JavaScript中是可能的,因为函数也是对象（原始类型之外的所有东西都是对象）;
函数是一种特殊类型的对象,您自己编写的代码并不是实际的函数,该函数是具有属性的对象,此属性是可调用的;
* * *
12.下面代码的输出是什么?
function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}
const member = new Person("Lydia", "Hallie");
Person.getFullName = () => this.firstName + this.lastName;
console.log(member.getFullName()); //TypeError

您不能像使用常规对象那样向构造函数添加属性,如果要一次向所有对象添加功能,则必须使用原型,所以在这种情况下应该这样写:
Person.prototype.getFullName = function () {
  return `${this.firstName} ${this.lastName}`;
}
这样会使member.getFullName()是可用的,为什么样做是对的,假设我们将此方法添加到构造函数本身,也许不是每个Person实例都需要这种方法,这会浪费大量内存空间,因为它们仍然具有该属性,这占用了每个实例的内存空间,相反,如果我们只将它添加到原型中,我们只需将它放在内存中的一个位置,但它们都可以访问它！
* * *
13.下面代码的输出是什么?
function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}
const lydia = new Person("Lydia", "Hallie");
const sarah = Person("Sarah", "Smith");
console.log(lydia); //Person {firstName: "Lydia", lastName: "Hallie"}
console.log(sarah); //undefined

对于sarah,我们没有使用new关键字,使用new时,它指的是我们创建的新空对象,如果你不添加new它指的是全局对象;
我们指定了this.firstName等于'Sarah和this.lastName等于Smith,我们实际做的是定义global.firstName ='Sarah'和global.lastName ='Smith,sarah本身的返回值是undefined;
* * *
14.事件传播的三个阶段是什么？
捕获 > 目标 > 冒泡
* * *
15.所有对象都有原型? 错误
除基础对象外,所有对象都有原型;
基础对象可以访问某些方法和属性,例如: toString,这就是您可以使用内置JavaScript方法的原因,所有这些方法都可以在原型上找到,虽然JavaScript无法直接在您的对象上找到它,但它会沿着原型链向下寻找并在那里找到它,这使您可以访问它;
基础对象指原型链终点的对象,基础对象的原型是null;
* * *
16.下面代码的输出是什么?
function sum(a, b) {
  return a + b; //"12"
}
sum(1, "2");

JavaScript是一种动态类型语言: 我们没有指定某些变量的类型,在您不知情的情况下,值可以自动转换为另一种类型,称为隐式类型转换,强制从一种类型转换为另一种类型;
在此示例中,JavaScript将数字1转换为字符串,以使函数有意义并返回值,在让数字类型（1）和字符串类型（'2'）相加时,该数字被视为字符串,所以这里发生的是“1”+“2”返回“12”;
* * *
17.下面代码的输出是什么?
let number = 0;
console.log(number++); //0
console.log(++number); //2
console.log(number); //2
* * *
18.下面代码的输出是什么? //["", "is", "years old"] Lydia 21
function getPersonInfo(one, two, three) {
  console.log(one); 
  console.log(two);
  console.log(three);
}
const person = "Lydia";
const age = 21;
getPersonInfo`${person} is ${age} years old`;

如果使用标记的模板字符串,则第一个参数的值始终是字符串值的数组,其余参数获取传递到模板字符串中的表达式的值;
* * *
19.下面代码的输出是什么? //Hmm.. You don't have an age I guess
function checkAge(data) {
  if (data === { age: 18 }) {
    console.log("You are an adult!");
  } else if (data == { age: 18 }) {
    console.log("You are still an adult.");
  } else {
    console.log(`Hmm.. You don't have an age I guess`);
  }
}
checkAge({ age: 18 });

在比较相等性,原始类型通过它们的值进行比较,而对象通过它们的引用进行比较;
JavaScript检查对象是否具有对内存中相同位置的引用;
我们作为参数传递的对象和我们用于检查相等性的对象在内存中位于不同位置,所以它们的引用是不同的;
这就是为什么{ age: 18 } === { age: 18 } 和 { age: 18 } == { age: 18 } 返回 false的原因;
* * *
20.下面代码的输出是什么? //"object"
function getAge(...args) {
  console.log(typeof args);
}
getAge(21);

扩展运算符（... args）返回一个带参数的数组,数组是一个对象,因此typeof args返回object;
* * *
21.下面代码的输出是什么? //ReferenceError
function getAge() {
  "use strict";
  age = 21;
  console.log(age);
}
getAge();

使用“use strict”,可以确保不会意外地声明全局变量,我们从未声明变量age,因为我们使用use strict,它会引发一个ReferenceError,如果我们不使用“use strict”,它就会起作用,因为属性age会被添加到全局对象中;
* * *
22.下面代码的输出是什么? //105
const sum = eval("10*10+5");

eval会为字符串传递的代码求值,如果它是一个表达式,就像在这种情况下一样,它会计算表达式,表达式为10 * 10 + 5计算得到105;
* * *
23.cool_secret可以访问多长时间? //用户关闭选项卡时。
sessionStorage.setItem("cool_secret", 123);

关闭选项卡后,将删除存储在sessionStorage中的数据;
如果使用localStorage,数据将永远存在,除非例如调用localStorage.clear();
* * *
24.下面代码的输出是什么?
var num = 8;
var num = 10;
console.log(num); //10

使用var关键字,您可以用相同的名称声明多个变量,然后变量将保存最新的值;
您不能使用let或const来实现这一点,因为它们是块作用域的;
* * *
25.下面代码的输出是什么? //true true false true
const obj = { 1: "a", 2: "b", 3: "c" };
const set = new Set([1, 2, 3, 4, 5]);
obj.hasOwnProperty("1");
obj.hasOwnProperty(1);
set.has("1");
set.has(1);

所有对象键（不包括Symbols）都会被存储为字符串,即使你没有给定字符串类型的键,这就是为什么obj.hasOwnProperty（'1'）也返回true;
上面的说法不适用于Set,在我们的Set中没有“1”: set.has（'1'）返回false;它有数字类型1,set.has（1）返回true;
* * *
26.下面代码的输出是什么?
const obj = { a: "one", b: "two", a: "three" };
console.log(obj); //{ a: "three", b: "two" }

如果对象有两个具有相同名称的键,则将替前面的键,它仍将处于第一个位置,但具有最后指定的值;
* * *
27.JavaScript全局执行上下文为你创建了两个东西:全局对象和this关键字?
对,基本执行上下文是全局执行上下文: 它是代码中随处可访问的内容;
* * *
28.下面代码的输出是什么? //1 2 4
for (let i = 1; i < 5; i++) {
  if (i === 3) continue;
  console.log(i);
}

如果某个条件返回true,则continue语句跳过迭代;
* * *
29.下面代码的输出是什么? //"Just give Lydia pizza already!"
String.prototype.giveLydiaPizza = () => {
  return "Just give Lydia pizza already!";
};
const name = "Lydia";
name.giveLydiaPizza();

String是一个内置的构造函数,我们可以为它添加属性,我刚给它的原型添加了一个方法,原始类型的字符串自动转换为字符串对象,由字符串原型函数生成,因此,所有字符串（字符串对象）都可以访问该方法;
当使用基本类型的字符串调用giveLydiaPizza时,实际上发生了下面的过程:
	创建一个String的包装类型实例;
	在实例上调用substring方法;
	销毁实例;
* * *
30.下面代码的输出是什么?
const a = {};
const b = { key: "b" };
const c = { key: "c" };
a[b] = 123;
a[c] = 456;
console.log(a[b]); //456

对象键自动转换为字符串,我们试图将一个对象设置为对象a的键,其值为123;
但是,当对象自动转换为字符串化时,它变成了[Object object],所以我们在这里说的是a["Object object"] = 123,然后,我们可以尝试再次做同样的事情,c对象同样会发生隐式类型转换,那么 a["Object object"] = 456。
然后,我们打印a[b],它实际上是 a["Object object"],我们将其设置为456,因此返回456;
* * *
31.下面代码的输出是什么? //First Third Second
const foo = () => console.log("First");
const bar = () => setTimeout(() => console.log("Second"));
const baz = () => console.log("Third");
bar();
foo();
baz();

我们有一个setTimeout函数并首先调用它,然而却最后打印了它;
这是因为在浏览器中,我们不只有运行时引擎,我们还有一个叫做WebAPI的东西,WebAPI为我们提供了setTimeout函数,例如DOM;
将callback推送到WebAPI后,setTimeout函数本身（但不是回调！）从堆栈中弹出;
* * *
32. 单击按钮时event.target是什么? //button
<div onclick="console.log('first div')">
  <div onclick="console.log('second div')">
    <button onclick="console.log('button')">
      Click!
    </button>
  </div>
</div>

导致事件的最深嵌套元素是事件的目标。 你可以通过event.stopPropagation停止冒泡
* * *
33.单击下面的html片段打印的内容是什么? //p div
<div onclick="console.log('div')">
  <p onclick="console.log('p')">
    Click here!
  </p>
</div>

如果我们单击p,我们会看到两个日志: p和div,在事件传播期间,有三个阶段: 捕获,目标和冒泡,默认情况下,事件处理程序在冒泡阶段执行（除非您将useCapture设置为true）,它从最深的嵌套元素向外延伸;
* * *
34.下面代码的输出是什么? //Lydia is 21 function
const person = { name: "Lydia" };
function sayHi(age) {
  console.log(`${this.name} is ${age}`);
}
sayHi.call(person, 21);
sayHi.bind(person, 21);

使用两者,我们可以传递我们想要this关键字引用的对象,但是, .call 方法会立即执行;
.bind方法会返回函数的拷贝值,但带有绑定的上下文,它不会立即执行;
* * *
35.下面代码的输出是什么? //"number"
function sayHi() {
  return (() => 0)();
}
typeof sayHi();

sayHi函数返回立即调用的函数（IIFE）的返回值,该函数返回0,类型为数字;
仅供参考: 只有7种内置类型: null，undefined，boolean，number，string，object和symbol;
function不是一个类型,因为函数是对象,它的类型是object;
* * *
36.下面这些值哪些是假值? //0, '', undefined
0;
new Number(0);
("");
(" ");
new Boolean(false);
undefined;

JavaScript中只有6个假值:
	undefined
	null
	NaN
	0
	'' (empty string)
	false
函数构造函数,如 new Number 和 new Boolean 都是真值;
* * *
37.下面代码的输出是什么?
console.log(typeof typeof 1); //"string"
typeof 1 返回 "number". typeof "number" 返回 "string"
* * *
38.下面代码的输出是什么? //[1, 2, 3, 7 x empty, 11]
const numbers = [1, 2, 3];
numbers[10] = 11;
console.log(numbers);

当你为数组中的元素设置一个超过数组长度的值时,JavaScript会创建一个名为“空插槽”的东西,这些位置的值实际上是undefined,但你会看到类似的东西:
[1, 2, 3, 7 x empty, 11]
这取决于你运行它的位置（每个浏览器有可能不同）
* * *
39.下面代码的输出是什么? //1 undefined 2
(() => {
  let x, y;
  try {
    throw new Error();
  } catch (x) {
    (x = 1), (y = 2);
    console.log(x);
  }
  console.log(x);
  console.log(y);
})();
catch块接收参数x,当我们传递参数时,这与变量的x不同,这个变量x是属于catch作用域的;
之后,我们将这个块级作用域的变量设置为1,并设置变量y的值,现在,我们打印块级作用域的变量x,它等于1;
在catch块之外,x仍然是undefined,而y是2,当我们想在catch块之外的console.log(x)时,它返回undefined,而y返回2;
* * *
40.JavaScript中的所有内容都是...
JavaScript只有原始类型和对象。
原始类型是boolean，null，undefined，bigint，number，string和symbol。
* * *
41.下面代码的输出是什么? //[1, 2, 0, 1, 2, 3]
[[0, 1], [2, 3]].reduce(
  (acc, cur) => {
    return acc.concat(cur);
  },
  [1, 2]
);
[1,2]是我们的初始值,这是我们开始执行reduce函数的初始值,以及第一个acc的值,在第一轮中,acc是[1,2],cur是[0,1],我们将它们连接起来,结果是[1,2,0,1];
然后,acc的值为[1,2,0,1],cur的值为[2,3],我们将它们连接起来,得到[1,2,0,1,2,3];
* * *
42.下面代码的输出是什么? //false false true
!!null;
!!"";
!!1;
null是假值, !null返回true, !true返回false;
""是假值, !""返回true, !true返回false;
1是真值, !1返回false, !false返回true;
* * *
43.setInterval方法的返回值什么? //一个唯一的id
它返回一个唯一的id,此id可用于使用clearInterval()函数清除该定时器;
* * *
44.下面代码的返回值是什么? //["L", "y", "d", "i", "a"]
[..."Lydia"];
字符串是可迭代的,扩展运算符将迭代的每个字符映射到一个元素;
```

```
js手写模板引擎
<script src="underscore.js"></script> //引入underscore以后,在全局就会多一个 _
<script type="text/html" id="tmp"> //dom节点
	<% for(var i = 0;i < users.length;i ++) {%>
		<li>
			<a href="<% = users[i].url %>">
				<% = users[i].name %>
			</a>
		</li>
	<% } %>
</script>
<script> //业务逻辑
	var oUl = document.getElementById('oUl');
	var tmp = document.getElementById('tmp');
	var data = {
		users: [{
			name: 'sxw',
			url: 'sxw.com'
		}, {
			name: 'kobe',
			url: 'kobe.com'
		}]
	}
	var compiler = _.template(tmp.innerHTML);
	var html = compiler(data);
	oUl.innerHTML = html;
</script>
```

```
思路:
模板字符串就是先给定一个空数组 var arr = [];
将所有需要编译成模板的东西进行push进这个空数组中:
	p.push('<li><a href="');
	p.push(users[i].url);
	...
将数组变成字符串: p.join("");
插入到oUl中: oUl.innerHTML = p.join("");
```

```
模板引擎的缺点: 1.seo不友好; 2.不是数据绑定; 3.性能问题;
```

```
html+css部分
-------------------
1.如何理解css盒模型？
盒模型分为IE盒模型和W3C标准盒模型;
	IE盒模型: 总宽度 = 内容宽度 = (content + padding + border)
	W3C标准盒模型: 总宽度 = 内容宽度(content) + padding + border
IE8+浏览器中用box-sizing控制需要使用哪个盒模型,默认为content-box(标准盒模型),border-box(IE盒模型);
若在IE6,7,8中DOCTYPE缺失则会触发IE盒模型;

2.什么是BFC？
BFC(Block Formatting Context) 块格式化上下文;
web页面中盒模型布局的CSS渲染模式,指一个独立的渲染区域;
形成BFC的条件:
	a.浮动元素; (float不为none)
	b.绝对定位元素; (position为absolute或fixed)
	c.行内块元素; (display: inline-block;)
	d.表格单元格: (display: table-cell;)
	e.overflow; (值不为visible)
	f.弹性盒子flex boxes; (display: flex或inline-flex)
	其中,最常见的是overflow: hidden; float: left/right; position: adsolute;也就是说每次看到这些属性的时候,就代表该元素已经创建了一个BFC了;
BFC的特性:
	a.内部的box会在垂直方向上一个接一个的放置; (BFC中有一个常规流)
	b.垂直方向上的距离由margin决定;
	c.bfc的区域不会与float的元素区域重叠;
	d.计算bfc的高度时,考略BFC所包含的所有元素,浮动元素也参与计算;
	e.bfc就是页面上的独立容器,容器里的子元素不会影响外元素;
	f.处于同一个BFC中的元素互相影响,可能会导致margin塌陷;
	
3.如何清除浮动？
不清浮动会导致高度塌陷: 父元素不写高度,子元素写了浮动后,父元素高度塌陷;
	a.clear清浮动(添加空div法): 在浮动元素下方添加空div,并给该元素写css样式
		{
			clear: both;
			height: 0;
			overflow: hidden;
		}
	b.给父级设置高度;
	c.给父级添加overflow: hidden清除浮动;
	d.after伪类清浮动;
	
4.用CSS画三角形？
	span{
		width: 0;
		height: 0;
		border: 100px solid black;
		border-left-color: red;
		border-top-color: transparent;
		border-right-color: transparent;
		border-bottom-color: transparent;
	}

5.CSS3实现0.5px的细线？
	.line{
		position: relative;
	}
	.line:after{
		content: '';
		position: absolute;
		left: 0;
		top: 0;
		width: 100%;
		height: 1px;
		background-color: #000000;
		-webkit-transform: scaleY(.5);
		transform: scaleY(.5);
	}
	<div class="line"></div>
知识点拓展:
CSS3属性transform详解:
	旋转: rotate;
	缩放: scale;
	倾斜: skew;
	移动: translate;
a.旋转 rotate
	transform: rotate(45deg); 正数顺时针旋转45度
b.缩放 scale
	transform: scale(0.5); transform: scale(0.5, 2);
	一个参数表示水平和垂直同时缩放该倍率;
	两个参数: 第一个参数水平方向的缩放倍率,第二个参数垂直方向的缩放倍率;
	transform: scaleX(2); 表示水平和垂直同时缩放该倍率;
    transform: scaleY(1.5); 表示水平和垂直同时缩放该倍率 
c.倾斜 skew
	transform: skew(30deg); transform: skew(30deg, 30deg);
	一个参数表示水平方向倾斜角度;
	两个参数: 第一个参数表示水平方向的倾斜角度,第二个参数表示垂直方向的倾斜角度;
	skew的默认原点transform-origin是这个物件的中心点;
d.移动 translate
	transform: translate(45px); transform: translate(45px, 150px);
	一个参数表示水平移动距离;
	两个参数: 第一个参数表示水平移动距离,第二个参数表示垂直移动距离;
基准点: transform-origin
没有使用transform-origin改变元素基点位置的情况下,transform进行的操作都是以元素自己中心位置进行变化的,但有时我们需要在不同的位置对元素进行这些操作,我们就可以使用transform-origin对元素进行基点位置改变,使元素基点不在中心位置,以达到你需要的基点位置。
transform-origin(X,Y);	(X,Y可以是字符参数值left,center,right)

6.css实现三栏布局？
	a.左右固定,中间自适应;
	flex方法
	<style>
      .box{
         display: flex;
         justify-content: center;
         height: 200px;
      }
      .left{
         width: 200px;
         background-color: red;
         height: 100%;
      }
      .content{
         background-color: yellow;
         flex: 1;
         height: 100%;
      }
      .right{
         width: 200px;
         background-color: green;
         height: 100%;
      }
   </style>
   <div class="box">
      <div class="left"></div>
      <div class="content"></div>
      <div class="right"></div>
   </div>
   
   b.绝对定位方式
   <style>
      .box{
         position: relative;
         height: 200px;
      }
      .left{
         width: 200px;
         background-color: red;
         position: absolute;
         left: 0;
         top: 0;
         height: 100%;
      }
      .content{
         background-color: yellow;
         position: absolute;
         left: 200px;
         right: 200px;
         height: 100%;
      }
      .right{
         width: 200px;
         background-color: green;
         position: absolute;
         right: 0;
         height: 100%;
      }
   </style>
   <div class="box">
      <div class="left"></div>
      <div class="content"></div>
      <div class="right"></div>
   </div>
   
   c.浮动方式
   <style>
      .box{
         height: 200px;
      }
      .left{
         width: 200px;
         background-color: red;
         float: left;
         height: 100%;
      }
      .content{
         background-color: yellow;
         height: 100%;
      }
      .right{
         width: 200px;
         background-color: green;
         float: right;
         height: 100%;
      }
   </style>
   <div class="box">
      <div class="left"></div>
      <div class="right"></div>
      <div class="content"></div>
   </div>

7.让一个div垂直居中
	a.宽高已知
	<style>
      .box{
         width: 400px;
         height: 200px;
         position: relative;
         background: red;
      }
      .content{
         width: 200px;
         height: 100px;
         position: absolute;
         top: 50%;
         left: 50%;
         margin-left: -100px;
         margin-top: -50px;
         background: green;
      }
   </style>
      <div class="box">
      <div class="content"></div>
   </div>
   b.宽高未知;
   <style>
      .box{
         width: 400px;
         height: 200px;
         position: relative;
         background: red;
      }
      .content{
         position: absolute;
         top: 50%;
         left: 50%;
         transform: translate(-50%, -50%);
         background: green;
      }
   </style>
      <div class="box">
      <div class="content"></div>
   </div>
   c.flex布局
   <style>
      .box{
         width: 400px;
         height: 200px;
         background: red;
         display: flex;
         justify-content: center;
         align-items: center;
      }
      .content{
         width: 200px;
         height: 100px;
         background: green;
      }
   </style>
   <div class="box">
      <div class="content"></div>
   </div>
```

```
第一部分 JavaScript语言核心
第二章 词法结构
JavaScript是区分大小写的语言
//这里是单行注释
/*
*这里是多行注释
*/
所谓直接量,就是程序中直接使用的数据值。数字,字符串文本,布尔值,正则表达式,null
标识符就是一个名字,在JavaScript中,标识符用来对变量和函数进行命名,或者用做JavaScript代码中某些循环语句中的跳转位置的标记。JavaScript标识符必须以字母,下划线,美元符开始,其中数字是不允许作为首字母出现的。
保留字: JavaScript把一些标识符拿出来用做自己的关键字,因此就不能再再程序中把这些关键字用做标识符了。
JavaScript的数据类型分为两类:原始类型和对象类型;原始类型包括数字,字符串,布尔值,null,undefined
对象是属性的集合,每个属性都由名/值对;
JavaScript语言核心定义了其他三种有用的类:日期(Date)类定义了代表日期的对象;正则(RegExp)类定义了表示正则表达式(一种强大的模式匹配工具)的对象;错误(Error)类定义了那些表示JavaScript程序中运行时错误和语法错误的对象;
十六进制的直接量是指以"0x"或者"ox"为前缀,其后跟随十六进制数串的直接量。
八进制直接量以数字0开始,其后跟随一个由0~7之间的数字组成的序列。
Math.round(.6) //1 四舍五入
Math.ceil(.6) //1 向上取整
Math.floor(.6) //0 向下取整
Math.abs(-5) //5 取绝对值
Math.max(x,y,z) //返回最大值
Math.min(x,y,z) //返回最小值
Math.random() //返回一个大于等于0小于1的随机数

零除以零是没有意义的,结果返回NaN;无穷大除以无穷大,给任意负数作开方运算或算术运算符与不是数字或无法转换为数字的操作符一起使用时都将返回NaN;
var now = new Date(); //当前日期和时间
new Date().getFullYear();
new Date().getMonth(); //从0开始计数的月份
new Date().getDate(); //从1开始计数的天数
new Date().getDay(); //0代表星期天,5代表星期一
new Date().getHours(); //当地时间
字符串中换行用\表示一行的结束
\n 换行符
\r 回车符
\" 双引号
\' 单引号
\\ 反斜杠

var s = "hello,world";
s[0] //"h"
s[s.length-1] //"d"
s.charAt(0); //"h" 第一个字符
s.charAt(s.length-1); //"d" 最后一个字符
s.substring(1,4); //"ell" 第2~4个字符
s.slice(1,4); //"ell" 第2~4个字符
s.slice(-3); //"rld" 最后三个字符
s.indexOf("1"); //2 字符l首次出现的位置
s.lastIndexOf("l"); //10 字符l最后一次出现的位置
s.indexOf("l", 3); //3 在位置3及之后首次出现字符l的位置
s.splice(","); //["hello","world"] 以,分割子串
s.replace("h","H"); //"Hello,world" 全文字符替换
s.toUpperCase(); //“HELLO,WORLD"
注意:在JavaScript中字符串时固定不变的,类似replace()和toUpperCase()方法都返回新字符串,原字符串本身并没有发生改变;
下面这些转换为布尔值时为false: undefined null 0 -0 NaN ""
&& 当且仅当两个运作数都是真值时才返回true;
|| 如果两个操作数其中之一为真值就返回true;
```

```
第1章 JavaScript概述
JavaScript是面向Web的编程语言。前端开发工程师必须掌握的三种技能之一:描述网页内容的HTML,描述网页样式的CSS以及描述网页行为的JavaScript。JavaScript是一门高端的,动态的,弱类型的编程语言,非常适合面向对象和函数式的编程风格。JavaScript是由Web发展初期的网景公司创建,"JavaScript"是sun公司(现在的Oracle)的注册商标,用来特指网景(现在的Mozilla)对这门语言的实现。网景将这门语言作为标准提交给了ECMAScript——欧洲计算机制造协会,由于商标上的冲突,这门语言的标准版本改成了一个丑陋的名字"ECMAScript"。同样由于商标的冲突,微软对这门语言的实现版本取了一个广为人知的名字"Jscript"。实际上,几乎所有人都将这门语言叫做"JavaScript"。本书也仅仅使用"ECMAScript"来指代语言标准。当我们提到这门语言本身时,通常所指的语言版本是ECMAScript 3和ECMAScript 5(ECMAScript 4已经开发了数年,但由于太过庞大,从未发布过正式版本)。(JavaScript 1.5 == ECMAScript 3)。Google将它的JavaScript解释器叫做V8。通常每一种编程语言都有各自的开发平台,标准库或API函数,用来提供诸如基本输入输出的功能。JavaScript语言核心针对文本,数组,日期和正则表达式的操作定义了很多的API,但是这些API不包括输入输出功能。输入输出功能(类似网络,存储和图形相关的复杂特性)是由JavaScript所属的"宿主环境"提供的。这里所说的宿主环境通常是Web浏览器(第12章会介绍两个不基于Web浏览器的JavaScript宿主环境)。
1.1 JavaScript语言核心
JavaScript数据类型: Number, String, Boolean, Undefined, Null, Object;其中前5个是基本类型,而Object是引用类型。实际上Object还包含了其他更为具体的引用类型,如: Array, Function, Arguments, Date, RegExp, Error;
检测数据类型的方法,分别是typeof和Object.prototype.toString;
a)typeof
typeof操作符返回一个字符串,表示未经计算的操作符的类型,其使用方式是typeof operand或typeof(operand),operand是一个表达式,表示对象或原始值,其类型将被返回,返回值是表示其数据类型的字符串的小写形式。
--------------------------------------------------
console.log(typeof undefined);  // undefined
console.log(typeof null);  // object
console.log(typeof true);  // boolean
console.log(typeof 1);  // number
console.log(typeof 'xys');  // string
console.log(typeof new Object());  // object
console.log(typeof [1,2,3]);  // object
console.log(typeof function(){});  // function
console.log(typeof new Date(););  // object
console.log(typeof  /a/g);  // object
console.log(typeof new Error());  // object

var arg;
(function getArg(){
    arg=arguments;
})();
console.log(typeof arg);  // object
使用typeof方法来检测数据类型,基本类型大部分都能被准确检测并返回正确的字符串(除了Null类型返回Object字符串),而引用类型大部分都不能够被准确检测(除了Function类型能够准确返回function字符串之外,其他都是返回了object字符串)。所以,typeof方法并不能完全准确地检测出上述JavaScript中的12种数据类型。

b)Object.prototype.toString
Object.prototype.toString最终会返回形式如:[object,class]的字符串,class指代的是其检测出的数据类型,这个是我们判断数据类型的关键。

var toString=Object.prototype.toString;
console.log(toString.call(undefined));  // [object Undefined]
console.log(toString.call(null));  // [object Null]
console.log(toString.call(true));  // [object Boolean]
console.log(toString.call(1));  // [object Number]
console.log(toString.call('xys'));  // [object String]
console.log(toString.call(new Object()));  // [object Object]
console.log(toString.call([1,2,3]));  // [object Array]
console.log(toString.call(function(){}));  // [object Function]
console.log(toString.call(new Date()));  // [object Date]
console.log(toString.call(/a/g));  // [object RegExp]
console.log(toString.call(new Error()));  // [object Error]

(function getArg(){
    arg=arguments;
})();
console.log(toString.call(arg));  // [object Arguments]
可以看到,Object.prototype.toString返回的[object,class]字符串中,class准确地表示了各个数据地类型,与typeof不同的是,class所代表的数据类型字符串首字母是大写的,而不像typeof返回的是小写的字符串;
---------------------------------------------------------------------------------------
通过上述描述可知,typeof能够被用来检测除Null类型外的其他基本类型,并且能够检测出引用类型中Function数据类型,而Object.prototype.toString能够检测出所以的数据类型,所以我们可以结合这两个方法来实现一个JavaScript数据类型检测的终极方法:
/**
 * @desc 数据类型检测
 * @param obj 待检测的数据
 * @return {String} 类型字符串
 */
function type(obj) {
  return typeof obj !== "object" ? typeof obj : Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();
}
--------------------------------------------------------------------------------------
关于数据类型的单独检测
/**
 * @desc 是否是 Undefined 类型检测
 * @param obj 待检测的数据
 * @return {Boolean} 布尔值
 */
function isUndefined(obj) {
    return obj === void 0;
}
/**
 * @desc 是否是 Null 类型检测
 * @param obj 待检测的数据
 * @return {Boolean} 布尔值
 */
function isNull(obj) {
    return obj === null;
}
/**
 * @desc 是否是 Boolean 类型检测
 * @param obj 待检测的数据
 * @return {Boolean} 布尔值
 */
function isBoolean(obj) {
    return typeof(obj) === 'boolean';
}
/**
 * @desc 是否是 Number 类型检测
 * @param obj 待检测的数据
 * @return {Boolean} 布尔值
 */
function isNumber(obj) {
    return typeof(obj) === 'number';
}
/**
 * @desc 是否是 String 类型检测
 * @param obj 待检测的数据
 * @return {Boolean} 布尔值
 */
function isString(obj) {
    return typeof(obj) === 'string';
}
/**
 * @desc 是否是 Object 类型检测
 * @param obj 待检测的数据
 * @return {Boolean} 布尔值
 */
function isObject(obj) {
    return Object.prototype.toString.call(obj) === '[object Object]';
}
/**
 * @desc 是否是 Array 类型检测
 * @param obj 待检测的数据
 * @return {Boolean} 布尔值
 */
function isArray(obj){
    return Array.isArray?Array.isArray(obj):Object.prototype.toString.call(obj) === '[object Array]';
}
/**
 * @desc 是否是 Function 类型检测
 * @param obj 待检测的数据
 * @return {Boolean} 布尔值
 */
function isFunction(obj){
    return typeof(obj) === 'function';
}
/**
 * @desc 是否是 Date 类型检测
 * @param obj 待检测的数据
 * @return {Boolean} 布尔值
 */
function isDate(obj){
    return Object.prototype.toString.call(obj) === '[object Date]';
}
/**
 * @desc 是否是 RegExp 类型检测
 * @param obj 待检测的数据
 * @return {Boolean} 布尔值
 */
function isRegExp(obj){
    return Object.prototype.toString.call(obj) === '[object RegExp]';
}
/**
 * @desc 是否是 Error 类型检测
 * @param obj 待检测的数据
 * @return {Boolean} 布尔值
 */
function isError(obj){
    return Object.prototype.toString.call(obj) === '[object Error]';
}
/**
 * @desc 是否是 Arguments 类型检测
 * @param obj 待检测的数据
 * @return {Boolean} 布尔值
 */
function isArguments(obj){
    return Object.prototype.toString.call(obj) === '[object Arguments]';
}
--------------------------------------------------------------------------------------
数据类型检测的四种方式
一.typeof
使用typeof检测数据类型,首先返回的都是一个字符串,其次字符串中包含了对应的数据类型,例如: "number","string","boolean","undefined","function","object".
面试题:
console.log(typeof typeof typeof function () {}); // string
typeof的局限性: 不能具体的细分是数组还是正则,还是对象中其他的值,因为使用typeof检测数据类型,对于对象数据类型中的所有的值,最后返回的结果都是"object";
二.instanceof
var ary = [];
console.log(ary instanceof Array); // true
console.log(ary instanceof Object); // true

function fn() {}
console.log(fn instanceof Function); // true
console.log(fn instanceof Object); // true
只要在当前实例的原型链上用instanceof检测出来的结果都是true,所以在类的原型继承中,最后检测出来的结果未必是正确的,例如:
function Fn() {
}
Fn.prototype = new Array; // 原型继承：让子类的原型等于父类的一个实例
var f = new Fn;
console.log(f instanceof Array); // true
三.constructor
constructor即构造函数,作用和instanceof非常相似;
var obj = [];
console.log(obj.constructor === Array); // true
console.log(obj.constructor === RegExp); // false
constructor可以处理基本的数据类型的检测,但是当我们把类的原型进行重写,在重写的过程中,很有可能把之前的constructor给覆盖了,这样检测出来的结果就是不准确的。
function Fn() {
}
Fn.prototype = new Array;
var f = new Fn;
console.log(f.constructor); // Array
对于特殊的数据类型null和undefined,他们所属类型是Null和Undefined,但是浏览器把这两个类保护起来了,不允许在外面访问使用。
四.Object.prototype.toString.call()
Object.prototype.toString.call()是检测数据类型最准确最常用的方式,其原理为: 先获取Object原型上的toString方法,让方法执行,并且改变方法中的this关键字的指向;Object.prototype.toString.call()是返回当前方法的执行主体(方法中this)所属类的详细信息;
var obj = {name:'iceman'};
// toString中的this是obj，返回的是obj所属类的信息 --> "[object Object]"
// 第一个object代表当前实例是对象数据类型的（这个是固定死的）
// 第二个Object，代表的是obj所属的类是Object
console.log(obj.toString());

// toString中的this是Math，那么返回的是Math所属类的信息 --> "[object Math]"
console.log(Math.toString());
var ary = [];
console.log(Object.prototype.toString.call(ary)); // --> "[object Array]"
console.log(Object.prototype.toString.call(/^$/)); // --> "[object RegExp]"
console.log(({}).toString.call(1)); // --> "[object Number]"

console.log(({}).toString.call('珠峰')); // --> "[object String]"
console.log(({}).toString.call(true)); // --> [object Boolean]
console.log(({}).toString.call(undefined)); // -->[object Undefined]
console.log(({}).toString.call(null)); // -->[object Null]
console.log(({}).toString.call(function () {})); // -->[object Function]

var ary = [];
console.log(Object.prototype.toString.call(ary) === '[object Array]'); // true

var reg = /^\[object Array\]$/;
console.log(reg.test(Object.prototype.toString.call(ary))); // true

检测原型继承的情况:
function Fn() {
}
Fn.prototype = new Array;
var f = new Fn;
console.log(f instanceof Array); // true
console.log(Object.prototype.toString.call(f) === '[object Array]'); // false

----------------------------------------------------------------------------------------
块元素和行元素
块元素: 默认情况下独占一行(float浮动后除外),可控制宽高,上下边距,可嵌套块级元素或行内元素,一般作为容器出现,用来组织结构,div是最常用的块级元素,元素样式的display: block;都是块级元素,他们总是以一个块的形式表现出来,并且跟同级的兄弟块依次竖直排列,左右撑满;
(address, center, div, dl, form, h1, hr, ol, p, table, ul...)
	a.总是在新行上开始;
	b.高度,行高以及外边距和内边距都可控制;
	c.宽度确实是它的容器的100%,除非设定一个宽度;
	d.可以容纳内联元素和其他块元素;
行内元素: 也叫内联元素,只能容纳文本或其他内联元素,常见内联元素"a"。比如span元素,iframe元素和元素样式的display: inline;都是行内元素,默认情况下一行可以摆放多个元素,不可控制宽高和上下边距;
(a, b, br, em, font, i, img, input, label, span, strong...)
	a.和其他元素都在一行上;
	b.高,行高以及外边距和内边距都不可改变;
	c.宽度就是它的文字或图片的宽度,不可改变;
	d.内联元素只能容纳文本或者其他内联元素;
	e.设置宽度和高度均无效,可以通过line-height来设置,只有设置左右margin有效,上下margin无效,只有设置左右padding有效,上下padding无效
行块转换: 
	display: none;不显示
	display: block;变成块级元素
	display: inline;变成行级元素
	display: inline-block;以块级元素样式展示,以行级元素样式排列

-------------------------------------------------------------------------------------
15种CSS居中的方式:
水平居中:
1)内联元素水平居中,利用text-align: center可以实现在块级元素内部的内联元素水平居中。此方法对内联元素(inline),内联块(inline-block),内联表(inline-table),inline-flex元素水平居中都有效。
.center-text {
    text-align: center;
 }
2)块级元素水平居中,通过把固定宽度块级元素的margin-left和margin-right设成auto,就可以使块级元素水平居中。
.center-block {
  margin: 0 auto;
}
3)多块级元素水平居中
a.利用inline-block,如果一行中有两个或两个以上的块级元素,通过设置块级元素的显示类型为inline-block和父容器的text-align属性从而使多块元素水平居中。
.container {
    text-align: center;
}
.inline-block {
    display: inline-block;
}
b.利用display: flex;利用弹性布局,实现水平居中,其中justify-content用于设置弹性盒子元素在主轴(横轴)方向上的对齐方式,本例中设置子元素水平居中显示:
.flex-center {
    display: flex;
    justify-content: center;
}
垂直居中
5.单行内联(inline-)元素垂直居中
通过设置内联元素的高度(height)和行高(line-height)相等,从而使元素垂直居中
#v-box {
    height: 120px;
    line-height: 120px;
}
多行元素垂直居中
6.利用表布局(table)
利用表布局的vertical-align: middle;可以实现子元素的垂直居中;
.center-table {
    display: table;
}
.v-cell {
    display: table-cell;
    vertical-align: middle;
}
7.利用flex布局,利用flex布局实现垂直居中,其中flex-direction: column定义主轴方向为纵向。因为flex布局是CSS3中定义,在较老的浏览器中存在兼容性问题;
.center-flex {
    display: flex;
    flex-direction: column;
    justify-content: center;
}
8.利用精灵元素技术实现垂直居中,即在父容器内放一个100%高度的伪元素,让文本和伪元素垂直对齐,从而达到垂直居中的目的;
.ghost-center {
    position: relative;
}
.ghost-center::before {
    content: " ";
    display: inline-block;
    height: 100%;
    width: 1%;
    vertical-align: middle;
}
.ghost-center p {
    display: inline-block;
    vertical-align: middle;
    width: 20rem;
}
块级元素垂直居中
9.固定高度的块级元素
我们知道居中元素的高度和宽度,垂直居中问题就很简单。通过绝对定位元素距离顶部50%,并设置margin-top向上偏移元素高度的一半,就可以实现垂直居中了;
.parent {
  position: relative;
}
.child {
  position: absolute;
  top: 50%;
  height: 100px;
  margin-top: -50px; 
}
10.未知高度的块级元素
当垂直居中的元素的高度和宽度未知时,我们可以借助CSS3中的transform属性向Y轴反向偏移50%的方法实现垂直居中。但是部分浏览器存在兼容性问题。
.parent {
    position: relative;
}
.child {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
}
水平垂直居中
11.固定宽高元素水平垂直居中
通过margin平移元素整体宽度的一半,使元素水平垂直居中。
.parent {
    position: relative;
}
.child {
    width: 300px;
    height: 100px;
    padding: 20px;
    position: absolute;
    top: 50%;
    left: 50%;
    margin: -70px 0 0 -170px;
}
12.未知宽高元素水平垂直居中
利用2D变换,在水平和垂直两个方向都向反向平移宽高的一半,从而使元素水平垂直居中。
.parent {
    position: relative;
}
.child {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}
13.利用flex布局,利用flex布局,其中justify-content用于设置或检索弹性盒子元素在主轴(横轴)方向上的对齐方式,而align-items属性定义flex子项在flex容器的当前行的侧轴(纵轴)方向上的对齐方式。
.parent {
    display: flex;
    justify-content: center;
    align-items: center;
}
14.利用grid布局实现水平垂直居中,兼容性较差,不推荐
.parent {
  height: 140px;
  display: grid;
}
.child { 
  margin: auto;
}
15.屏幕上水平垂直居中,常规的登陆及注册页面都需要用到。要保证较好的兼容性,还需要用到表布局。
.outer {
    display: table;
    position: absolute;
    height: 100%;
    width: 100%;
}

.middle {
    display: table-cell;
    vertical-align: middle;
}

.inner {
    margin-left: auto;
    margin-right: auto; 
    width: 400px;
}
---------------------------------------------------------------------------------------
生成一个网页大致需要如下步骤:
1.HTML代码转化为DOM;
2.CSS代码转化成CSSOM (CSS Object Model);
3.结合DOM和CSSOM,生成一棵渲染树(包含每个节点的视觉信息);
4.生成布局(layout),即将所有渲染树的所有节点进行平面合成;   (在这里提高性能)
5.将布局绘制(paint)在屏幕上;
--------------------------------------------------------------------------------------
页面布局方式:
1)双飞翼布局(经典三列布局/圣杯布局):三列布局,中间宽度自适应,两边定宽,中间栏要在浏览器中优先展示渲染,允许任意列的高度最高,要求只用一个额外的div标签,要求用最简单的css;
2)多栏布局: 栏栅格系统,利用浮动实现的多栏布局,在bootstrap中用的非常多;多列布局,栅格系统并没有真正实现分栏效果,CSS3为了满足这个要求增加了多列布局模块;
3)弹性布局: CSS3引入了一种新的布局模式——Flexbox布局,即使他们的大小是未知或者动态的,Flexbox布局常用于设计比较复杂的页面,可以轻松的实现屏幕和浏览器窗口大小发生变化时保持元素的相对位置和大小不变,同时减少了依赖于浮动布局实现元素位置的定义以及重置元素的大小;
4)瀑布流布局: 是流式布局的一种,视觉表现为参差不齐的多栏布局,随着页面滚动条向下滚动,这种布局还会不断加载数据块并附加至当前尾部。
5)流式布局:不受窗口宽度影响,流式布局使用百分比宽度来限定布局元素,这样可以根据客户端分辨率的大小进行合理的显示。
6)响应式布局
-----------------------------------------------------------------------------------------
JavaScript中最重要的类型是对象,对象是名/值对的集合,或字符串到值映射的集合,通过"."或"[]"来访问属性;
var book = {
	topic: "JavaScript",
	fat: true
}
book.topic //"JavaScript"
book["fat"] //true
book.author = "sxw"; //通过赋值创建一个新属性
book.contents = {}; //{}是一个空对象,它没有属性

var arr = [0,1,2,3];
console.log(arr.length - 1); //数组的最后一个元素

数组和对象中都可以包含另一个数组或对象;
var points = [
	{x: 0,y: 0},
	{x: 1,y: 1}
]
var data = { //一个包含两个属性的对象,每一个属性都是数组,数组的元素也是数组
	arr1: [[1,2],[3,4]],
	arr2: [[2,3],[4,5]]
}

"two" > "three" //true,"tw"在字母表中的索引大于"th"
function fun1(x) {
	return x + 1;
}
fun1(y);
----------------------
var fun2 = function(x) { //函数是一种值,可以赋值给变量
	return x * x;
}
fun2(fun1(y)) //在一个表达式中调用两个函数

var a = [];
a.push(1,2,3);
a.reverse();

points.dist = function() { //定义一个方法用来计算两点之间的距离
	var p1 = this[0]; //通过this获得对当前数组的引用
	var p2 = this[1]; //并取得调用的数组前两个元素
	var a = p2.x - p1.x; //x坐标轴上的距离
	var b = p2.y - p1.y; //y坐标轴上的距离
	return Math.sqrt(a * a + b * b); //勾股定理,用Math.sqrt()来计算平方根
};
points.dist()

注意:如果分支中只有一条语句,花括号是可以省略的
function jc(n) { //计算阶乘的函数
	var n1 = 1;
	while(n > 1) {
		n1 *= n;
		n--;
	}
	return n1;
}
---------------------------------------
function jc(n) { //循环计算阶乘
	var i,n1 = 1;
	for(i = 2;i <= n;i ++) 
		n1 *= i;
	return n1;
}
JavaScript是一种面向对象的编程语言
---------------------------------------
function Point(x,y) { //定义一个构造函数以初始化一个新的Point对象
	this.x = x;
	this.y = y; //不需要return
}
var p = new Point(1, 1); //使用new关键字和构造函数来创建一个实例;
Point.prototype.r = function() { //给构造函数的prototype对象赋值,来给Point对象定义方法;
	return Math.sqrt(this.x * this.x + this.y * this.y);
}
p.r(); //Point的实例对象P(以及所有的Point实例对象)继承了方法r();

1.2客户端JavaScript
function moveon() {
	var answer = confirm("准备好了吗？");
	if(answer)
		window.location = "http://taobao.com";
}
setTimeout(moveon, 60000);

function debug(msg) {
	var log = document.getElementById("debug");
	if(!log) { //如果页面上找不到log,则自己创建
		log = document.createElement("div");
		log.id = "debug";
		log.innerHTML = "<h1>Debug Log</h1>";
		document.body.appendChild(log); //将其添加到文档的末尾
	}
	//将消息包装在<pre>中,并添加至log中
	var pre = document.createElement("pre");
	var text = document.createTextNode(msg);
	pre.appendChild(text);
	log.appendChild(pre);
}

function hide(e, reflow) { //通过JavaScript操纵样式来隐藏元素e
	if(reflow) { //如果第二个参数是true的话
		e.style.display = "none"; //隐藏这个元素,其所占的空间也随之消失
	}else {
		e.style.visibility = "hidden"; //将e隐藏,但是保留其所占空间
	}
}
function hightlight(e) { //通过css来显示代码高亮
	if(!e.className) {
		e.className = "hilite";
	}else {
		e.className += "hilite";
	}
}

window.onload = function() { //"load"事件只有在文档加载完成之后才会触发
	var images = document.getElementsByTagName("img"); //找到所有<img>标签
	for(var i = 0;i < images.length; i++) {
		var image = images[i];
		if(image.addEventListener) {
			image.addEventListener("click", hide, false);
		}else {								//兼容IE8及以前的版本
			image.attachEvent("onclick", hide);
		}
		function hide(event) {event.target.style.visibility = "hidden";}
	}
};
```

```
14.网络进阶
History历史记录管理
window对象通过History对象提供对浏览器历史记录的访问能力,允许用户在历史记录中自由的前进和后退,而在HTML5中,还可以操作历史记录中的数据;
1.history.pushState(stateObj1,'','bar.html')添加一条历史记录,并不会刷新页面,也就是说页面还是原来的页面,只是可以后退,前进罢了;
2.history.replaceState(stateObj,'','bar.html')替换当前历史记录,所以现在是既不能后退也不能前进,而且页面依旧是展示老的内容,并没有被新设置的页面所替换;
window.onpopstate历史记录发生变化时触发,1,2不会触发;
window.onpopstate = function(e) { //这里的e就是传过来的参数 stateObj
   console.log(e.state)
}
History属于Browser对象,Browser对象描述浏览器信息的,下有Window(全局对象,包含了所有的对象,也包括下面这些对象),Navigator(浏览器信息,浏览器版本号,浏览器品牌名称),Screen(客户端浏览器显示屏幕的信息),History(可以前进页面,可以后退页面),Location(操作URL,获取URL域名的部分,参数的部分); https://www.w3school.com.cn/jsref/dom_obj_history.asp
history.back();
history.forward();
history.go(); // -1表示后退1; 1表示往前进1
history.length; //当前页面一共有多少条历史记录了,一共前进,后退操作了多少次
----------------------------------------------------------
问题: 我们使用ajax获取数据的时候是局部获取数据,并不会进行页面的刷新,所以浏览器后退是不能够返回上一个操作的;
解决问题: 无刷新历史记录切换
----------------------------------------------------------------------------------------
Cookie使用机制:
个性化服务: HTTP是无状态的请求/相应连接,导致连接断开猴,再次连接服务器无法识别用户;
我们需要用一些技术来帮助服务器去识别用户:
1.跟踪客户端IP地址,动态IP;
2.借助http首部放置用户身份信息,referer,e-mail;
3.胖URL在URL中嵌入识别信息,丑陋,无法共享URL,非持久;
4.cookie在客户端存储用户标识信息,识别用户,持久化最好的方式;
-----------------------------------------
webStorage本地存储
1.storage本地存储
本地存储可以使用cookie,但是cookie本地存储不便:大小限制(4k),随http传输;
storage本地存储容量大(5M)仅供本地存储使用;
2.分类
sessionStorage 临时存储 浏览器关闭存储结束
localStorage 永久存储 除非用户手动删除
<script>
   localStorage.username = 'sxw'
   var obj = {
      "name": "sxw"
   }
   localStorage.obj = JSON.stringify(obj)
   var str = localStorage.obj
   console.log(JSON.parse(str))
</script>
------------------------------------
CORS跨域资源共享
1.cross-origin resource sharing(CORS)跨域资源共享,是一种使用额外HTTP首部实现跨域获取资源权限的机制;
XMLHttprequest获取非同源资源会被浏览器拦截;
eg: localhost下的资源发送XMLSttprequest请求同源,非同源资源
2.CORS分类
a.简单请求
   使用下列方法之一: GET POST HEAD
   content-Type值为下列之一: text/plain multipart/form-data application/x-www-form-urlencoded
   除了正常发送请求之外,若想实现cors跨域,还需要服务器配置正确的相应首部,否则无法获取;
   access-contral-allow-origin: *(http://localhost)访问控制允许源
b.预检请求
-------------------------------
postMessage通信
为了安全考虑,浏览器会有同源策略限制,禁止跨域访问数据,但是具有src属性的标签不受限制,可以跨域访问资源,例如:
<img src="" alt="">
<script src=""></script>
<iframe src="" frameborder="0"></iframe>
---
该window.postMessage()方法安全的启用Window对象之间的跨源通信,提供了一种受控制的机制来安全地规避这种限制;使用targetWindow.postMessage()在其上发送一个MessageEvent,然后,接收窗口可根据需要自由处理此事件,传递给window.postMessage()的参数(即“message")通过事件对象暴露给接口窗口;otherWindow.postMessage(message,targetOrigion),发送数据;message事件: 相应postMessage发送的数据;
webSocket双向通信
```

```
13.常见的HTTP状态码你了解多少?
	a)200,请求成功,一切正常,数据成功返回;
	b)301,永久性重定向,是指所请求的文档在别的地方,文档新的URL会在定位响应头信息中给出,浏览器会自动连接到新的URL;
	c)302,临时重定向,该状态码表示请求的资源已被分配了新的URI,希望用户能使用新的URI访问;
	d)303,该状态码表示由于请求对应的资源存在着另一个URI,应使用GET方法定向获取请求的资源;
	e)403,Foribidden 服务器端理解本次请求,但是拒绝执行任务,没有权限访问;
    f)404,NOT,found 请求的资源,网页无法找到,不存在;
    g)503,服务器端无法响应,服务器由于在维护或已经超载而无法响应;
```

```
12.什么情况下会遇到跨域,描述一下前端常见处理跨域的几种方式,并封装一个jsonp原理;
	浏览器最核心,最基本的安全功能是同源策略。限制了一个源中加载文本或者脚本与其他源中资源的交互方式,当浏览器执行一个脚本时会检查是否同源,只有同源的脚本才会执行,如果不同源即为跨域;
	a.Jsonp: 原理就是利用了script标签不受同源策略的限制,在页面中动态插入script,script标签的src属性就是后端api接口的地址,并且以get的方式将前端回调处理函数名称告诉后端,后端在响应请求时会将回调返还,并且将数据以参数的形式传递回去;
	b.CORS: (跨域资源共享)是一种允许当前域的资源被其他域的脚本请求访问的机制;
	当使用XMLHttpRequest发送请求时,浏览器如果发现违反了同源策略就会自动加上一个请求头: origin;后端在接受到请求后,确定响应后,会在Response Headers中加入一个属性: Access-Control-Allow-Origin,值就是发起请求的源地址,浏览器得到响应会进行判断Access-Control-Allow-Origin的值是否和当前的地址相同,只有匹配成功后才进行响应处理;现代浏览器和移动端都支持CORS,IE下需要8+;
	c.服务器跨域,服务器中转代理;
	前端向本地服务器发送请求,本地服务器代替前端再向服务器接口发送请求进行服务器间通信,本地服务器是个中转站的角色,再将响应的数据返回给前端;
```

```
11.Web前端应该从哪些方面来优化网站性能?
	a.减少页面体积,提升网络加载;
		静态资源压缩合并,(js/css代码压缩合并,雪碧图);
		静态资源缓存;
		使用CDN(内容分发网络)加载资源更快;
	b.优化页面渲染;
        css放在前面,js放后面;
        懒加载;
        减少dom操作;
```

```
10.浏览器端存储有哪些,并描述他们的区别;
cookie / localStorage / sessionStorage 他们都是保存在浏览器端,且同源;
区别:
	a.cookie数据始终在同源的http请求中携带,即cookie在浏览器和服务器间来回传递;而sessionStorage和localStorage不会自动把数据发给服务器,仅在本地保存;
	b.存储大小限制也不同;cookie数据不能超过4k,同时因为每次http请求都会携带cookie,所以cookie只适合保存很小的数据,如会话标识;sessionStorage和localStorage 虽然也有存储大小的限制,但比cookie大得多,可以达到5M或更大;
	c.数据有效期不同,sessionStorage仅在当前浏览器窗口关闭前有效,自然也就不可能持久保持;localStorage 始终有效,窗口或浏览器关闭也一直保存,因此用作持久数据;cookie只在设置的cookie过期时间之前一直有效,即使窗口或浏览器关闭;
	d.作用域不同,sessionStorage不在不同的浏览器窗口中共享,即使是同一个页面;localStorage在所有同源窗口中都是共享的;cookie也是在所有同源窗口中都是共享的;
```

```
9.get和post请求
	a.默认是get方式;
	b.GET请求只能进行url编码,而POST支持多种编码方式;
	c.GET请求参数会被完整保留在浏览器历史记录里,而POST中的参数不会被保留;
	d.GET请求在URL中传送的参数是有长度限制的,而POST没有;
	e.对参数的数据类型: GET只接受ASCII字符,而POST没有限制;
	f.安全性,GET比POST更不安全,因为参数直接暴露在URL上,所以不能用来传递敏感信息;
	g.GET参数通过URL传递,POST放在Request body中;
	h.GET产生一个TCP数据包,POST产生两个TCP数据包;
	i)对于GET方式的请求,浏览器会把http header和data一并发送出去,服务器响应200(返回数据);而对于POST,浏览器先发送header,服务器响应100 continue,浏览器再发送data,服务器响应200 ok(返回数据);
```

```
8.一个页面从输入URL到页面加载完的过程中都发生了什么事情？
    浏览器根据DNS服务器解析得到域名的IP地址;
    向这个IP的机器发送HTTP请求;
    服务器收到,处理并返回HTTP请求;
    浏览器得到返回内容;
    渲染过程;
    根据HTML结构生成DOM树;
    根据CSS生成CSSOM;
    将DOM和CSSOM整合形成RenderTree;
    根据RenderTree开始渲染和展示;
```

```
7.数组去重(至少三种);
	a.set
        function handle() {
            return Array.from(new Set(arr));
        }
	b.indexOf
        var newArr = [];
        arr.forEach(function(item) {
            if(newArr.indexOf(item) == -1) {
                newArr.push(item);
            }
        })
	c.利用对象的属性不能相同的特点进行去重
        var out = {}
        var outArr = [];
        for(var i = 0;i < arr.length;i ++) {
            if(!out[arr[i]]) {
                out[arr[i]] = 1;
                outArr.push(arr[i])
            }
        }
	d.使用splice
        var len = arr.length
        for(var i = 0;i < len;i ++) {
            for(var j = i + 1;j < len;j ++) {
                if(arr[i] == arr[j]) {
                    arr.splice(j,1);
                    len --;
                    j --;
                }
            }
        }
```

```
6.深拷贝
function deepClone() {
    return JSON.parse(JSON.stringify(arr));
}
-----------------------------------------------
function deepClone(obj) {
	var newObj = obj instanceof Array ? [] : {};
	if(typeof obj != 'object') return obj;
	for(var prop in obj) {
		newObj[prop] = typeof obj[prop] == 'object' ? deepClone(obj[prop] : obj[prop])
	}
	return newObj;
}
```

```
5.TCP三次握手与四次挥手:
TCP是主机对主机层的传输控制协议,提供可靠的连接服务,采用三次握手确认建立一个连接:
tcp标志位有6种:
	SYN(建立连接)
	ACK(响应、确认)
	PSH(有DATA数据传输)
	FIN(关闭连接)
	RST(连接重置)
	URG(紧急指针字段值有效)
--------------------------------------------------------------
三次握手:
第一次握手: 客户端发送syn包(syn=x)到服务器,并进入SYN_SEND状态,等待服务器确认;
第二次握手: 服务器收到syn包,必须确认客户的SYN(ack=x+1),同时自己也发送一个SYN包(syn=y)即SYN+ACK包,此时服务器进入SYN_RECV状态;
第三次握手: 客户端收到服务器的SYN＋ACK包,向服务器发送确认包ACK(ack=y+1),此包发送完毕,客户端和服务器进入ESTABLISHED状态,完成三次握手;
握手过程中传送的包里不包含数据,三次握手完毕后,客户端与服务器才正式开始传送数据;
理想状态下,TCP连接一旦建立,在通信双方中的任何一方主动关闭连接之前,TCP连接都将被一直保持下去;
------------------------------------------------------------------------------
四次挥手:
第一次挥手: 主动关闭方发送一个FIN,主动关闭方告诉被动关闭方: 我已经不会再给你发数据了,但是此时主动关闭方还可以接受数据;
第二次挥手: 被动关闭方收到FIN包后,发送一个ACK给对方,确认序号为收到序号+1;
第三次挥手: 被动关闭方发送一个FIN,用来关闭被动关闭方到主动关闭方的数据传送,也就是告诉主动关闭方,我的数据也发送完了,不会再给你发数据了;
第四次挥手: 主动关闭方收到FIN后,发送一个ACK给被动关闭方,确认序号为收到序号+1,至此,完成四次挥手;
主动关闭方向被动关闭方发送不会再给你发数据了的信息;被动关闭方对收到的主动关闭方的报文段进行确认;被动关闭方向主动关闭方发送我也不会再给你发数据了的信息;主动关闭方再次对被动关闭方的确认进行确认;
```

```
4.http与https的区别:
	http是超文本传输协议,用于定义浏览器与服务器之间交换数据的过程,信息是明文传输,,https则是具有安全性的ssl加密传输协议,HTTP协议用于定义客户端与web服务器通迅的格式;
	http的连接很简单,是无状态的;HTTPS协议是由SSL+HTTP协议构建的可进行加密传输,身份认证的网络协议,比http协议安全;
```

```
3.重排(回流)和重绘是什么?
重绘: 
浏览器会把HTML解析成DOM,把CSS解析成CSSOM;
DOM和CSSOM合并就产生了Render Tree;
有了Render Tree,我们就知道了所有节点的样式,然后计算他们在页面上的大小和位置,最后把节点绘制到页面上;
-------------------------------------------------------------------------------------
回流: 
当Render Tree中部分或全部元素的尺寸,结构,或某些属性发生改变时,浏览器重新渲染的过程称为回流;
* * *
回流触发的情况: 
页面首次渲染;浏览器窗口大小发生改变;元素尺寸或位置发生改变;元素内容变化;元素字体大小变化;添加或者删除可见的DOM元素;触发display: none;
------------------------------------
当页面中元素样式的改变并不影响它在文档流中的位置时(color,background-color,visibility),浏览器会将新样式赋予给元素并重新绘制它,这个过程称为重绘;
```

```
2.浏览器执行时间线:
	a)创建document对象,开始解析web页面,此时document.readyState = ’loading’;
	b)遇到link标签(外部引用css)创建线程加载(异步加载),并继续解析文档;
	c)遇到非异步的script标签,浏览器加载并阻塞,等待js加载完成;
	d)遇到异步的script标签,浏览器创建线程加载,并继续解析文档;
		对于async属性的脚本,脚本加载完成后立即执行;
		对于defer属性的脚本,脚本等到页面加载完之后再执行(异步禁止使用document.write);
	e)遇到img等,先正常解析dom结构,然后浏览器异步加载src,并继续解析文档;
	f)当文档解析完成之后,renderTree构建完成,document.readyState=‘interative’,活跃的;
	g)文档解析完成后,所有设置有defer的脚本会按照顺序执行;
	h)文档解析完成之后,页面会触发document上的一个DOMContentLoad事件;
	i)当页面都执行完成之后document.readyState = ‘complete’,之后就可以执行window.onload事件;
```

```
1.js异步加载的三种方式:
    a)defer: DOM文档全部解析完才会执行,只有IE能用,不阻塞页面;
    b)async: 加载完就执行,只能加载外部脚本,不阻塞页面;
    c)创建script: 插入到DOM中,加载完毕后callBack;
```

